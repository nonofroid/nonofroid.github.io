<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>20岁的天空</title>
    <url>/undefined/%E6%80%9D%E8%80%83/20%E5%B2%81%E7%9A%84%E5%A4%A9%E7%A9%BA/</url>
    <content><![CDATA[<p>人有时往往会在一瞬间认识到自己的内心，这或许是一个质变的过程，然后紧接着继续发生量变。<br>我觉得人类是在我认知范围内最邪恶的物种。我们通过压榨剥削、洗脑欺骗、暴力奴役等手段建立了稳定的社会制度，权力与财富集中在少数人手中，普罗大众心甘情愿沉迷于“奶头乐”。权色与金钱奴役着人类，这种无序的状态究竟还要持续到什么时候？</p>
<blockquote>
<p><a href="https://nonowithpassion.notion.site/0c032de31cc541d5a3cf76ce343bd062">我的个人图书馆</a></p>
</blockquote>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解计算机系统(CSAPP)笔记</title>
    <url>/undefined/%E5%AD%A6%E4%B9%A0/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-csapp-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="深入理解计算机系统笔记-CSAPP"><a href="#深入理解计算机系统笔记-CSAPP" class="headerlink" title="深入理解计算机系统笔记(CSAPP)"></a>深入理解计算机系统笔记(CSAPP)</h1><p><img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2F-MHtt00XBvS4gFjhfw7b%2F-MHttfdsLWUPlWSz8ANj%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%20%E5%8E%9F%E4%B9%A6%E7%AC%AC3%E7%89%88.pdf..20200922190952319_00.png?alt=media&token=f65abe2d-0a5c-4e2c-91b8-5f008051209c" alt="img"></p>
<blockquote>
<p>作者：兰德尔 E. 布莱恩特</p>
</blockquote>
<span id="more"></span>

<h2 id="第-1-章：计算机系统漫游"><a href="#第-1-章：计算机系统漫游" class="headerlink" title="第 1 章：计算机系统漫游"></a><strong>第 1 章：计算机系统漫游</strong></h2><p><strong>计算机系统</strong>是由硬件和系统软件组成的，它们共同工作来运行应用程序。虽然系统的具体实现方式随着时间不断变化，但是系统内在的概念却没有改变。所有计算机系统都有相似的硬件和软件组件，它们又执行着相似的功能。一些程序员希望深入了解这些组件是如何工作的以及这些组件是如何影响程序的正确性和性能的，以此来提高自身的技能。本书便是为这些读者而写的。</p>
<p>现在就要开始一次有趣的漫游历程了。如果你全力投身学习本书中的概念，完全理解底层计算机系统以及它对应用程序的影响，那么你会步上成为为数不多的“大牛”的道路。</p>
<p>你将会学习一些实践技巧，比如如何避免由计算机表示数字的方式引起的奇怪的数字错误。你将学会怎样通过一些小窍门来优化自己的 C 代码，以充分利用现代处理器和存储器系统的设计。你将了解编译器是如何实现过程调用的，以及如何利用这些知识来避免缓冲区溢出错误带来的安全漏洞，这些弱点给网络和因特网软件带来了巨大的麻烦。你将学会如何识别和避免链接时那些令人讨厌的错误，它们困扰着普通的程序员。你将学会如何编写自己的 Unix shell、自己的动态存储分配包，甚至于自己的 Web 服务器。你会认识并发带来的希望和陷阱，这个主题随着单个芯片上集成了多个处理器核变得越来越重要。</p>
<p>在 Kernighan 和 Ritchie 的关于 C 编程语言的经典教材【61】中，他们通过图 1-1 中所示的 hello 程序来向读者介绍 C。尽管 hello 程序非常简单，但是为了让它实现运行，系统的每个主要组成部分都需要协调工作。从某种意义上来说，本书的目的就是要帮助你了解当你在系统上执行 hello 程序时，系统发生了什么以及为什么会这样。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello, world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们通过跟踪 hello 程序的生命周期来开始对系统的学习——从它被程序员创建开始，到在系统上运行，输出简单的消息，然后终止。我们将沿着这个程序的生命周期，简要地介绍一些逐步出现的关键概念、专业术语和组成部分。后面的章节将围绕这些内容展开。</p>
<h3 id="1-1-信息就是位-上下文"><a href="#1-1-信息就是位-上下文" class="headerlink" title="1.1 信息就是位 + 上下文"></a><strong>1.1 信息就是位 + 上下文</strong></h3><p>hello 程序的生命周期是从一个<strong>源程序</strong>（或者说源文件）开始的，即程序员通过编辑器创建并保存的文本文件，文件名是 hello.c。源程序实际上就是一个由值 0 和 1 组成的位（又称为比特）序列，8 个位被组织成一组，称为字节。每个字节表示程序中的某些文本字符。</p>
<p>大部分的现代计算机系统都使用 ASCII 标准来表示文本字符，这种方式实际上就是用一个唯一的单字节大小的✦整数值✦来表示每个字符。比如，图 1-2 中给出了 hello.c 程序的 ASCII 码表示。</p>
<p><img src="https://1087580735-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MHt_spaxGgCbp2POnfq%2Fsync%2Fb21fa77cbcdfba62be01af7b13234cf5eed3c055.png?generation=1624553050781139&alt=media" alt="img"></p>
<p>hello.c 程序是以字节序列的方式储存在文件中的。每个字节都有一个整数值，对应于某些字符。例如，第一个字节的整数值是 35，它对应的就是字符 “#”。第二个字节的整数值为 105，它对应的字符是 ‘i’，依此类推。注意，每个文本行都是以一个看不见的换行符 ‘\n’ 来结束的，它所对应的整数值为 10。像 hello.c 这样只由 ASCII 字符构成的文件称为<strong>文本文件</strong>，所有其他文件都称为<strong>二进制文件</strong>。</p>
<p>hello.c 的表示方法说明了一个基本思想∶系统中所有的信息——包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串<strong>比特</strong>表示的。区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。比如，在不同的上下文中，一个同样的字节序列可能表示一个整数、浮点数、字符串或者机器指令。 作为程序员，我们需要了解数字的机器表示方式，因为它们与实际的整数和实数是不同的。它们是对真值的有限近似值，有时候会有意想不到的行为表现。这方面的基本原理将在第 2 章中详细描述。</p>
<blockquote>
<p><strong>旁注 编程语言的起源</strong></p>
<p>C 语言是<strong>贝尔实验室</strong>的 <strong>Dennis Ritchie</strong> 于 <strong>1969 年 ~ 1973 年间创建的。</strong>美国国家标准学会（American National Standards Institute，ANSI）在 1989 年颁布了 ANSI C 的标准，后来 C 语言的标准化成了国际标准化组织（International StandardsOrganization，ISO）的责任。这些标准定义了C语言和一系列函数库，即所谓的 <strong>C 标准库</strong>。Kernighan 和 Ritchie 在他们的经典著作中描述了 ANSI C，这本著作被人们满怀感情地称为 “K&amp;R”【61】。用 Ritchic 的话来说【92】，C 语言是“古怪的、有缺陷的，但同时也是一个巨大的成功”。为什么会成功呢?</p>
<ul>
<li><strong>C 语言与 Unix 操作系统关系密切。</strong>C 从一开始就是作为一种用于 Unix 系统的程序语言开发出来的。大部分 Unix 内核（操作系统的核心部分），以及所有支撑工具和函数库都是用 C 语言编写的。20 世纪 70 年代后期到 80 年代初期，Unix 风行于高等院校，许多人开始接触 C 语言并喜欢上它。因为 Unix 几乎全部是用 C 编写的，它可以很方便地移植到新的机器上，这种特点为 C 和 Unix 赢得了更为广泛的支持。</li>
<li><strong>C 语言小而简单。</strong>C语言的设计是由一个人而非一个协会掌控的，因此这是一个简洁明了、没有什么冗赘的设计。K&amp;R 这本书用大量的例子和练习描述了完整的 C 语言及其标准库，而全书不过  261 页。C 语言的简单使它相对而言易于学习，也易于移植到不同的计算机上。 </li>
<li><strong>C语言是为实践目的设计的。</strong>C 语言是设计用来实现 Unix 操作系统的。后来，其他人发现能够用这门语言无障碍地编写他们想要的程序。</li>
</ul>
<p>C 语言是系统级编程的首选，同时它也非常适用于应用级程序的编写。然而，它也并非适用于所有的程序员和所有的情况。C 语言的指针是造成程序员困惑和程序错误的一个常见原因。同时，C 语言还缺乏对非常有用的抽象的显式支持，例如类、对象和异常。像 C++ 和 Java 这样针对应用级程序的新程序语言解决了这些问题。</p>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
        <category>专业基础</category>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统概念笔记</title>
    <url>/undefined/%E5%AD%A6%E4%B9%A0/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="操作系统概念"><a href="#操作系统概念" class="headerlink" title="操作系统概念"></a>操作系统概念</h1><p>操作系统位于用户与计算机硬件之间。操作系统是管理计算机硬件的软件。</p>
<h2 id="第一章-导论"><a href="#第一章-导论" class="headerlink" title="第一章 导论"></a>第一章 导论</h2><p><strong>操作系统</strong>是管理计算机硬件的程序，充当计算机用户和硬件的中介。</p>
<blockquote>
<p>我们的目标：</p>
<ol>
<li>描述计算机系统的基本组成</li>
<li>概述操作系统的组件</li>
<li>概述多种类型的计算环境</li>
<li>探讨多个开源的操作系统</li>
</ol>
</blockquote>
<span id="more"></span>

<h3 id="1-1-操作系统的功能"><a href="#1-1-操作系统的功能" class="headerlink" title="1.1 操作系统的功能"></a>1.1 操作系统的功能</h3><p>计算机系统可以粗分为4个组件：硬件、操作系统、应用程序和用户。</p>
<p>硬件：如中央处理单元(CPU)、内存(memory)、输入/输出设备(I/O device)。提供基本的计算资源。</p>
<p>用户程序：规定了用户为解决计算问题而使用这些资源的方式。</p>
<p>操作系统：控制硬件。</p>
<p>计算机系统可以分为硬件、软件和程序。</p>
<h4 id="1-1-1-用户视角"><a href="#1-1-1-用户视角" class="headerlink" title="1.1.1 用户视角"></a>1.1.1 用户视角</h4><img src="操作系统概念.assets/image-20220703152411343.png" alt="image-20220703152411343" style="zoom: 80%;" />

<p>PC用户：操作系统设计的主要目的是用户<strong>使用方便</strong>，次要的方便，不在乎资源利用。</p>
<p>操作系统是一个桥梁，管理硬件。</p>
<p>不同的其他视角：</p>
<p>1.大型机小型机相连：优化资源利用率。</p>
<p>2.工作站与服务器相连：兼顾使用方便性和资源利用率。</p>
<p>3.移动设备的普及：通过触摸屏交互。</p>
<p>4.嵌入式设备：家电和汽车等嵌入式计算机。</p>
<h4 id="1-1-2-系统视角"><a href="#1-1-2-系统视角" class="headerlink" title="1.1.2 系统视角"></a>1.1.2 系统视角</h4><p>操作系统可被视为资源分配器。</p>
<p>稍微不同的另一个视角是：强调控制各种I/O设备和用户程序的需求。<strong>控制程序</strong>管理用户程序的执行，以防止计算机资源的错误或不当使用。它特别注重I/O设备的运行和控制。</p>
<h4 id="1-1-3-操作系统的定义"><a href="#1-1-3-操作系统的定义" class="headerlink" title="1.1.3 操作系统的定义"></a>1.1.3 操作系统的定义</h4><p>前言：</p>
<p>20世纪60年代，摩尔定律预测集成电路可容纳元器件的数目每隔18个月便会翻倍。</p>
<p>公认的定义：管理计算机硬件与软件资源的计算机程序。</p>
<p>通常称为<strong>内核</strong>：系统程序和应用程序。</p>
<h3 id="1-2-计算机系统的组成"><a href="#1-2-计算机系统的组成" class="headerlink" title="1.2 计算机系统的组成"></a>1.2 计算机系统的组成</h3><h4 id="1-2-1-计算机系统的运行"><a href="#1-2-1-计算机系统的运行" class="headerlink" title="1.2.1 计算机系统的运行"></a>1.2.1 计算机系统的运行</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5.assets/image-20220703155146827.png" alt="image-20220703155146827"></p>
<p>现代通用计算机包括一个或多个CPU和若干设备控制器，通过公用总线相连而成。总线提供了共享内存的访问。</p>
<p>通过内存控制器协调访问内存。</p>
<p>引导程序：开机时，需要运行一个初始程序，该程序位于计算机的固件(如只读内存ROM或电可擦编程只读内存EEPROM)。引导程序必须知道如何加载操作系统并开始执行系统。</p>
<p>引导程序要知道如何加载操作系统并开始执行系统。为了完成这一目标，引导程序必须定位操作系统内核并加载到内存。</p>
<p>一旦内核加载到内存并执行，它开始为系统与用户提供服务。系统程序也提供一些服务，它们在启动时加到内存而成为系统进程或系统后台程序。</p>
<p>事件发生通过<strong>中断</strong>来通知。软件可以通过<strong>系统调用</strong>触发中断。</p>
<img src="操作系统概念.assets/image-20220703174055435.png" alt="image-20220703174055435" style="zoom:67%;" />

<p>当CPU被打断，CPU停止正在做的事，并立即转到固定位置再继续执行。该固定位置通常包含中断服务程序的开始地址。中断服务程序开始执行，在执行完后，CPU重新执行中断的计算。</p>
<p>中断是计算机体系结构中重要组成部分。中断应将控制转移到合适的中断服务程序。通常，指针表位于低地址内存。这些位置包含各种设备的中断处理程序的地址。这种地址的数组或中断向量，可以通过唯一的设备号来索引。</p>
<p>中断体系结构也应保存中断指令的地址。许多以前的设计只是简单地将中断地址保存在某个固定位置或可用设备号来索引的位置。现代体系结构将返回地址保存在系统堆栈上。如果中断程序需要修改处理器状态，如修改寄存器的值，则应明确保存当前状态，并在返回之前恢复该状态。处理中断后，保存的返回地址会加载到程序计数器。</p>
<h4 id="1-2-2-存储结构"><a href="#1-2-2-存储结构" class="headerlink" title="1.2.2 存储结构"></a>1.2.2 存储结构</h4><p>内存：随机访问内存(RAM)，内存通常动态随机访问内存(DRAM)，采用半导体技术实现。</p>
<p>只读内存：ROM，数据不可修改，不可写。</p>
<p>电可擦可编程只读内存：EEPROM，可以修改，但是不能经常修改，可保存大部分静态程序。应用：智能手机。</p>
<p>内存特点：易丢失，掉电丢失数据。</p>
<p>外村：非易失性，数据可持久化。</p>
<p>内存提供字节数组，字节都有地址。通过<code>load</code>或<code>store</code>实现。指令<code>load</code>将内存字节或字保存到CPU寄存器，而指令<code>store</code>将寄存器内容保存到内存。</p>
<p>在冯·诺依曼体系结构（von Neumann architecture)上执行时，一个典型的指令执行周期是，首先从内存中获取指令，并存到指令寄存器( instruction register)。接着，该指令被解码，也可能会从内存中获取操作数据并且存到内部寄存器。在指令完成对操作数据的执行后，结果也可存到内存。</p>
<blockquote>
<p>注意:内存单元只能看到内存地址的流，而并不知道它们如何产生(通过指令计数器、索引、间接、常量地址或其他方式)或它们是什么样(指令或数据）的地址。相应地，我们可以忽略程序如何产生内存地址，而只关注由程序运行所生成的地址序列。</p>
</blockquote>
<p>程序和数据不可能永久驻留在内存中：内存太少或者内存易失性。</p>
<p>所以需要<strong>外存</strong>。</p>
<p>外存设备：磁盘，硬盘，高速缓存，CD-ROM，磁带等。程序执行时才加载到内存。各个存储系统差异在于速度、价格、大小和易失性等。</p>
<p>易失存储会丢失内容；非易失性存储不易丢失。</p>
<p><strong>固态磁盘：</strong>非易失性，一般比磁盘块。</p>
<p>固态磁盘(solid-state disk)有多种类型，一般来说都比磁盘要快，也是非易失的。一种类型的固态磁盘在运行时将数据保存在一个大的DRAM数组上，它有一个隐藏磁盘和一个作为备份电源的电池。当外部电源被中断时，固态磁盘控制器将数据从RAM复制到磁盘。当外部电源恢复后，控制器将数据复制到RAM。另一种固态磁盘是<strong>闪存</strong>，它在照相机、个人数字助理(Personal Digital Assistant，PDA)和机器人中很受欢迎，并越来越多地作为通用计算机的存储。闪存比DRAM慢，但是无需电源以便保存内容。另一种非易失性存储器是NVRAM，即具有备用电池的DRAM。这种存储与DRAM一样快，且是非易失的(只要电池有电)。</p>
<p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5.assets/image-20220703183936217.png" alt="image-20220703183936217"></p>
<h4 id="1-2-3-I-O结构"><a href="#1-2-3-I-O结构" class="headerlink" title="1.2.3 I/O结构"></a>1.2.3 I/O结构</h4><p>每个通用计算机系统由一个CPU和多个设备控制器组成，它们通过共同总线连在一起。每个设备控制器管理某一特定类型的设备。根据设备控制器的特性，可以允许多个设备与其相连。例如，<strong>小型计算机系统接口</strong>（Small Computer System Interface，SCSI)控制器可连接7个或更多的设备。每个设备控制器维护一定量的本地缓冲存储和一组特定用途的寄存器。设备控制器负责在所控制的外围设备与本地缓冲存储之间进行数据传递。</p>
<p>通常，操作系统为每个设备控制器提供一个<strong>设备驱动程序</strong>( device driver)。该设备驱动程序负责设备控制器,并且为操作系统的其他部分提供统一的设备访问接口。</p>
<p>在开始IO时，设备驱动程序加载设备控制器的适当寄存器。相应地，设备控制器检查这些寄存器内容，以便决定采取什么操作（如“从键盘中读取一个字符”)。控制器开始从设备向本地缓冲区传输数据。一旦完成数据传输，设备控制器就会通过中断通知设备驱动程序，它已完成了操作。然后，设备驱动程序返回控制到操作系统。对于读操作，数据或数据指针也会返回;而对于其他操作，设备驱动程序返回状态信息。</p>
<p>通过<strong>直接内存访问DMA</strong>，为设备控制器可在本地缓冲和内存之间传送整块的数据，而无需CPU的干预。每块只能产生一个中断。</p>
<p>一些高端系统采用交换而不是总线结构。在这些系统中，多个组件可以与其他组件同时对话，而不是竞争公共总线的周期，此时的DMA更为有效。</p>
<p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5.assets/image-20220703185117788.png" alt="image-20220703185117788"></p>
<h3 id="1-3-计算机系统的体系结构"><a href="#1-3-计算机系统的体系结构" class="headerlink" title="1.3 计算机系统的体系结构"></a>1.3 计算机系统的体系结构</h3><h4 id="1-3-1-单处理器系统"><a href="#1-3-1-单处理器系统" class="headerlink" title="1.3.1 单处理器系统"></a>1.3.1 单处理器系统</h4><p>直到最近，大多数系统仍采用单处理器。单处理器系统只有一个主CPU，以便执行一个通用指令集，该指令集包括执行用户进程的指令。几乎所有单处理器系统都带有其他专用处理器。它们或为特定设备的处理器，如磁盘、键盘、图形控制器;或为更通用的处理器,如在系统组件之间快速移动数据的I/O处理器。</p>
<p>所有这些专用处理器执行<strong>有限指令集</strong>，<strong>而并不执行用户进程</strong>。在有的环境下，它们由操作系统来管理，此时操作系统将要做的任务信息发给它们，并监控它们的状态。例如，磁盘控制器的微处理器接收来自主CPU的一系列请求，并执行自己的磁盘队列和调度算法。这种安排使得主CPU不必再执行磁盘调度。PC的键盘有一个微处理器来将击键转换为代码,并发送给CPU。在其他的环境下，专用处理器作为低层组件集成到硬件。操作系统不能与这些处理器通信，但是它们可以自主完成任务。专用处理器的使用十分常见，但是这并不能将一个单处理器系统变成多处理器系统。如果系统只有一个通用CPU，那么就为单处理器系统。</p>
<h4 id="1-3-2-多处理系统"><a href="#1-3-2-多处理系统" class="headerlink" title="1.3.2 多处理系统"></a>1.3.2 多处理系统</h4><p>多处理器系统，也称为并行系统或多核系统。这类系统有两个或多个紧密通信的CPU，共享计算机总线、时钟、内存和外设。</p>
<p>优点：</p>
<ol>
<li>增加吞吐量：增加处理器数量；采用N个处理器加速比小于N。</li>
<li>规模经济：多处理器系统价格小于相同功能多个单个处理器系统的价格，因为前者可以共享。</li>
<li>增加可靠性：关于失灵。</li>
</ol>
<p><strong>适度退化：</strong>根据剩余有效硬件的级别按比例继续提供服务的能力。</p>
<p>有的系统超过适度退化，称为<strong>容错</strong>，因为它们能够容忍单个部件错误，并且仍然继续运行。</p>
<p><strong>非对称处理：</strong>每个处理器有各自特定的任务。</p>
<blockquote>
<p>主从关系：一个主处理器控制系统，其他处理器或者向主处理器要任务或做预先规定的任务。主处理器调度从处理器，并安排工作。</p>
</blockquote>
<p>**对称多处理(Symmetric MultiProcessing,SMP)**：每个处理器都参与完成操作系统的所有任务。SMP表示所有处理器对等，处理器之间没有主从关系。每个处理器都有自己的寄存器集，也有私有或本地缓存。所有处理器都共享物理内存。SMP的一个例子是AIX，这是IBM设计的一种商用版UNIX。每个AIX系统可以配有多个处理器。</p>
<p>优点：许多进程可以同时执行。各个CPU互相独立，通过共享一定的数据结构可以避免低效。</p>
<p>例子：现代操作系统都支持SMP</p>
<img src="操作系统概念.assets/image-20220704125321425.png" alt="image-20220704125321425" style="zoom:50%;" />

<p>多处理通过增加CPU提高计算能力。多处理可使系统的内存访问模型，从均匀内存访问UMA改成非均匀内存访问NUMA。对UMA，CPU访问RAM的所需时间相同；对于NUMA，有的内存访问的所需时间更多。</p>
<p>CPU设计的最新趋势是：集成多个计算核到单个芯片(多核)。更高效，消耗低。</p>
<img src="操作系统概念.assets/image-20220704130135254.png" alt="image-20220704130135254" style="zoom:50%;" />

<p>每个核都有自己的寄存器和本地缓存。这些多核CPU对于操作系统就像N个标准处理器。</p>
<blockquote>
<p>刀片服务器：<a href="https://zh.m.wikipedia.org/zh-hans/%E5%88%80%E9%8B%92%E4%BC%BA%E6%9C%8D%E5%99%A8">刀片服务器 - 维基百科，自由的百科全书 (wikipedia.org)</a>：一种单板型态的伺服器，于2001年由<a href="https://zh.m.wikipedia.org/w/index.php?title=RLX&action=edit&redlink=1">RLX</a>公司提出。</p>
</blockquote>
<h4 id="1-3-3-集群系统"><a href="#1-3-3-集群系统" class="headerlink" title="1.3.3 集群系统"></a>1.3.3 集群系统</h4><p>集群系统：另一类型的多处理器系统是集群系统。</p>
<p>集群系统由两个或多个独立系统组成，这样的系统称为<strong>松耦合的</strong>。每个节点可为单处理器系统或多核系统。</p>
<p>公认的定义：集群计算机共享存储，并且采用LAN (Local Area Network，局域网）连接或更快的内部连接，如 InfiniBand。</p>
<p>集群通常用于提供高可用性( high availability)服务，这意味着即使集群中的一个或多个系统出错，仍可继续提供服务。一般来说，通过在系统中增加一定冗余，可获取高可用性。每个集群节点都执行集群软件层，以监视（通过局域网)一个或多个其他节点。如果被监视的机器失效，那么监视机器能够取代存储的拥有权，并重新启动在失效机器上运行的应用程序。应用程序的用户和客户只会感到短暂的服务中止。</p>
<p>集群可以是对称的，也可以是非对称的。对于<strong>非对称集群</strong>(asymmetric clustering)，一台机器处于<strong>热备份模式</strong>( hot-standby mode)，而另一台运行应用程序。热备份主机只监视活动服务器。如果活动服务器失效，那么热备份主机变成活动服务器。对于对称集群(symmetricclustering)，两个或多个主机都运行应用程序，并互相监视。由于充分使用现有硬件，当有多个应用程序可供执行时,这种结构更为高效。</p>
<p>每个集群由通过网络相连的多个计算机系统组成，也可提供<strong>高性能计算</strong>(high-performance computing)环境。每个集群的所有计算机可以并发执行一个应用程序，因此与单处理器和SMP系统相比，这样的系统能够提供更为强大的计算能力。当然，这种应用程序应当专门编写，才能利用集群。这种技术称为<strong>并行计算</strong>( parallelization)，即将一个程序分成多个部分，而每个部分可以并行运行在计算机或集群计算机的各个核上。通常，这类应用中的每个集群节点解决部分问题，而所有节点的计算结果合并在一起，以便形成最终解决方案。</p>
<p>其他形式的集群还有并行集群和<strong>WAN ( Wide-Area Network)集群</strong>。并行集群允许多个主机访问共享存储的同一数据。由于大多数操作系统并不支持多个主机同时访问数据，并行集群通常需要由专门软件或专门应用程序来完成。例如，Oracle Real Application Cluster就是一种可运行在并行集群上的、专用的Oracle数据库。每个机器都运行Oracle，而且软件层跟踪共享磁盘的访问。每台机器对数据库内的所有数据都可以完全访问。为了提供这种共享访问，系统应当针对文件访问加以控制与加锁，以便确保没有冲突操作。有的集群技术包括了这种通常称为<strong>分布锁管理器</strong>（Distributed Lock Manager，DLM)的服务。</p>
<blockquote>
<p>Beowulf集群</p>
<p>Beowulf集群的设计用于解决高性能的计算任务。每个 Beowulf集群由商用硬件（如个人计算机)，通过简单的LAN而连在一起。这种集群无需特定软件包，每个节点采用开源软件库来通信。因此每个 Beowulf集群的构成方法有很多。通常，每个 Beowulf计算节点都运行Linux操作系统。由于并不要求专门硬件而只采用免费的开源软件，构成这种高性能计算的集群更为经济。实际上，有的Beowulf集群采用数百台遗弃的计算机，以便解决大运算量的科学计算问题。</p>
</blockquote>
<p>集群技术发展迅速。有的集群产品支持数十个系统，而且集群节点也可分开数公里之远。<strong>存储域网</strong>(Storage-Area Network，SAN)的出现也改进了集群性能;如12.3.3节所述,SAN可让许多系统访问同一存储池。SAN可以存储应用程序和数据，集群软件可将应用程序交给SAN的任何主机来执行。如果主机出错，那么其他主机可以接管过来。对于数据库集群，数十个主机可以共享同一数据库，从而大大提升了性能和可用性。图1-8显示了一个集群的通用结构。</p>
<h3 id="1-4-操作系统的结构"><a href="#1-4-操作系统的结构" class="headerlink" title="1.4 操作系统的结构"></a>1.4 操作系统的结构</h3><p>操作系统最重要的能力：<strong>多道程序设计</strong>，为了提高CPU利用率。</p>
<p>操作系统在内存中同时保存多个任务。由于贮存太小不能容纳所有作业，因此这些作业首先保存在磁盘的作业池上。作业池上包括磁盘上的、等待分配内存的所有进程。</p>
<p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5.assets/image-20220704142529296.png" alt="image-20220704142529296"></p>
<p>内存的作业集为作业池的作业集的一个子集。只要有一个任务可以执行，CPU就不会空闲。</p>
<p><strong>分时系统</strong>是多道程序设计的自然延伸。</p>
<p>分时系统要求计算机可交互，响应时间要短。</p>
<p>分时操作系统采用CPU调度和多道程序设计，为每个用户提供一小部分的分时计算机资源。**每个用户至少有一个程序在内存中。加载到内存并执行的程序，通常称为进程( process)**。当进程执行时，它通常在执行较短的一段时间后，要么完成，要么需要进行IО操作。I/O可以是交互的，即输出是到用户显示器，输入来自用户键盘、鼠标或其他设备。由于交互IO通常按人类速度（ people speed)来进行，因此可能需要很长时间完成。例如，输入通常受限于用户打字速度，每秒7个字符对人类来说可能很快，但是对计算机来说太慢了。在用户进行交互输入时，操作系统为了不让CPU空闲，会将CPU切换到其他用户程序。</p>
<p><strong>作业调度：</strong>系统对作业做出选择。从作业池中选出一个作业，并将它调入内存。内存同时包括多个程序。</p>
<p><strong>交换</strong>：可将进程从磁盘调入内存，也可将进程从内存调到磁盘。</p>
<p><strong>虚拟内存：</strong>是实现合理响应时间的更为常用的一种方法，虚拟内存允许一个执行作业不必完全在内存中。优点：用户可执行比物<strong>理内存( physicalmemory)大的程序</strong>。再者，它将内存抽象成一个庞大的、统一的存储数组，将用户理解的逻辑内存( logical memory)与真正的物理内存区分开来。这种安排使得程序员不受内存空间的限制。</p>
<h3 id="1-5-操作系统的执行"><a href="#1-5-操作系统的执行" class="headerlink" title="1.5 操作系统的执行"></a>1.5 操作系统的执行</h3><p>现代操作系统是<strong>中断驱动</strong>的。事件由中断或者陷阱引起。</p>
<p>陷阱/异常：软件生成的中断，或源于出错，或源于用户程序的特定请求。</p>
<p>由于系统和用户共享计算机系统地硬件和软件，一个程序的bug可能会对其他进程造成不利影响。</p>
<h4 id="1-5-1-双重模式和多重模式的执行。"><a href="#1-5-1-双重模式和多重模式的执行。" class="headerlink" title="1.5.1 双重模式和多重模式的执行。"></a>1.5.1 双重模式和多重模式的执行。</h4><p>区分操作系统代码和用户代码的执行。</p>
<p>至少需要两种单独运行模式:<strong>用户模式</strong>(user mode)和<strong>内核模式</strong>(kernel mode)(也称为<em>监视模式</em>（ supervisor mode)、<em>系统模式</em>( system mode)或<em>特权模式</em>( privileged mode))。计算机硬件可以通过一个<strong>模式位</strong>(mode bit)来表示当前模式:内核模式(0）和用户模式(1)。有了模式位，就可区分为操作系统执行的任务和为用户执行的任务。当计算机系统执行用户应用时，系统处于用户模式。然而，当用户应用通过系统调用，请求操作系统服务时，系统必须从用户模式切换到内核模式，以满足请求，如图1-10所示。正如将会看到的，这种架构改进也可用于系统操作的许多其他方面。</p>
<p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5.assets/image-20220704144625855.png" alt="image-20220704144625855"></p>
<p>当系统引导时，硬件从内核模式开始。操作系统接着加载，然后开始在用户模式下执行用户程序。一旦有陷阱或中断，硬件会从用户模式切换到内核模式(即将模式位的状态设为0 )。因此，**每当操作系统能够控制计算机时，它就处于内核模式。在将控制交给用户程序前，系统会切换到用户模式(将模式位设为1)**。</p>
<p>双重模式执行提供保护手段，以便防止操作系统和用户程序受到错误用户程序的影响。这种防护实现为:将可能引起损害的机器指令作为特权指令(privileged instruction)，并且硬件只有在内核模式下才允许执行特权指令。如果在用户模式下试图执行特权指令，那么硬件并不执行该指令，而是认为该指令非法，并将其以陷阱形式通知操作系统。</p>
<p>模式概念可以拓展。<strong>支持虚拟化技术的CPU有一种单独模式</strong>，用于表示<strong>虚拟机管理器</strong>(Virtual Machine Manager, VMM)是否正在控制系统。这种模式的特权要多于用户模式，但少于内核模式。这种特权模式可以改变CPU状态，以便创建和管理虚拟机。有时，不同的内核组件也会使用不同模式。需要注意的是，除了模式外，CPU设计人员也可采用其他方式来区分执行特权。例如，Intel 64系列的CPU有四种特权级别( privilege level)并支持虚拟化,但是没有一个特定的虚拟化模式。</p>
<p>现在看一看计算机系统的指令执行的生命周期。最初，操作系统进行控制，这时指令执行在内核模式。当控制转交到一个用户应用时，模式也设置为用户模式。最终，通过中断、陷阱或系统调用,控制又返回到操作系统。</p>
<p>系统调用为用户程序提供手段，以便请求操作系统完成某些特权任务。系统调用可有多种方式，取决于底层处理器提供的功能。不管哪种，它都是进程请求操作系统执行功能的方法。系统调用通常会陷入中断向量的某个指定位置。这一般可由通用trap指令来完成，不过也有的系统(如MIPS系列)由专用syscall指令来完成系统调用。</p>
<p>当要执行系统调用时，硬件通常将它作为软件中断。控制通过中断向量转到操作系统的中断服务程序，并且模式位也设为内核模式。系统调用服务程序是操作系统的一部分。内核检查中断指令，判断发生了什么系统调用;参数表示用户程序请求何种服务。请求所需的其他信息可以通过寄存器、堆栈或内存(内存指针也可通过寄存器传递)来传递。内核首先验证参数是否正确和合法，然后执行请求，最后控制返回到系统调用之后的指令。2.3节将更加详细地描述系统调用。</p>
<p>如果双重模式没有硬件支持，则操作系统会有严重缺点。例如，MS-DOS是为Intel8088体系结构而编写的，它没有模式位，因而没有双重模式。运行出错的程序可以通过写入数据而清除整个操作系统，多个程序可以同时写入同一设备，进而可能引起灾难结果。现今的Intel CPU确实提供双重模式执行。因此，大多数的当代操作系统，如Microsoft Windows 7、UNIX和 Linux，都利用了双重模式的优点，并为操作系统提供了更强保护。</p>
<p>一旦硬件保护到位，就可检测模式错误。这些错误通常由操作系统处理。如果一个用户程序出错，如试图执行非法指令或者访问不属于自己的地址空间内存，则通过硬件陷到操作系统。陷阱如同中断一样，通过中断向量可将控制转到操作系统。当一个程序出错时，可由操作系统来异常终止。这种情况的处理代码与用户请求的异常终止一样。操作系统会给出一个适当的出错信息，并倒出(dump)程序内存。倒出内存信息通常写到文件，这样用户或程序员可检查它,纠正错误并重新启动程序。</p>
<h4 id="1-5-2-定时器"><a href="#1-5-2-定时器" class="headerlink" title="1.5.2 定时器"></a>1.5.2 定时器</h4><p>定时器：操作系统应该维持控制CPU，防止用户程序陷入死循环，或不调用系统服务并且不将控制返给操作系统。</p>
<p>定时器可设置为在指定周期后中断计算机。指定周期可以是固定的/</p>
<p>**可变定时器:**一般通过一个固定速率的时钟和计数器来实现。</p>
<p>操作系统设置计数器。每次时钟滴答时，计数器都要递减。</p>
<p>在将控制交到用户之前，操作系统确保定时器已设置好以便产生中断。当定时器中断时，控制自动转到操作系统，而操作系统可以将中断作为致命错误来处理，也可以给予用户程序更多时间。当然，用于修改定时器的指令是特权的。</p>
<p>定时器可以防止用户程序运行过长。一种简单方法是，采用程序允许执行的时间来初始化计数器。例如，能运行7分钟的程序可以将计数器设置为420。定时器每秒产生一次中断，计数器相应递减1。只要计数器的值为正，控制就返回到用户程序。当计数器的值为负时，操作系统就会中止程序执行，因为它超过了设置的时间限制。</p>
<h3 id="1-6-进程管理"><a href="#1-6-进程管理" class="headerlink" title="1.6 进程管理"></a>1.6 进程管理</h3><p>进程：执行的程序。</p>
<p>进程为了完成任务，需要一定的资源，包括CPU时间、内存、文件、IO设备等。这些资源可以在进程创建时赋予，也可以在执行进程时分配。除了创建时得到的各种物理和逻辑资源外，进程还可以接受传输过来的各种初始化数据(输人)。例如，考虑这样一个进程,它要在终端或者屏幕上显示文件状态，而且需要有一个文件名作为输入。文件名的获得和信息的终端显示，可以通过适当指令和系统调用来进行。当进程中止时，操作系统就会收回所有可再利用的资源。</p>
<p>需要强调的是，**程序本身不是进程，程序是个被动实体( passive entity)，如同存储在磁盘上的文件内容，而进程是个主动实体（ active entity)**。单线程进程有一个程序计数器( program counter)，指定了下一个所要执行的指令(第4章讨论线程)。这样一个进程的执行应是顺序的。CPU一个接着一个地执行进程的指令，直至进程完成。再者，在任何时候,<strong>每个进程最多只能执行一条指令</strong>。因此，尽管两个进程可能与同一个程序相关联，然而这两个进程都有各自的执行顺序。多线程进程有多个程序计数器，每一个指向下一个给定线程需要执行的指令。</p>
<p><strong>进程是系统的工作单元。系统由多个进程组成，其中有的是操作系统进程（执行系统代码)，其他的是用户进程(执行用户代码)。所有这些进程都会并发执行，例如通过在单CPU上采用多路复用来实现。</strong></p>
<p>操作系统负责进程管理的以下活动:</p>
<ul>
<li>在CPU 上调度进程和线程</li>
<li>创建和删除用户进程和系统进程</li>
<li>挂起和重启进程</li>
<li>提供进程同步机制</li>
<li>提供进程通信机制</li>
</ul>
<h3 id="1-7-内存管理"><a href="#1-7-内存管理" class="headerlink" title="1.7 内存管理"></a>1.7 内存管理</h3><p>正如1.2.2节所述，内存是现代计算机系统执行的中心。内存是一个大的字节数组，大小从数十万到数十亿。<strong>每个字节都有地址。内存是个快速访问的数据仓库，并为CPU和IO设备所共享</strong>。<strong>中央处理器在获取指令周期时从内存中读取指令，而在获取数据周期时对内存数据进行读写(在冯·诺依曼架构上)。内存一般是CPU所能直接寻址和访问的、唯一的、大容量的存储器。</strong>例如，如果 CPU需要处理磁盘数据，那么这些数据必须首先通过CPU产生的I/O调用传到内存。同样，如果 CPU需要执行指令，那么这些指令必须在内存中。</p>
<p><strong>如果一个程序需要执行，那么它必须映射到绝对地址，并且加载到内存。</strong>随着程序执行，<strong>进程可以通过产生绝对地址来访问内存的程序指令和数据。最后，程序终止，它的内存空间得以释放，这样下一个程序可以加载并得以执行。</strong></p>
<p>为改进CPU的利用率和用户的计算机响应速度，通用计算机应在内存中保留多个程序，这就需要内存管理。内存管理的方案有许多。这些方案会有各种具体方法，所有特定算法的效率取决于特定情景。在选择某个特定系统的内存管理方案时，必须考虑许多因素，尤其是系统的硬件设计。每个算法都要求特定的硬件支持。<br>操作系统负责内存管理的以下活动:</p>
<ul>
<li>记录内存的哪部分在被使用以及被谁使用。</li>
<li>决定哪些进程(或其部分）会调入或调出内存。</li>
<li>根据需要分配和释放内存空间。</li>
</ul>
<h3 id="1-8-存储管理"><a href="#1-8-存储管理" class="headerlink" title="1.8 存储管理"></a>1.8 存储管理</h3><p>文件：OS对存储设备的物理属性进行抽象，并定义逻辑存储单元。操作系统映射文件到物理媒介，并通过存储设备来访问文件。</p>
<h4 id="1-8-1-文件系统管理"><a href="#1-8-1-文件系统管理" class="headerlink" title="1.8.1 文件系统管理"></a>1.8.1 文件系统管理</h4><p>计算机可在多种类型的物理介质上存储信息，常用的有磁盘、光盘和磁带等。每个介质都由一个设备来控制，如磁盘驱动器或磁带驱动器。</p>
<p>文件是创建者定义的相关信息组合。文件内容为程序和数据。数据文件可以是数值、字符等。文件可以没有格式或者严格格式。</p>
<p>操作系统管理大容量存储介质，如磁盘和此带。</p>
<p>OS负责文件管理以下活动：</p>
<ul>
<li>创建、删除文件</li>
<li>创建、删除目录</li>
<li>提供文件和目录的操作原语</li>
<li>映射文件到外村</li>
<li>备份文件到稳定存储介质</li>
</ul>
<h4 id="1-8-2-大容量存储器管理"><a href="#1-8-2-大容量存储器管理" class="headerlink" title="1.8.2 大容量存储器管理"></a>1.8.2 大容量存储器管理</h4><p>因为内存较小、掉电会失去数据，所以计算机系统应该提供外存以备份内存。</p>
<p>主要的线存储介质：硬盘。</p>
<p>OS负责硬盘管理以下活动：</p>
<ul>
<li>空闲空间管理</li>
<li>存储空间分配</li>
<li>硬盘调度</li>
</ul>
<p>外存使用应该更高效一点。</p>
<p>三级存储：磁带驱动器及其磁带、CD/DVD驱动器及光盘。分为一次写多次读和读-写。</p>
<h4 id="1-8-3-高速缓存"><a href="#1-8-3-高速缓存" class="headerlink" title="1.8.3 高速缓存"></a>1.8.3 高速缓存</h4><p>高速缓存也简称为缓存。</p>
<p>工作原理：信息通常保存在一个存储系统中(如内存)，使用时，它会被临时复制到更快存储系统，即高速缓存;当需要特定信息时，首先检查它是否处于高速缓存，如果是，可以直接使用高速缓存的信息，如果否，就使用位于源地的信息，同时将其复制到高速缓存以便下次再用。</p>
<p>可编程内部寄存器为内存提供高速缓存。程序员通过寄存器分配与寄存器替换的算法，决定哪些信息应在寄存器中而哪些应存在内存中。</p>
<p>高速缓存完全通过硬件实现。大多数系统都有一个指令的高速缓存。</p>
<p>所以高速缓存管理的设计很重要。</p>
<p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5.assets/image-20220706110529839.png" alt="image-20220706110529839"></p>
<p>内存可以看作外存的高速缓存，这是因为外存数据应先复制到内存以便使用，而且数据应位于内存中才可保存到外存。永久驻留在外存上的文件系统的数据，会位于存储层次的多个层次上。在最高层上，操作系统可在内存中保存一个文件系统数据的高速缓存。另外，<strong>固态盘也可作为高速存储</strong>，并可通过文件系统接口来访问。大容量的外存为磁盘。磁盘存储又通常可以用磁带或移动磁盘来备份数据，以防止因磁盘损坏造成的数据丢失。有的系统将位于磁盘上的旧文件数据自动备份到三级存储，如磁带塔，以便降低存储费用(参见第12章)。</p>
<p>存储层次间的信息移动可以是显式的，也可以是隐式的，这取决于硬件设计和操作系统的控制软件。例如，高速缓存到CPU或寄存器的数据传递，通常通过硬件完成，无需操作系统干预。相反，磁盘到内存的数据传递通常通过操作系统控制。</p>
<p>在层次存储结构中，同一数据可能出现在存储系统的不同层次上。例如，位于文件B的整数A需要加1，而文件B位于磁盘。加1操作这样进行:先进行IO操作以将A所在的块调入内存。之后，A被复制到高速缓存和内部寄存器。这样，A的副本出现在多个地方:磁盘上、内存中、高速缓存中、内部寄存器中(见图1-12)。一旦在内部寄存器中执行加法后，A的值在不同存储系统中就会不同。只有在A的新值从内部寄存器写到磁盘时，A的值才会一样。</p>
<p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5.assets/image-20220706110749884.png" alt="image-20220706110749884"></p>
<p>高速缓存一致性：带有本地的高速缓存。</p>
<h4 id="1-8-1-I-O系统"><a href="#1-8-1-I-O系统" class="headerlink" title="1.8.1 I/O系统"></a>1.8.1 I/O系统</h4><p>操作系统的目的之一是为用户隐藏具体硬件设备的特性。例如，在UNIX系统中，IO子系统（IO subsystem)为操作系统本身隐藏了IO设备的特性。I/O子系统包括以下几个组件:</p>
<ul>
<li><p>包括缓冲、高速缓存和假脱机的内存管理组件。</p>
</li>
<li><p>设备驱动器的通用接口。</p>
</li>
<li><p>特定硬件设备的驱动程序。</p>
<p>只有设备驱动程序才能知道控制设备的特性。</p>
</li>
</ul>
<h3 id="1-9-保护与安全"><a href="#1-9-保护与安全" class="headerlink" title="1.9 保护与安全"></a>1.9 保护与安全</h3><p>内存寻址硬件确保一个进程仅可在自己的地址空间内执行。</p>
<p><strong>保护</strong>是一种机制，用于控制进程或用户访问计算机系统的资源。保护安全要求系统能够区分所有用户。</p>
<p>UID：用户标识。</p>
<h3 id="1-10-内核数据结构"><a href="#1-10-内核数据结构" class="headerlink" title="1.10 内核数据结构"></a>1.10 内核数据结构</h3><h4 id="1-10-1-列表、堆栈及队列"><a href="#1-10-1-列表、堆栈及队列" class="headerlink" title="1.10.1 列表、堆栈及队列"></a>1.10.1 列表、堆栈及队列</h4><p>内存就是一个数组。</p>
<p>列表：项需要按照特定次序访问，列表是一组数据表示成序列，实现结构常用方法：链表。</p>
<ul>
<li><p>单向链表：每项指向它的后继。</p>
<p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5.assets/image-20220706112832740.png" alt="image-20220706112832740"></p>
</li>
<li><p>双向链表：每项指向它的前驱与后继</p>
<p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5.assets/image-20220706113806971.png" alt="image-20220706113806971"></p>
</li>
<li><p>循环链表：最后一项指向第一项</p>
<p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5.assets/image-20220706113845855.png" alt="image-20220706113845855"></p>
</li>
</ul>
<p>链表：允许不同大小项；插入删除方便</p>
<p>缺点：遍历麻烦</p>
<p>堆栈：有序，后进先出原则。压入和弹出。</p>
<p>队列：先进先出</p>
<h4 id="1-10-2-树"><a href="#1-10-2-树" class="headerlink" title="1.10.2 树"></a>1.10.2 树</h4><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5.assets/image-20220706114042951.png" alt="image-20220706114042951"></p>
<p>树( tree）是一种数据结构，可以表示数据层次。树结构的数据值可按父-子关系连接起来。对于一般树(general tree),父结点可有多个子结点。对于二叉树(binary tree)，父结点最多可有两个子结点,即左子结点（left child)和右子结点（rightchild)。二叉查找树(binary search tree)还要求对两个子结点进行排序,如左子结点≤右子结点。图 1-16为一个二叉查找树的例子。当需要对一个二叉查找树进行查找时，最坏性能为O(n)(请想一想这是为什么)。为了纠正这种情况，我们可以通过算法来创建平衡二叉查找树(balanced binary search tree)。这样，包含n个项的树最多只有lg n层，这可确保最坏性能为O(lg n)。在5.7.1节中，我们将会看到，Linux在CPU 调度算法中就使用了平衡二叉查找树。</p>
<h4 id="1-10-3-哈希函数与哈希表"><a href="#1-10-3-哈希函数与哈希表" class="headerlink" title="1.10.3 哈希函数与哈希表"></a>1.10.3 哈希函数与哈希表</h4><p>哈希函数( hash function)将一个数据作为输入，对此进行数值运算，然后返回一个数值。该值可用作一个表(通常为数据组）的索引，以快速获得数据。虽然在最坏情况下从大小为n的列表中查找数据项所需的比较会是O(n)，但是采用哈希函数来从表中获得数据可能只有O(1)，这与具体实现有关。由于性能关系，哈希函数在操作系统中用得很广。</p>
<p>哈希函数有一潜在问题:两个输入可能产生同样的输出值，即它们会链接到列表的同一位置。哈希碰撞( hash collision)可以这样处理:在列表位置上可以存放一个链表，以便将具有相同哈希值的所有项链接起来。当然，碰撞越多，哈希函数的效率越低。</p>
<p>**哈希函数的另一用途是实现哈希表( hash map)，即利用哈希函数将键( key)和值( value)关联起来。例如，可将键operating映射到值system。有了这个映射，就可将哈希函数应用于键，进而从哈希表中获得对应值(图1-17)**。例如，现有用户名称映射到用户密码。用户认证可以这样进行:用户输入他的用户名称和密码;将哈希函数应用于用户名称，以获取密码;获取密码再与用户输入的密码进行比较,以便认证。</p>
<p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5.assets/image-20220706114414469.png" alt="image-20220706114414469"></p>
<h4 id="1-10-4-位图"><a href="#1-10-4-位图" class="headerlink" title="1.10.4 位图"></a>1.10.4 位图</h4><p>位图( bitmap）为n个二进制位的串，用于表示n项的状态。例如，假设有若干资源,每个资源的可用性可用二进制数字来表示：0表示资源可用，而1表示资源不可用(或相反)。位图的第i个位置的值与第i个资源相关联。例如，现有如下位图:<br>$001011101$<br>第2、4、5、6和8个资源是不可用的，第0、1、3和7个资源是可用的。</p>
<p>当考虑空间效率时，位图优势明显。如果所用的布尔值是8位的而不是1位的，那么最终的数据结构将会是原来的8倍。因此，当需要表示大量资源的可用性时，通常采用位图。磁盘驱动器就是这么工作的。一个中等大小的磁盘可以分成数千个单元，称为<strong>磁盘块</strong>( diskblock)。每个磁盘块的可用性就可通过位图来表示。</p>
<p>数据结构广泛用于实现操作系统。因此，除了这里讨论的一些数据结构，在分析内核算法与实现时，也会讨论其他的数据结构。</p>
<blockquote>
<p>Linux内核数据结构</p>
<p>Linux内核所用的数据结构有源码。头文件&lt;linux/list.h&gt;包括内核所用的链表数据结构的实现细节。<strong>Linux的队列称为kfifo</strong>，<strong>源代码的目录kernel的文件kfifo.c包含它的实现</strong>。<strong>Linux通过红黑树提供了平衡二分查找树的实现，头文件&lt;linux/rbtree.h&gt;包括它的细节</strong>。</p>
</blockquote>
<h3 id="1-11-计算环境"><a href="#1-11-计算环境" class="headerlink" title="1.11 计算环境"></a>1.11 计算环境</h3><h4 id="1-11-1-传统计算"><a href="#1-11-1-传统计算" class="headerlink" title="1.11.1 传统计算"></a>1.11.1 传统计算</h4><p>桌面计算机等。服务器、笔记本电脑、远程访问。</p>
<h4 id="1-11-2-移动计算"><a href="#1-11-2-移动计算" class="headerlink" title="1.11.2 移动计算"></a>1.11.2 移动计算</h4><p>便携与轻巧。</p>
<h4 id="1-11-3-分布计算"><a href="#1-11-3-分布计算" class="headerlink" title="1.11.3 分布计算"></a>1.11.3 分布计算</h4><p><strong>分布式系统是物理上分开的、可能异构的、通过网络相联的一组计算机系统，可供用户访问系统维护的各个资源</strong>。共享资源的访问可提高计算速度、功能、数据可用性及可靠性。有的操作系统将网络访问简化为文件访问，而网络细节则包含在网络接口驱动程序中;而其他的操作系统则让用户自己调用网络功能。通常，系统对这两种模式都会支持，<strong>如FTP和NFS</strong>。构建分布式系统的协议可以极大影响系统的实用和普及。</p>
<p>简单地说，<strong>网络(network)就是两个或多个系统之间的通信路径</strong>。分布式系统通过网络提供功能。<strong>由于通信协议、节点距离、传输媒介的不同，网络也会不同</strong>。<strong>传输控制协议/网间协议（Transport Control Protocol/Internet Protocol，TCP/IP)是最为常用的网络协议，为因特网提供了基础架构。大多数的操作系统都支持TCP/IP，包括所有通用协议</strong>。有的系统支持专用协议，以满足特定需求。对于操作系统而言，一个网络协议只是需要一个接口设备（如网络适配器)，通过驱动程序以便管理它以及处理数据的软件。这些概念后面会加以讨论。</p>
<p>网络可以根据节点之间的距离来划分。<strong>局域网</strong>(Local-Area Network，LAN)位于一个房间、一栋大楼或一所校园。<strong>广域网</strong>（ Wide-Area Network，WAN)通常用于联接楼宇、城市或国家。例如，一个全球性的公司可以用WAN将其全球内的办公室联接起来。这些网络可以采用单个或多个协议。不断出现的新技术也带来新的网络类型。例如，<strong>城域网</strong>( Metropolitan-Area Network，MAN)可以将一个城市内的楼宇连接起来。蓝牙和802.11设备采用无线技术，实现在数米内的无线通信，进而创建了个人局域网（ Personal-AreaNetwork ，PAN)，以连接电话和耳机或连接智能手机和桌面计算机。</p>
<p>网络的连接媒介同样很多，它们包括铜线、光纤、卫星之间的无线传输、微波和无线电波。当计算设备连接到手机时，就创建了一个网络。即使非常近距离的红外通信也可用来构建网络。总之，无论计算机何时通信，它们都要使用或构建一个网络。这些网络的性能和可靠性各不相同。</p>
<p>有的操作系统不但提供网络连接，而且进一步拓广了网络和分布式系统的概念。网络操作系统(network operating system)就是这样一种操作系统，它提供跨网络的文件共享、不同计算机进程的消息交换等功能。虽然运行网络操作系统的计算机知道有网络且能与其他联网的计算机进行通信，但是相对于网络上的其他计算机而言却是自治的。分布式操作系统提供较少的自治环境。不同的计算机紧密通信，以致于好像只有一个操作系统控制整个网络。</p>
<h4 id="1-11-4-客户机-服务器计算"><a href="#1-11-4-客户机-服务器计算" class="headerlink" title="1.11.4 客户机-服务器计算"></a>1.11.4 客户机-服务器计算</h4><p>许多现代操作系统可作为服务器系统，以满足客户机系统的请求。这种形式的专用分布式系统称为客户机-服务器系统。</p>
<p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5.assets/image-20220706144126438.png" alt="image-20220706144126438"></p>
<p>服务器系统可大致分为计算服务器和文件服务器:</p>
<ul>
<li><strong>计算服务器系统（ compute-server system)提供接口</strong>，以便客户发送请求以执行操作(如读数据)。相应地，服务器执行操作，并发送结果到客户机。例如，如果一个服务器运行数据库,那么就可响应客户机的数据请求。</li>
<li><strong>文件服务器系统( file-server system)提供文件系统接口</strong>，以便客户机可以创建、更新、访问和删除文件。例如，一个Web服务器可以发送文件到运行Web浏览器的客户机。</li>
</ul>
<h4 id="1-11-5-对等计算"><a href="#1-11-5-对等计算" class="headerlink" title="1.11.5 对等计算"></a>1.11.5 对等计算</h4><p>分布式系统另一结构是<strong>对等系统模型</strong>(Peer to Peer, P2P)，这个模型并不区分客户机与服务器。所有系统节点对等，每个节点都可作为客户机或服务器。</p>
<p>一个节点在加入对等系统时，就应首先加入对等网络。节点一旦加入对等网络，可以为其他节点提供服务。</p>
<p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5.assets/image-20220706151230411.png" alt="image-20220706151230411"></p>
<ul>
<li>通过网络集中查询服务来注册服务。</li>
<li>提供发现协议，以允许节点发现其他节点服务。</li>
</ul>
<p>提供文件共享服务的对等网络在20世纪90年代后期很受欢迎，如 Napster 和 Gnutella，可让对等节点互相交换文件。Napster系统采用类似上述的第一种方法:一个集中服务器维护存储在Napster网络上对等节点的所有文件的索引，而对等节点之间进行文件交换。Gnutella系统采用类似上述的第二种方法:一个客户机向系统的其他节点广播文件请求，能够服务请求的节点直接响应请求。文件交换的未来发展并不明朗，因为对等网络可以用于传播有产权保护的资料（如音乐)，而这些授权资料的传播是有法律限制的。值得一提的是，Napster 已陷入侵权案件，其服务也在2001年关停。</p>
<p>另一个对等计算的例子是Skype。它采用了<strong>IP语音</strong>( Voice Over IP，VoP)技术，客户可以在 Internet上进行语音通话、视频通话、发送文本消息等。Skype采用了混合方式：它有集中登录服务器，也支持分散节点之间的通信。</p>
<h4 id="1-11-6-虚拟化"><a href="#1-11-6-虚拟化" class="headerlink" title="1.11.6 虚拟化"></a>1.11.6 虚拟化</h4><p>虚拟化是一种软件技术，用于实现模拟。当原有CPU与现有CPU类型不同时，就可采用模拟：允许某一平台的操作系统可以运行在另一平台上。</p>
<p>解释：一种计算语言转换成中间形式或按高级形式来执行。</p>
<p>虚拟化：为某一CPU而编译的操作系统可以运行在为另一相同CPU而编译的操作系统上。</p>
<p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5.assets/image-20220706152229327.png" alt="image-20220706152229327"></p>
<h4 id="1-11-7-云计算"><a href="#1-11-7-云计算" class="headerlink" title="1.11.7 云计算"></a>1.11.7 云计算</h4><p>云计算可以通过网络提供计算、存储甚至应用程序等服务。它是虚拟化技术的延伸。例如，亚马逊有数百万的虚拟机。</p>
<p>云计算实际上有许多类型,包括如下:</p>
<ul>
<li>公云(public cloud)。只要愿意为服务付费就可以使用的云。</li>
<li>私云（private cloud)。公司自己使用自己的云。</li>
<li>混合云( hybrid cloud)。有公云部分也有私云部分的云。</li>
<li>软件即服务(Software as a Service，SaaS)。可通过Internet使用的应用程序(如文字处理程序或电子表格程序)。</li>
<li>平台即服务( Platform as a Service，PaaS)。可通过Internet而为应用程序(如数据库服务器）使用的软件堆栈。</li>
<li>基础设施即服务( Infrastructure as a Service，laaS)。可通过Internet使用的服务器或存储(如用于生产数据备份的存储)。</li>
</ul>
<p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5.assets/image-20220706152407106.png" alt="image-20220706152407106"></p>
<h4 id="1-11-8-实时嵌入式系统"><a href="#1-11-8-实时嵌入式系统" class="headerlink" title="1.11.8 实时嵌入式系统"></a>1.11.8 实时嵌入式系统</h4><p>嵌入式计算机是目前最为普遍的计算机。从汽车引擎和制造机器人，到录像机和微波炉，到处可以找到它们的身影。它们往往具有特定任务，运行系统通常很简单，因此操作系统提供了有限的功能。通常，<strong>它们很少有甚至没有用户界面，主要关注监视和管理硬件设备，如汽车引擎和机器手</strong>。</p>
<p>这些嵌入式系统差别相当大。有的是通用计算机，具有标准的操作系统如Linux，并运行专用应用程序来实现功能。还有的硬件设备具有专用的嵌入式操作系统，以提供所需功能。此外，还有其他的硬件设备，不采用操作系统，而采用<strong>专用集成电路</strong>（ ApplicationSpecific Integrated Circuit，ASIC)来执行任务。</p>
<p>嵌入式系统的使用继续扩大。无论是作为独立单元还是作为网络或Web 的组件，这些设备的性能也在增强。现在，整个房屋可以由计算机来控制，这样一台中心计算机，无论是通用计算机还是嵌入式计算机，可以控制取暖、照明、报警甚至咖啡机等。通过Web访问,房主可告诉房子在他回家之前加好温度。将来，冰箱也可能在发现牛奶没有时，通知食品杂货店送货。</p>
<p>嵌入式系统几乎总是采用实时操作系统( real-time operating system)。当处理器执行或数据流动具有严格时间要求时，就要使用实时系统，通常用作特定应用的控制设备。计算机从传感器获得数据，接着分析数据，然后通过控制调整传感器输入。科学试验的控制系统、医学成像系统、工业控制系统和有些显示系统等，都是实时系统。有些汽车喷油系统、家电控制器和武器系统等也是实时系统。</p>
<p>实时系统具有明确的、固定的时间约束。处理必须在固定时间约束内完成，否则系统就会出错。如果机器手在打坏所造汽车之后才停止，那么就不行了。只有在时间约束内返回正确结果，实时系统的运行才是正确的。与之不同的是，分时系统只是要(而不是一定）响应快，而批处理系统则没有任何时间约束。</p>
<p>第5章讨论操作系统如何实现实时功能的调度。第9章讨论实时计算的内存管理设计。最后，第16章和第17章讨论Linux和 Windows 7操作系统的实时组件。</p>
<h3 id="1-12-开源操作系统"><a href="#1-12-开源操作系统" class="headerlink" title="1.12 开源操作系统"></a>1.12 开源操作系统</h3>]]></content>
      <categories>
        <category>学习</category>
        <category>专业基础</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络笔记</title>
    <url>/undefined/%E5%AD%A6%E4%B9%A0/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="计算机网络笔记"><a href="#计算机网络笔记" class="headerlink" title="计算机网络笔记"></a>计算机网络笔记</h1><h1 id="第一章-计算机网络和因特网"><a href="#第一章-计算机网络和因特网" class="headerlink" title="第一章 计算机网络和因特网"></a>第一章 计算机网络和因特网</h1><blockquote>
<p>提纲：</p>
<ul>
<li>什么是Internet？</li>
<li>什么是协议？</li>
<li>网络边缘</li>
<li>接入网、物理媒体</li>
<li>Internet结构和ISP</li>
<li>分组延时、丢失和吞吐量</li>
<li>协议层次及服务模型</li>
<li>历史</li>
</ul>
</blockquote>
<span id="more"></span>
<h2 id="1-1-什么是因特网"><a href="#1-1-什么是因特网" class="headerlink" title="1.1 什么是因特网"></a>1.1 什么是因特网</h2><p>其一：描述因特网的基本硬件和软件组件</p>
<p>其二：根据为分布式应用提供服务的联网基础来描述因特网</p>
<p><strong>网络</strong>：节点、边关系</p>
<p>节点：主机及其上运行的应用程序；路由器、交换机等网络交换设备。</p>
<p>边/通信链路：接入网链路(主机连接到互联网的链路)；主干链路：路由器间的链路。</p>
<p><strong>计算机网络</strong>：</p>
<p><strong>互联网</strong>：</p>
<h3 id="1-1-1-具体描述"><a href="#1-1-1-具体描述" class="headerlink" title="1.1.1 具体描述"></a>1.1.1 具体描述</h3><p><strong>主机/端系统</strong>：如智能手机、平板电脑、手提电脑等等因特网物品。</p>
<img src="G:\科技数码\img\image-20220511151825032.png" alt="image-20220511151825032" style="zoom:50%;" />

<p>端系统通过<strong>通信链路</strong>和<strong>分组交换机</strong>连接到一起。</p>
<p>链路的传输速率以比特/秒度量。</p>
<p><strong>分组</strong>：发送端系统将数据分段，并为每段加上首部字节。由此形成的信息包。</p>
<p><strong>分组交换机</strong>通过通信链路接收到达分组链路。</p>
<p>交换机：路由器(网络核心)、链路层交换机(接入网)等。</p>
<p><strong>路径</strong>：一个分组所经历的一系列通信链路和分组交换机称为通过该网络的路径。</p>
<p><strong>因特网服务提供商</strong>：ISP，端系统通过这个接入因特网。每个ISP自身就是一个由多台分组交换机和多段通信链路组成的网络。ISP为端系统提供了各种不同类型的网络接入。较底层的ISP通过国家的、国际的较高层ISP互联起来。运行着IP协议，遵从一定的命名和地址规则。每个ISP自身就是一个有多台分组交换机和多段通信链路组成的网路。</p>
<p><strong>因特网</strong>：将端系统彼此互联，为端系统提供接入的ISP也必须互联。</p>
<p><strong>协议</strong>：控制因特网中信息的接收和发送。TCP(Transmission Control Protocol，传输控制协议)和UDP(Internet Protocol，网际协议)是因特网中最为重要的两个协议。IP协议定义了在路由器和端系统之间发送和接收的分组格式。因特网主要协议统称为TCP/IP。</p>
<p><strong>因特网标准</strong>由因特网工程任务组(IETF)研发，IETF的标准文档叫请求评论(RFC)</p>
<h3 id="1-1-2-服务描述"><a href="#1-1-2-服务描述" class="headerlink" title="1.1.2 服务描述"></a>1.1.2 服务描述</h3><blockquote>
<p>为应用程序提供服务的基础设施。</p>
</blockquote>
<p><strong>分布式应用程序</strong>：这些应用程序涉及多个相互交换数据的端系统。</p>
<p>因特网应用程序不运行在网络核心的分组交换机中。</p>
<p><strong>套接字接口</strong>：规定了运行在一个端系统上的程序请求因特网基础设施向运行在另一个端系统上的特定目的地程序交付数据的方式。因特网套接字接口是一套发送程序必须遵循的规则集合，因此因特网能够将数据交付给目的地。</p>
<h3 id="1-1-3-什么是协议"><a href="#1-1-3-什么是协议" class="headerlink" title="1.1.3 什么是协议"></a>1.1.3 什么是协议</h3><p><strong>1.人类活动的类比</strong></p>
<img src="G:\科技数码\img\image-20220515115821402.png" alt="image-20220515115821402" style="zoom:50%;" />

<p><strong>2.网络协议</strong></p>
<p>协议：<strong>定义了在两个或多个通信实体之间交换的报文的格式和顺序，以及报文发送和/或接收一条报文或其他事件所采取的动作。</strong></p>
<p>因特网广泛使用协议。</p>
<h2 id="1-2-网络边缘"><a href="#1-2-网络边缘" class="headerlink" title="1.2 网络边缘"></a>1.2 网络边缘</h2><p>端系统：与因特网相连的计算机或者其他设备，位于因特网边缘。</p>
<p>端系统也称主机，可以容纳应用程序。</p>
<p>主机分为客户机和服务器，</p>
<p>客户通常是桌面PC、移动PC和智能机，服务器则是用于存储和发布Web页面、流视频和中继电子邮件等。</p>
<p><strong>数据中心</strong>：服务器的集合。</p>
<h3 id="1-2-1-接入网"><a href="#1-2-1-接入网" class="headerlink" title="1.2.1 接入网"></a>1.2.1 接入网</h3><p><strong>接入网：</strong>将端系统物理连接到其边缘路由器的网络。边缘路由器是端系统到任何其他远程端系统路径上的第一台路由器。</p>
<p><strong>边缘路由器：</strong>是端系统到任何其他远程端系统的路径上的第一台路由器。</p>
<ol>
<li>家庭接入：DSL、电缆、FTTH、拨号和卫星</li>
</ol>
<p>宽带住宅最流行的两种类型：数字用户线(DSL)和电缆。当使用DSL时，用户的本地电话公司也是它的ISP。每个用户的DSL调制解调器使用现有的电话线与位于电话公司的本地中心局(CO)中的数字用户线接入复用器(DSLAM)交换数据。家庭的DSL调制解调器时得到数字数据后将其转换为高频音，以通过电话线传输给本地中心局。来自许多家庭的模拟信号在DSLAM处被转换回数字形式。</p>
<p>家庭电话线使用不同的频率编码。</p>
<p>分配器把家庭的数据和电话信号分开，并将数据信号转发给DSL调制解调器。在电话公司的一侧，在本地中心局，DSLAM把数据和电话信号分隔开，并将数据送往因特网。数百甚至上千个家庭与同一个DSLAM相连。</p>
<p>DSL利用电话公司现有的有线电视基础设施；电缆因特网接入利用了有线电视公司现有的有线电视基础设施。需要特殊的电缆调制解调器。</p>
<p>住宅提供有线电视的公司获得了电缆因特网接入。H，</p>
<p><strong>光纤到户</strong>：FTTH。主动光纤和被动光纤。AON本质是交换因特网。</p>
<p>PON技术用于Verzion的FIOS服务中。</p>
<p>每个家庭具有一个光纤网络端接器ONT，由专门的光纤连接到邻近的分配器。该分配器把一些家庭集结到一根共享光纤中，该光纤再连接到本地电话和公司的中心局中的光纤线路端接器OLT。</p>
<p>FTTH有潜力提供每秒千兆比特范围的因特网接入速率。然而，大多数FTTH ISP提供多种不同速率选择，较高的速率自然花费更多。</p>
<ol start="2">
<li>企业和家庭接入：以太网和WiFi</li>
</ol>
<p>在公司和大学校园：局域网(LAN)将端系统连接到边缘路由器。</p>
<p>家庭将电缆调制解调器和廉价的无线局域网技术结合起来。</p>
<p>家庭网络组成如下：一台漫游的便携机和一台有线的PC；一个与无线PC和家中其他无线设备通信的基站；一个提供与因特网带宽接入的电缆调制解调器；一个互联了基站及带有电缆调制解调器的固定PC的路由器。</p>
<ol start="3">
<li>广域无线接入：3G和LTE</li>
</ol>
<p>移动设备应用了无线基础设施，通过蜂窝网提供商运营的基站来发送和接收分组。</p>
<h3 id="1-2-2-物理媒体"><a href="#1-2-2-物理媒体" class="headerlink" title="1.2.2 物理媒体"></a>1.2.2 物理媒体</h3><p>因特网中使用的传输媒体：HFC使用光缆和同轴电缆；DSL和以太网使用双绞铜线；移动接入网使用无线电频谱。</p>
<p><strong>物理媒体</strong>：导引型媒体和非导引型媒体。</p>
<p>导引型：电波沿着固体媒体前行(双绞铜线、光缆或同轴电缆)</p>
<p>非导引型：电波在空气或外层空间传播(无线局域网或数字卫星频道)</p>
<p><strong>1.双绞铜线</strong>：便宜，应用于电话网。两根绝缘的铜线组成，许多双绞线捆扎在一起形成一根电缆。无屏蔽双绞线常用在建筑物内中，即LAN中。所能达到的传输速率却决于线的粗细以及传输方和接收方的距离。</p>
<p><strong>2.同轴电缆</strong>：两个铜导体组成。同轴电缆能被用作导引型共享媒体。</p>
<p><strong>3.光纤</strong>：柔软、引导光脉冲的媒体。每个脉冲表示一个比特。成为长途导引型媒体，特别用于海底链路。</p>
<p><strong>4.陆地无线电信道</strong>：依赖传播环境和信号传输的距离。环境上考虑取决于路径损耗和遮挡衰落、多径衰落以及干扰。</p>
<p><strong>5.卫星无线电信道</strong>：地面站的含义:通信卫星连接地球上的微波发射/接收器。该卫星在一个频段上接收传输，使用下一个转发器再生信号。两类卫星：同步卫星和近地轨道。</p>
<h2 id="1-3-网络核心"><a href="#1-3-网络核心" class="headerlink" title="1.3 网络核心"></a>1.3 网络核心</h2><p>网络核心：互联因特网端系统的分组交换机和链路构成的网状网络。</p>
<h4 id="1-3-1-分组交换"><a href="#1-3-1-分组交换" class="headerlink" title="1.3.1 分组交换"></a>1.3.1 分组交换</h4><p><strong>报文</strong>：端系统彼此交换的东西关系。报文可以执行控制功能，也可以包含数据。</p>
<p><strong>分组</strong>：从源端系统向目的地端系统发送一个报文，源将长报文划分为较小的数据块。</p>
<p>在源和目的地之间，每个分组都通过通信链路和分组交换机传送。</p>
<p><strong>分组交换机</strong>：路由器和链路层交换机。</p>
<h5 id="1-存储转发传输"><a href="#1-存储转发传输" class="headerlink" title="1.存储转发传输"></a>1.存储转发传输</h5><p>指在交换机能够开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组。</p>
<p>通过由N条速率均为R的链路组成的路径，端到端时延是$d_{端到端}=NL/R$。</p>
<h5 id="2-排队时延和分组丢失"><a href="#2-排队时延和分组丢失" class="headerlink" title="2.排队时延和分组丢失"></a>2.排队时延和分组丢失</h5><p><strong>输出缓存</strong>：对于每条相连的链路，该分组交换机具有一个输出缓存。</p>
<p><strong>排队时延</strong>：分组要在排队的链路中等待。</p>
<p><strong>丢包</strong>：缓存已被其他等待传输的分组完全充满了。</p>
<h5 id="3-转发表和路由选择协议"><a href="#3-转发表和路由选择协议" class="headerlink" title="3.转发表和路由选择协议"></a>3.转发表和路由选择协议</h5><p>路由器从与它相连的一条通信链路得到分组，在因特网中，每个端系统具有一个称之为IP地址的地址。分组首部包含了IP地址。每台路由器具有一个<strong>转发表</strong>，用于将目的地址映射成为输出链路。因特网具有特殊的路由选择协议。</p>
<h4 id="1-3-2-电路交换"><a href="#1-3-2-电路交换" class="headerlink" title="1.3.2 电路交换"></a>1.3.2 电路交换</h4><p>通过网络链路和交换机移动数据有两种方法：电路交换和分组交换。</p>
<p>电路交换预留了端系统沿路径通信所需要的资源(缓存、链路传输速率)，分组交换不预留。</p>
<p>端到端连接：两台主机之间。</p>
<h5 id="1-电路交换中的复用"><a href="#1-电路交换中的复用" class="headerlink" title="1. 电路交换中的复用"></a>1. 电路交换中的复用</h5><p>链路中电路通过<strong>频分复用</strong>FDM或<strong>时分复用</strong>TDM 实现。</p>
<p><strong>带宽</strong>：频段的宽度。</p>
<p>对于FDM，链路的频谱由跨越链路创建的所有连接共享。</p>
<p>对于TDM，时间被划分为固定期间的帧，每个帧又被划分为固定数量的时隙。</p>
<h5 id="2-分组交换与电路交换对比"><a href="#2-分组交换与电路交换对比" class="headerlink" title="2.分组交换与电路交换对比"></a>2.分组交换与电路交换对比</h5><p>分组交换更有效。</p>
<h4 id="1-3-3-网络的网络"><a href="#1-3-3-网络的网络" class="headerlink" title="1.3.3 网络的网络"></a>1.3.3 网络的网络</h4><p>端系统经过一个接入ISP与因特网相连。</p>
<p>单一的全球传输的ISP互联接入所有ISP。我们假想的全球传输ISP是一个由路由器和通信链路构成的网络。</p>
<p>在任何区域，可能有一个区域ISP，区域中的接入ISP与之连接。每个区域ISP则与第一层ISP连接。</p>
<p>一个区域可能有多个竞争的区域ISP。ISP逐级交付费用。</p>
<p><strong>存在点 PoP</strong>：提供商网络中的一台或多台路由器群组</p>
<p><strong>多宿</strong>：可以与两个或更多提供商ISP连接</p>
<p><strong>对等</strong>：直接将他们网络连接在一起。</p>
<p><strong>因特网交换点IXP：</strong>IXP是一个汇合点，多个ISP能够在这里一起对等。</p>
<h2 id="1-4-分组交换中的时延、丢包和吞吐量"><a href="#1-4-分组交换中的时延、丢包和吞吐量" class="headerlink" title="1.4 分组交换中的时延、丢包和吞吐量"></a>1.4 分组交换中的时延、丢包和吞吐量</h2><h5 id="1-4-1-分组交换网中的时延概述"><a href="#1-4-1-分组交换网中的时延概述" class="headerlink" title="1.4.1 分组交换网中的时延概述"></a>1.4.1 分组交换网中的时延概述</h5><p>分组会在沿途的每个节点经受几种不同的时延：节点处理时延、排队时延、传输时延和传播时延。</p>
<p><strong>处理时延</strong>：检查分组首部和决定将该分组导向何处所需要的时间。</p>
<p><strong>排队时延</strong>：分组在链路上等待传输。</p>
<p><strong>传输时延</strong>：将所有分组的比特推向链路。路由器推出分组的时间。</p>
<p><strong>传播时延</strong>：链路起点到路由器B传播所需的时间是传播时延。d/s。</p>
<p>$d_{proc}$为处理时延；$d_{queue}$为排队时延；$d_{trans}$为传输时延；$d_{prop}$为传播时延；节点总时延：$d_{nodal}=d_{proc}+d_{queue}+d_{trans}+d_{prop}$。</p>
<h5 id="1-4-2-排队时延和丢包"><a href="#1-4-2-排队时延和丢包" class="headerlink" title="1.4.2 排队时延和丢包"></a>1.4.2 排队时延和丢包</h5><p><strong>排队时延</strong>对不同的分组可能是不同的。</p>
<p>排队时延速度：取决于流量到达该队列的速率，链路的传输速率和到达流量的性质，即流量是周期性到达还是以突发形式到达。</p>
<p>流量强度：比率La/R。La/R&lt;=1。</p>
<p>随着流量强度接近于1，平均排队时延迅速增加。该强度的少量增加将导致时延大比例增加。</p>
<p>如果到达的分组发现满队列，由于没有地方存储这个分组，路由器将丢弃该分组，分组会丢失</p>
<h5 id="1-4-3-端到端时延"><a href="#1-4-3-端到端时延" class="headerlink" title="1.4.3 端到端时延"></a>1.4.3 端到端时延</h5><p>含义：源到目的地时延。</p>
<ol>
<li>Traceroute</li>
</ol>
<p>一个短报文，包含路由器名字和地址。</p>
<ol start="2">
<li>端系统、应用程序和其他时延。</li>
</ol>
<h5 id="1-4-4-计算机网络中的吞吐量"><a href="#1-4-4-计算机网络中的吞吐量" class="headerlink" title="1.4.4 计算机网络中的吞吐量"></a>1.4.4 计算机网络中的吞吐量</h5><p><strong>瞬时吞吐量</strong>：主机B接收到该文件的速率。</p>
<p><strong>平均吞吐量</strong>：接收到的大小除以花费的时间。</p>
<p><strong>瓶颈链路传输的速率</strong>：限制吞吐的链路，取两段上速率最小的那段。</p>
<p>吞吐量取决于最小速率，也取决于吞吐量。</p>
<h2 id="1-5-协议层次及其服务模型"><a href="#1-5-协议层次及其服务模型" class="headerlink" title="1.5 协议层次及其服务模型"></a>1.5 协议层次及其服务模型</h2><h3 id="1-5-1-分层体系结构"><a href="#1-5-1-分层体系结构" class="headerlink" title="1.5.1 分层体系结构"></a>1.5.1 分层体系结构</h3><h4 id="1-协议分层"><a href="#1-协议分层" class="headerlink" title="1.协议分层"></a>1.协议分层</h4><p>网络设计者以<strong>分层</strong>的方式组织协议。某层向它的上一层提供的服务。</p>
<p>各层所有协议被称为协议栈，因特网的协议栈分为五种：物理层、链路层、网络层、运输层和应用层。</p>
<img src="https://img-blog.csdnimg.cn/ced5ff7ff3454a6c9c18d4109ed229ea.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWFUgSG9uZ2R1bw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="图片来源：https://image.baidu.com/search/detail?ct=503316480&z=0&ipn=d&word=5%E5%B1%82%E5%9B%A0%E7%89%B9%E7%BD%91%E5%8D%8F%E8%AE%AE%E6%A0%88&step_word=&hs=0&pn=13&spn=0&di=7077213605308923905&pi=0&rn=1&tn=baiduimagedetail&is=0%2C0&istype=0&ie=utf-8&oe=utf-8&in=&cl=2&lm=-1&st=undefined&cs=2245168335%2C1557936172&os=1782924538%2C2879332916&simid=3440522025%2C331546831&adpicid=0&lpn=0&ln=787&fr=&fmq=1650605817814_R&fm=&ic=undefined&s=undefined&hd=undefined&latest=undefined&copyright=undefined&se=&sme=&tab=0&width=undefined&height=undefined&face=undefined&ist=&jit=&cg=&bdtype=0&oriquery=&objurl=https%3A%2F%2Fgimg2.baidu.com%2Fimage_search%2Fsrc%3Dhttp%3A%2F%2Ffilescdn.proginn.com%2Ff222019c13f1bba14835bbf2b0dff60a%2Fd3fbef3cfc575c2aa9a60c87946a76f2.webp%26refer%3Dhttp%3A%2F%2Ffilescdn.proginn.com%26app%3D2002%26size%3Df9999%2C10000%26q%3Da80%26n%3D0%26g%3D0n%26fmt%3Dauto%3Fsec%3D1653197831%26t%3D6365f613229bbf8fc182509466a9b28b&fromurl=ippr_z2C%24qAzdH3FAzdH3F3tfi7tg_z%26e3Br652tgg_z%26e3Bv54AzdH3FrAzdH3F0mnkuk1mjw9k&gsm=e&rpstart=0&rpnum=0&islist=&querylist=&nojc=undefined&dyTabStr=MCw1LDEsNiw0LDMsNyw4LDIsOQ%3D%3D" style="zoom: 67%;" />

<p><strong>1.应用层</strong></p>
<p>是网络应用程序及它们的应用层协议存留的地方。</p>
<p>比如HTTP、SMTP和FRP协议。将端系统名字转换为网络地址是由DNS完成的。</p>
<p>应用层协议分布在多个<strong>端系统</strong>上，而一个端系统中的应用程序使用协议与另一个端系统中的应用程序交换信息分组。我们把这种位于应用层的信息分组称为 <strong>报文(message)</strong> 。</p>
<img src="https://img-blog.csdnimg.cn/47ed1ebc1d4c4043a2ed1a596c8654ec.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWFUgSG9uZ2R1bw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom:67%;" />

<p><strong>2.运输层</strong></p>
<p>因特网的 <strong>运输层</strong> 在应用程序端点之间传送 <strong>应用层报文</strong> 。而运输层的分组我们称之为 <strong>报文段(segment)</strong> 。</p>
<img src="https://img-blog.csdnimg.cn/362905f341684d918f5d1b607b7ee7ea.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWFUgSG9uZ2R1bw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom:67%;" />

<p><strong>3.网络层</strong></p>
<p>因特网的网络层负责将 <strong>数据报</strong> 的 <strong>网络层分组</strong> 从一台主机移动到另一台主机。<br>在一台源主机中的因特网 <strong>运输层协议（TCP或UDP）</strong> 向 <strong>网络层</strong> 递交运输层 <strong>报文段</strong> 和 <strong>目的地址</strong>。</p>
<img src="https://img-blog.csdnimg.cn/1b6e2a247c3e4227b2a54eee4667ecb5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWFUgSG9uZ2R1bw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom: 67%;" />

<p>因特网的网络层也包括决定<strong>路由的路由选择协议</strong>。他根据该路由将数据报从原传输到目的地。因特网具有许多路由选择协议。</p>
<p>简单地被称为IP层。</p>
<p><strong>4.链路层</strong></p>
<p>因特网的网络层通过源和目的地之间的一系列路由器路由数据报。为了将分组从一个节点（主机或路由器）移动到路径上的下一个节点，</p>
<p>网络层必须依靠该链路层的服务。特别是在每个节点，网络层将数据报下传给链路层，链路层沿着路径将数据报传递给下一个节点。在该下一个节点，链路层将数据报双传给网络层。</p>
<p>由链路层提供的服务取决于应用于该链路的 特定链路层协议。网络层会受到来自不同链路层协议的不同服务。<br>链路层的分组称为帧。</p>
<p><strong>5.物理层</strong></p>
<p>虽然链路层的任务是将整个 <strong>帧</strong> 从一个网络元素移动到临近的网络元素，而物理层的任务是将该 <strong>帧</strong> 中的一个个 <strong>比特</strong> 从一个节点移动到下一个节点。在这层中的协议仍然是链路相关的，并且进一步与该链路的 <strong>实际传输媒体</strong> 相关（比如双绞铜线或者光纤等）。</p>
<h4 id="2-OSI模型"><a href="#2-OSI模型" class="headerlink" title="2.OSI模型"></a>2.OSI模型</h4><p>20世纪70年代，ISO组织提出计算机网络围绕7层组织，称为<strong>开放系统互连模型</strong>。</p>
<p>分别是应用层、表示层、会话层、运输层、网络层、数据链路层和物理层。</p>
<h3 id="1-5-2-封装"><a href="#1-5-2-封装" class="headerlink" title="1.5.2 封装"></a>1.5.2 封装</h3><p>在发送主机端， 一个应用层 报文 (application-layer message) (图 1-24 中的 M) 被传送给运输层 。在最简单的情况下，运输层收取到报文并附上附加信息(所谓运输层首部信息，图 1-24 中的$H_1$),该首部将被接收端的运输层使用 。应用层报文和运输层首部信息一道构成了运输层报文段 (transport­ layer segment) 。运输层报文段因此封装了应用层报文。附加的信息也许包括了下列信息: 允许接收端运输层向上向适当的应用程序交付报文的信息；差错检测位信息，该信息让接收方能够判断报文中的比特是否在途中已被改变。运输层则向网络层传递该报文段，网 层增加了如源和目的端系统地址等网络层首部信息(图 1-24 中的$H_n$)生成了网络层数。该数据报 (network-layer datagram) 。 该数据报接下来被传递给链路层，链路层(自然而然地) 增加它自己的链路层首部信息并生成链路层帧 (link-layer frame) 。 所以我们看到，在每一层，一个分组具有两种类型的字段 : 首部字段和有效载荷字段 (payload field) 。有效载荷通常是来自上一层的分组 。</p>
<img src="计算机网络.assets\image-20220529133707931.png" alt="image-20220529133707931" style="zoom:50%;" />

<h2 id="1-6-被攻击的网络"><a href="#1-6-被攻击的网络" class="headerlink" title="1.6 被攻击的网络"></a>1.6 被攻击的网络</h2><p>网络安全：如何攻击网络，以及我们如何防御以免受他们的攻击。</p>
<p><strong>1.因特网有害程序嵌入计算机中</strong></p>
<p>恶意软件：感染设备，收集隐私信息。受害设备网络被称为<strong>僵尸网络</strong>。</p>
<p>多数恶意软件是自我复制。<strong>病毒</strong>是一种需要某种形式的用户交互来感染用户设备的恶意软件。蠕虫是一种无须任何明显用户交互就能进入设备的恶意软件。</p>
<p><strong>2.服务器和网络基础设施遭到攻击</strong></p>
<p>另一类宽泛类型的安全性威胁被称为**拒绝服务攻击(Denial-of-Service (DoS) attack)**。DoS攻击网络、主机或者其他基础设施部分。</p>
<p>DoS攻击分为弱点攻击、带宽洪泛或者连接洪泛。</p>
<p>弱点攻击：这涉及向 一 台目标主机上运行的易受攻击的应用程序或操作系统发送 制作精细的报文。如果适当顺序的多个分组发送给一个易受攻击的应用程序或操作系统，该服务器可能停止运行，或者更糟糕的是主机可能崩溃。</p>
<p>带宽洪泛：攻击者向目标主机发送大量的分组，分组数量之多使得目标的接入链路变得拥塞，使得合法的分组无法到达服务器 。</p>
<p>连接洪泛：攻击者在目标主机中创建大量的半开或全开 TCP 连接(将在第3章中讨论TCP连接) 。 该主机因这些伪造的连接而陷入困境，并停止接受合法的连接 。</p>
<p><strong>3.嗅探分组</strong></p>
<p>在无线传输设备的附近设置一台被动的接收机，会得到传输分组的副本。记录每个流经的分组副本的被动接受机被称为<strong>分组嗅探器</strong>。</p>
<p><strong>4.伪装成信任的人</strong></p>
<p>IP哄骗：一个用户能够冒充另一个用户的许多方式的一种。</p>
<p>解决这个问题的方式：端点鉴别：即一种使我们能够确信一个报文源自我们认为它应当来自的地方的机制。</p>
<h2 id="1-7-计算机网络和因特网的历史"><a href="#1-7-计算机网络和因特网的历史" class="headerlink" title="1.7 计算机网络和因特网的历史"></a>1.7 计算机网络和因特网的历史</h2><h3 id="1-7-1-分组交换的发展-1961-1972"><a href="#1-7-1-分组交换的发展-1961-1972" class="headerlink" title="1.7.1 分组交换的发展(1961-1972)"></a>1.7.1 分组交换的发展(1961-1972)</h3><p>开端：20世纪60年代早期。</p>
<p>全世界具有3个研究组首先发明了分组交换。</p>
<p>分组交换技术首次公开发表出自MIT一名研究生。Kleinrock使用排队论，完美地体现了使用分组交换方法处理突发性流量源的有效性。</p>
<p>1964年，兰德公司的Paul Baran已经开始研究分组交换的应用，以在军用网络上传输安全语音，同时在英国的NPL，Donald Davies和 Roger Scantlebury也在研究分组交换技术。</p>
<p>Robert公布了一个ARPAnet的总体计划，它是第一个分组交换计算机网络。</p>
<p>1969年的劳动节，第一台分组交换机在Kleinrock的监管下安装在美国加州大学洛杉矶分校。</p>
<p>1972年，ARPAnet已经成长到大约15个节点。NCP此时发展。1972年，Ray Tomlinson编写了第一个电子邮件程序。</p>
<h3 id="1-7-2-专用网络户网络互联：1972-1980"><a href="#1-7-2-专用网络户网络互联：1972-1980" class="headerlink" title="1.7.2 专用网络户网络互联：1972~1980"></a>1.7.2 专用网络户网络互联：1972~1980</h3><p>最初的 ARPAnet是一个单一的、封闭的网络。 为了与 ARPAnet 的一台主机通信， 一 台主机必须与另 一台 ARPAnet IMP 实际相连 。 20 世纪 70 年代早期和中期 ，除 ARPAnel 之 外的其他分组交换网络问世: ALOHAnet 是一个微波网络，它将夏威夷岛上 的大 学 [Abramson 1970] 以及 DARPA 的分组卫星[ RFC 829] 和分组无线电网 [Kahn 1987] 连 接到一起; Telenel是 BBN 的商用分组交换网，它基ARPAnet技术;由 Loui~Pouzin领衔 的Cyclades是法国的一个分组交换网 [Think2012];还有如Tymnet和GE信息服务网这样的分时网络，以及 20 世纪 60 年代后期和 70 年代初期的 类似网络[ Schwartz 1977 J; IBM 的 SNA (1996 - 1974) , 它与 ARPAnet 同时在运行 [Schwartz 1977]。</p>
<p>网络的数目开始增加.人们事后看到，研制将网络连接到 一 起的体系结构的时机已 经 成熟 。互联网络的先驱性工作(得到了美国国防部高级研究计划署 (DARPA) 的支持 )由 Vinton Cerf和 Robert Kahn [Cerf 1974] 完成，本质上就是创建一个网络的网络;术语网络互联 (intemetting) 就是用来描述该项工作的 。</p>
<p>这些体系结构的原则体现在TCP 中。然而，TCP 的早期版本与今天的 TCP 差异很大 ” TCP 的早期版本将通过端系统重传的可靠按序数据传递 (仍是今天的 TCP 的 一 部分) 与 转发功能(今天该功能由 IP 执行)相结合 。 TCP 的早期 实验以及认识到对诸 如分组语 音 这样的应用程序中不可靠的、非流控制的 、 端到端传递服务的重要性，导致 IP 从 TCP 中 分离出来，并研制了 UDP 协议 。 我们今天看到的 3 个重要的因特网协议 一 TCP、 UDP 和IP, 到 20 世纪 70 年代末在概念上已经完成 。</p>
<p>除了 DARPA 的因特网相关研究外，许多其他重要的网络活动也在进行中 。 在夏威夷Norman Abramson 正在研制 ALOHAnet, 这是一个基于分组的无线电网络，它使在夏威夷岛 上的多个远程站点互相通信。 ALOHA协议 [Abramson1970] 是第一个多路访问协议，允许地理上分布的用户共享单一的广播通信媒体( 一个无线 电频率 ) 。 Metcalfe 和 Boggs 基 千 Abramson 的多路访问协议，研制了用 于有线共享广播网络的以太网协议 [Metcalfe 1976 ] c 令人感兴趣的是， Metcalfe 和 Boggs 的以太网协议是由连接多台 PC 、打印机和共享磁盘在一起的需求所激励的[ Perkins 1994J。 在 PC 革命和网络爆炸的 25 年之前， Metcalfe 和 Boggs 就奠定了今天 PC LAN 的基础 。</p>
<h3 id="1-7-3-网络的激增：1980-1990"><a href="#1-7-3-网络的激增：1980-1990" class="headerlink" title="1.7.3 网络的激增：1980~1990"></a>1.7.3 网络的激增：1980~1990</h3><p>到了20世纪70年代末，大约200台主机与ARPAnet相连。 到了20世纪80年代末， 连到公共因特网的主机数量达到 100000 台，那时的公共因特网是网络的联盟，看起来非 常像今天的因特网 。 20世纪80年代是联网主机数量急剧增长的时期 。</p>
<p>这种增长是由几个显著成果即创建计算机网络将大学连接到一起引起的 。BITNET 为 位于美国东北部的几个大学之间提供了电子邮件和文件传输 。 建立了 CSNET (计算机科学 网)，以将还没有接人 ARPAnet 的大学研究人员连接在一起。 1986 年，建立了 NSFNET, 为 NSF 资助的超级计算中心提供接入 。 NSFNET 最初具有 56kbps 的主干速率，到了20世纪80年代末，它的主干运行速率是 l. 5Mbps, 并成为连接区域网络的基本主干 。</p>
<p>Minitel项目的发展。</p>
<h3 id="1-7-4-因特网爆炸：20世纪90年代"><a href="#1-7-4-因特网爆炸：20世纪90年代" class="headerlink" title="1.7.4 因特网爆炸：20世纪90年代"></a>1.7.4 因特网爆炸：20世纪90年代</h3><p>1991 年， NSFNET解除了对NSFNET用于商业目的的限制。NSFNET 自身于1995年退役，这时因特网主干流量则由商业因特网服务提 供商负责承载。</p>
<p>然而， 20 世纪 90 年代的主要事件是万维网 (World Wide Web) 应用程序的出现，它将因特网带入世界上数以百万计的家庭和商业中。 Web 作为一个平台，也引入和配置了数 百个新的应用程序，其中包括搜索(如谷歌和Bing) 、因特网商务( 如亚马逊和eBay) 以及社交网络(如脸书)，对这些应用程序我们今天巳经习以为常了 。</p>
<p>Web是由 Tim Bemers-Lee 于 1989 - 1991 年间在 CERN 发明的[ Berners-Lee 1989] ,最初的想法源于 20 世纪 40 年代 Vannevar Bush [ Bush 1945 ] 和 20 世纪 60 年代以来 Ted Nelson [ Xanadu 2012] 在超文本方面的早期工作 。 Bemers-Lee 和他的同事研制了 HTML、 HTTP、 Web 服务器和浏览器的初始版本，这是 Web 的 4 个关键部分 。 到了 1993 年年底前 后，大约有 200 台 Web 服务器在运行，而这些只是正在出现 的 Web 服务器的冰山 一 角 。 就在这个时候，几个研究人员研制了具有 GUI 接口的 Web 浏览器，其中的 Marc Andrees- sen 和 Jim Clark 一起创办了 Mosaic Communications 公司，该公司就是后来的 Netscape 通信 公司[ Cusmano 1998 ; Quittner 1998] 。 到了 1995 年，大学生们每天都在使用 Netscape 浏览器在 Web 上冲浪 。 大约在这段时间，大大小小的公司都开 始运行 Web 服务器，并在 Web 上处理商务 。 1996 年，微软公司开始开发浏览器，这导致了 Netscape 和微软之间的 浏览器之战，并以微软公司在几年后获胜而告终[ Cusumano 1998] 。</p>
<p>20 世纪 90 年代的后5年，随着主流公司和数以千计的初创公司创造了大量因特网产品和服务，因特网到了飞速增长和创新的时期。到了 2000 年末，因特网巳经支待数百流行的应用程序，包括以下4种备受欢迎的应用程序：<br>• 电子邮件，包括附件和 Web 可访问的电子邮件 。<br>• Web,包括Web浏览和因特网商务。<br>• 即时讯息 (i皿tanl messaging) , 具有联系人列表 。<br>• MP3的对等 (peer-to-peer) 文件共享，由Napster开创。</p>
<h3 id="1-7-5-最新发展"><a href="#1-7-5-最新发展" class="headerlink" title="1.7.5 最新发展"></a>1.7.5 最新发展</h3><p>计算机网络中的变革继续以急促的步伐前进。所有的前沿研究正在取得进展，包括部署更快的路由器和在接入网和网络主干中提供更高的传输速率 。 但下列进展值得特别关注:<br>• 自 2000 年开始，我们见证了家庭宽带因特网接入的积极部署一不仅有电缆调制 解调器和 DSL, 而且有光纤到户，这些在 1.2 节中讨论过 。这种高速因特网为丰 富的视频应用创造了条件，包括用户生成的视频的分发 (例如 YouTube) 、电影和<br>电视节目的按需流(例如 Netflix) 以及多人视频 会议(例如 Skype、 Facetime 和 Google Hangouts) 。<br>• 高速 (54Mbps 及更高)公共 WiFi 网络和经过 4G 蜂窝电话网的中速(几十 Mbps) 因特网接入越来越普及，不仅使在运动中保持持续连接成为可能，也产生了新型特定位置应用，如 Yelp、 Tinder、 Yik Yak 和 Waz。 2011 年，与因特网连接的无线 设备的数量超过了有线设备的数量 。 高速无线接入为手持计算机 (iPhone、安卓 手机 、 iPad 等)的迅速出现提供了舞台，这些手持计算机 具有对因特网持续不断 和无拘束接入的优点 。<br>• 诸如脸书 、 lnstagram、 推特 (Twitter) 和微信(在中国极为流行 )这样 的在 线 社交网络已经在因特网之上构建了巨大的人际网络 。 这些社交网络，许多广泛 用于发送消息以及照片分享 。 许多因特网用户今天主要“ 生活”在一个或多个 社交网络中 。 通过他们的 API, 在线社交网络为新的联网应用和分布式游戏创建了平台 。<br>• 如在 I. 3. 3 节中所讨论的，在线服务提供商如谷歌和微软 巳经广泛部署了自己的<br>专用网络。该专用网络不仅将它们分布在全球的数据中心连接在一起，而且通过 直接与较低层 ISP 对等连接，能够尽可能绕过因特网 。因此，谷歌几乎可以瞬间提供搜索结果和电子邮件访问，仿佛它们的数据中心运行在自己的计算机中 一样 。<br>• 许多因特网商务公司在“云”(如亚马逊的 EC2、谷歌的应用引擎 、微软的 Azw·e)中运行它们的应用 。 许多公司和大学也已经将它们的因特网应用(如电子邮件和 Web 托管)迁移到云中 。 云公司不仅可以为应用提供可扩展的计算和存储环境， 也可为应用提供对其高性能专用网络的隐含访问 。</p>
<p><strong>课后习题和问题</strong></p>
<p>复习题：</p>
<p>R1:没有区别。根据书本内容，“主机”和“终端系统”是交换使⽤的。终端系统包括PC、⼯作站、⽹络服务器、邮件服务器、PDA、连接⽹络的游戏控制台等等。⽹络服务器是终端系统。</p>
<p>R2:外交协议常⽤于描述⼀系列国家来往规则。这些构建完备和经过时间检验的规则可以使国家和⼈⺠⽣活和⼯作更简单。协议规则以⼈⺠准则为基础， 其中的⼀部分已经作为现在等级地位的声明。</p>
<p>R3:标准对于协议来说，可以让⼈们创建可以相互操作的⽹络系统和产品。</p>
<p>R4:（1）通过电话线的拨号调制解调器：家庭 （2）通过电话线的DSL（Digital Subscriber Line，数字⽤⼾线）：家庭或⼩办公室 （3）混合光纤同轴电缆：家庭 （4）100M交换以太⽹：企业 （5）⽆线⽹：家庭或企业 （6）3G和4G：⼴域⽆线⽹</p>
<p>R5:HFC带宽是由⽤⼾共享。下⾏通道中，所有的包都是由头端这⼀个单⼀源发出的。因此，下⾏通道中没有碰撞。</p>
<p>R6:光纤到⼾、3G和4G⽆线⽹</p>
<p>R7:10M、100M、1G、10G</p>
<p>R8:双绞线、光纤</p>
<p>R9:拨号调制解调器：最⾼56K，带宽专⽤</p>
<p>ADSL：下⾏最⾼24M，上⾏最⾼2.5M，带宽专⽤ HFC：下⾏最⾼42.8M，上⾏最⾼30.7M，带宽共享 FTTH：上⾏2-10M，下⾏10-20M，带宽不共享</p>
<h1 id="第二章-应用层"><a href="#第二章-应用层" class="headerlink" title="第二章 应用层"></a>第二章 应用层</h1><h2 id="2-1-应用层协议原理"><a href="#2-1-应用层协议原理" class="headerlink" title="2.1 应用层协议原理"></a>2.1 应用层协议原理</h2><p>网络应用程序：核心是写出能够运行在不同的端系统和通过网络彼此通信的程序。</p>
<p><strong>服务器</strong>：</p>
<ul>
<li>7<em>24 小时*<em>提供服务</em></em></li>
<li>可永久性访问的IP地址 / 域名</li>
<li>利用大量服务器实现可扩展性</li>
</ul>
<p><strong>客户机</strong>：</p>
<ul>
<li>与服务器通信，<strong>使用服务器提供的服务</strong></li>
<li>可以间歇性接入网络</li>
<li>可以使用动态 IP 地址</li>
<li>客户机之间没有任何协作、通信</li>
</ul>
<h3 id="2-1-1-网络应用程序体系结构"><a href="#2-1-1-网络应用程序体系结构" class="headerlink" title="2.1.1 网络应用程序体系结构"></a>2.1.1 网络应用程序体系结构</h3><p><strong>应用程序体系结构：</strong>由应用程序研发者设计，规定了如何在各种端系统上组织该应用程序。在选择应用程序体系结构时，有两种主流体系结构：客户-服务器体系结构或者对等P2P结构</p>
<p><strong>客户-服务器体系结构</strong>：一个总是打开的主机称为服务器，服务于称为客户的主机。当 Web 服务器接收到 来自某客户对某对象的请求时，它向该客户发送所请求的对象作为响 应 。 值得注意的是利用客户-服务器体系结构 ，客户相互之间不直接通信 ;例如.在 Web应用中两个浏览器并不直接通信 。 客户-服务器体系结构的另 一个特征是该服务器具有固 定的、周知的地址，该地址称为 IP 地址(我们将很快讨论它) 。 因为该服务器具有固定的 、 周知的地址，并且因为该服务器总 是打开的，客户总是能够通过向该服务器的 IP 地 址发送分组来与其联系 。 具有客户 - 服务器体系结构的非常著名的应用程序包括 Web、 FTP、 Telnet和电子邮件。 图2-2a中显示了这种客户-服务器体系结构。</p>
<p>数据中心是用来创建强大的虚拟服务器。一个数据中心有数十万台服务器。</p>
<p><strong>P2P体系结构</strong>：对位于数据中心的专用服务器有最小(没有)依赖。应用程序在间断连接的主机之间使用直接通信，主机成为对等方。该体系结构也被称为对等方到对等方。</p>
<p>比如文件共享、下载加速器、因特网电话和视频会议。</p>
<p>特性：自拓展性。</p>
<p>挑战：高度非集中结构、安全性、性能和可靠性挑战。</p>
<h3 id="2-1-2-进程通信"><a href="#2-1-2-进程通信" class="headerlink" title="2.1.2 进程通信"></a>2.1.2 进程通信</h3><p>通信实际上是进程。一个进程可认为是运行在端系统中的程序。在不同端系统上的进程通过跨越计算机网络交换报文而互相通信。发送方生成并向网络中发送，接收进程接受并通过回送报文进行响应。</p>
<p><strong>1.客户和服务器进程</strong></p>
<p>进程通过网络相互发送报文。对于两个进程，一个被标记为客户，另一个被标记为服务器。</p>
<p><strong>2.进程与计算机网络之间的接口</strong></p>
<p>进程通过被称为<strong>套接字</strong>的软件接口向网络发送和接收报文。</p>
<p>如该图所示，套接字是同一台主机内应用层与运输层之间的接口。也被称为**应用程序编程接口(API)**。</p>
<p>由于该套接字是建立网络应用程序的可编程接口，因此套接字也称为应用程序和网络之间的应用程序编程接口 (Application Programming Interface, API ) 应用程序开发者可以控制套接字在应用层端的一切，但是对该套接字的运输层端几乎没有控制权。应用程序开发者对千运输层的控制仅限于: ①选择运输层协议; ②也许能设定几 个运输层参数，如最大缓存和最大报文段长度等(将在第3章中涉及) 。一旦应用程序开发者选择了一个运输层协议(如果可供选择的话) ，则应用程序就建立在由该协议提供的运输层服务之上。</p>
<p><strong>3.进程寻址</strong></p>
<p>为了向特定目的地发送邮政邮件，目的地需要有一个地址。类似地，在一台主机上运行的进程为了向在另一台主机上运行的进程发送分组，接收进程需要有一个地址。为了标识该接收进程，需要定义两种信息 : ①主机的地址；②在目的主机中指定接收进程的标识符。</p>
<p>因特网中，主机由其<strong>IP地址</strong>标识。IP地址32比特，除了知道报文发送目的地的主机地址外，发送进程还必须指定运行在接收主机上的<br>接收进程(更具体地说，接收套接字) 。 因为一般而言一台主机能够运行许多网络应用， 这些信息是需要的 。 目的地端口号 (port number) 用于这个目的 。 已经给流行的应用分配了特定的端口号。 例如， Web服务器用端口号80来标识。 邮件服务器进程(使用SMTP 协议)用端口号 25 来标识 。 用于所有因特网标准协议的周知端口号的列表能够在<a href="http://www.iana.org处找到/">http://www.iana.org处找到</a> 。 </p>
<h3 id="2-1-3-可供应用程序使用的运输服务"><a href="#2-1-3-可供应用程序使用的运输服务" class="headerlink" title="2.1.3 可供应用程序使用的运输服务"></a>2.1.3 可供应用程序使用的运输服务</h3><p>套接字是应用程序进程和运输层协议之间的接口。</p>
<p>运输层协议要为不同的应用程序提供不同的服务。大致分为：可靠数据传输、吞吐量、定时和安全性。</p>
<p><strong>1.可靠数据传输</strong></p>
<p>确保由应用程序一端发送的数据正确。</p>
<p><strong>2.吞吐量</strong></p>
<p>带宽敏感应用：具有吞吐量敏感的应用。</p>
<p>弹性应用：根据当时可用的带宽或多或少利用可供使用的吞吐量。</p>
<p><strong>3.定时</strong></p>
<p>运输层协议也能提供定时保证。如同具有吞吐量保证那样，定时保证能够以多种形式实现。一个保证的例子如: 发送方注入进套接字中的每个比特到达接收方的套接字不迟于100ms。 这种服务将对交互式实时应用程序有吸引力，如因特网电话、虚拟环境、电话会 议和多方游戏，所有这些服务为了有效性而要求数据交付有严格的时间限制。</p>
<p><strong>4.安全性</strong></p>
<p>运输协议能够为应用程序提供一种或多种安全性服务。</p>
<p>例如，在发送主机中，运输协议能够加密由发送进程传输的所有数据，在接收主机中，运输层协议能够将数据交付给接收进程之前解密这些数据 。这种服务将在发送和接收进程之间提供机密性，以防该数据以某种方式在这两个进程之间被观察到。 </p>
<h3 id="2-1-4-因特网提供的运输服务"><a href="#2-1-4-因特网提供的运输服务" class="headerlink" title="2.1.4 因特网提供的运输服务"></a>2.1.4 因特网提供的运输服务</h3><p>因特网为应用程序提供两个运输层协议：TCP和UDP。</p>
<p><strong>1.TCP服务</strong></p>
<p>TCP服务模型包括面向连接服务和可靠数据传输服务。当某个应用程序调用TCP作为其运输协议时,该应用程序就能获得来自 TCP的这两种服务。</p>
<p><strong>面向连接的服务</strong>:在应用层数据报文开始流动之前，TCP让客户和服务器互相交换运输层控制信息。这个所谓的握手过程提示客户和服务器，使它们为大量分组的到来做好准备。在握手阶段后，一个 TCP连接（TCP connection) 就在两个进程的套接字之间建立了。这条连接是全双工的,即连接双方的进程可以在此连接上同时进行报文收发。</p>
<p><strong>可靠的数据传送服务</strong>:通信进程能够依靠TCP，无差错、按适当顺序交付所有发送的数据。当应用程序的一端将字节流传进套接字时，它能够依靠TCP将相同的字节流交付给接收方的套接字，而没有字节的丢失和冗余。</p>
<p>TCP协议还具有<strong>拥塞控制</strong>机制和<strong>分组开销</strong>，这种服务不一定能为通信进程带来直接好处，但能为因特网带来整体好处。当发送方和接收方之间的网络出现拥塞时，<strong>TCP的拥塞控制机制会抑制发送进程</strong>（客户或服务器)。TCP拥塞控制也试图限制每个TCP连接,使它们达到公平共享网络带宽的目的。</p>
<p>3次握手 4次放手</p>
<p>特点：1.面向连接</p>
<p>2.每一条tcp连接只能点对点(一对一)</p>
<p>3.提供可靠交付的服务</p>
<p>4.提供全双工服务</p>
<p>5.面向字节流</p>
<p><strong>2.UDP服务</strong></p>
<p>UDP是一种轻量级运输协议。UDP是无连接的，因此在两个进程通信前没有握手过程。UDP协议提供一种不可靠数据传送服务，也就是说，<strong>当进程将一个报文发送进UDP套接字时,UDP协议并不保证该报文将到达接收进程。</strong>到达接收进程的报文也可能是乱序到达的。</p>
<p>UDP没有包括拥塞控制机制,所以UDP的发送端可以用它选定的任何速率向其下层(网络层）注入数据。</p>
<p>特点：1.无链接</p>
<p>2.尽最大努力</p>
<p>3.面向报文</p>
<p>4.无拥塞控制</p>
<p>5.支持一对一、一对多、多对一、多对多的交互通信</p>
<p>6.首部开销小，(只有4个字段 源端口、目的端口、长度、检验和)</p>
<p><strong>3.因特网运输协议所不提供的服务</strong></p>
<p>4个方面组织了运输协议服务:可靠数据传输、吞吐量、定时和安全性。TCP和UDP提供了这些服务中的哪些呢?我们已经注意到TCP提供了可靠的端到端数据传送。并且我们也知道TCP在应用层可以很容易地用SSL来加强以提供安全服务。但在我们对TCP 和UDP的简要描述中，明显地缺少了对吞吐量或定时保证的讨论，即这些服务目前的因特网运输协议并没有提供。这是否意味着诸如因特网电话这样的时间敏感应用不能运行在今天的因特网上呢?答案显然是否定的，因为在因特网上运行时间敏感的应用已经有多年了。这些应用工作得相当好，因为它们已经被设计成尽最大可能对付这种保证的缺乏。总之,今天的因特网通常能够为时间敏感应用提供满意的服务，但它不能提供任何定时或带宽保证。</p>
<h3 id="2-1-5-应用层协议"><a href="#2-1-5-应用层协议" class="headerlink" title="2.1.5 应用层协议"></a>2.1.5 应用层协议</h3><p>定义：运行在不同端系统上的应用程序进程如何相互传递报文。</p>
<p>交换的报文类型、各种报文类型的语法、字段的语义、确定一个进程何时以及发送报文。</p>
<p>有些协议是由RFC文档定义。</p>
<h3 id="2-1-6-本书涉及的网络应用"><a href="#2-1-6-本书涉及的网络应用" class="headerlink" title="2.1.6 本书涉及的网络应用"></a>2.1.6 本书涉及的网络应用</h3><p>5种重要的应用：Web、文件传输、电子邮件、目录服务、流式视频和P2P。</p>
<p>DNS：网络名字到网络地址的转换。</p>
<h2 id="2-2-Web和HTTP"><a href="#2-2-Web和HTTP" class="headerlink" title="2.2 Web和HTTP"></a>2.2 Web和HTTP</h2><h3 id="2-2-1-HTTP概况"><a href="#2-2-1-HTTP概况" class="headerlink" title="2.2.1 HTTP概况"></a>2.2.1 HTTP概况</h3><p>1.Web应用层协议：超文本传输协议(HTTP),是Web核心。</p>
<p>HTTP由两个程序实现：一个客户程序和服务器程序。客户和服务器通过交换HTTP报文进行绘画，</p>
<p>2.Web页面(文档)由对象组成</p>
<ul>
<li><p>一个对象是一个文件。可以是HTML文件、JPEG图像、Java <a href="https://so.csdn.net/so/search?q=applet&spm=1001.2101.3001.7020">applet</a>、音频文件等。</p>
</li>
<li><p>多数网页由单个基本HTML文件和若干个所引用的对象构成。</p>
</li>
<li><p>每个对象被一个URL（统一资源定位符）寻址。(每个URL地址由两部分组成：**存放对象的服务器主机名和对象的路径名)**。</p>
</li>
</ul>
<p>URL形象的给出了任何一个对象、任何一个资源在互联网中的位置。例如</p>
<p><img src="https://img-blog.csdnimg.cn/20210709084904597.png" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/97ab2d33fa04456989bca20d68587771.png" alt="在这里插入图片描述"></p>
<p>注意：路径一般是虚拟路径，它不一定代表这台主机上面实际的本地路径。</p>
<p><strong>URL和域名的区别</strong></p>
<p><a href="https://www.zhihu.com/question/310534288">网址中的www是什么意思? - 知乎 (zhihu.com)</a></p>
<p><strong>域名</strong><br>域名是由一串用“.”分隔的名字组成的Internet上某一台计算机或计算机组的名称。</p>
<p>作用：用来将主机名和域名转换为IP地址的工作。</p>
<p>域名，Domain Name，通常指一个网址的顶级域名。</p>
<p><strong>URL</strong></p>
<p>URL，website address，网页或网站的地址。URL以字符串的抽象形式来描述一个资源在万维网上的地址。统一资源定位符，是一种资源位置的抽象唯一识别方法。一个URL唯一标识一个Web资源，通过与之对应的URL即可获得该资源。可以用来定位网页,多媒体文件等</p>
<p><code>常用的URL格式如下：协议类型://主机or服务器地址[:端口号]/路径/文件名[参数=值]</code></p>
<p>URL中包含了网站的域名.<br>比如一个网址：<a href="http://www.cnblogs.com/gopark/p/8430916.html%E3%80%82%E5%85%B6%E4%B8%ADcnblogs.com%E6%98%AF%E5%9F%9F%E5%90%8D%EF%BC%8Ccnblogs%E6%98%AF%E7%BD%91%E7%AB%99%E5%90%8D%E5%AD%97%EF%BC%8Ccom%E6%98%AF%E5%9F%9F%E5%90%8D%E5%90%8E%E7%BC%80%EF%BC%9Bwww.cnblogs.com%E4%BB%A3%E8%A1%A8%E4%B8%80%E4%B8%AA%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D%EF%BC%8C%E9%80%9A%E5%B8%B8www%E8%A2%AB%E7%94%A8%E6%9D%A5%E7%94%A8%E4%B8%BA%E9%A6%96%E9%A1%B5%E6%A0%87%E8%AF%86%EF%BC%9B">www.cnblogs.com/gopark/p/8430916.html。其中cnblogs.com是域名，cnblogs是网站名字，com是域名后缀；www.cnblogs.com代表一个二级域名，通常www被用来用为首页标识；</a><br><a href="https://www.cnblogs.com/gopark/p/8430916.html%EF%BC%8C%E8%BF%99%E4%B8%AA%E5%88%99%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E7%BD%91%E7%AB%99%E9%A6%96%E9%A1%B5URL%E5%9C%B0%E5%9D%80%E3%80%82https://%EF%BC%8C%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E5%8D%8F%E8%AE%AE%EF%BC%8C%E6%98%AF%E7%BD%91%E7%AB%99%E5%9C%A8%E7%BD%91%E4%B8%8A%E4%BC%A0%E8%BE%93%E7%9A%84%E5%8D%8F%E8%AE%AE%E3%80%82">https://www.cnblogs.com/gopark/p/8430916.html，这个则是一个完整的网站首页URL地址。https://，这是一个协议，是网站在网上传输的协议。</a></p>
<p>Web服务器实现了HTTP的服务器端，它用于存储Web对象。它用于存储Web对象。每个对象由URL寻址。流行的服务器有Apache和微软互联网信息中心。</p>
<p><strong>访问阶段</strong></p>
<p>HTTP定义了Web客户向Web服务器请求Web页面，以及服务器向客户传送Web页面方式。</p>
<p>我们使用HTTP协议进行访问时主要有两个阶段<br>1.当用户请求一个 Web 页面(如点击一个超链接)时，浏览器向服务器发出对该页面中所包含对象的 HTTP请求报文。</p>
<p>2.服务器接收到请求并用包含这些对象的 HTTP 响应报文进行响应。</p>
<p>注意：不管是什么类型的主机，什么类型的客户端，只要遵从HTTP协议，就可以和遵从HTTP协议的服务器端通信。在下图列出两种。</p>
<p><img src="F:\计算机网络\计算机网络.assets\image-20220531182849694.png" alt="image-20220531182849694"></p>
<p><strong>特点</strong></p>
<p>1.HTTP使用TCP作为它的支撑运输协议。</p>
<p>（1）客户端初始化一个与HTTP服务器80端口的TCP连接，也就是创建套接字。<br>（2）HTTP服务器接收来自客户的TCP连接请求，建立连接。<br>（3）Browser和Web服务器交换HTTP消息（应用层协议消息），包括HTTP请求和响应消息。<br>（4）最后关闭TCP连接。</p>
<p>客户向它的套接字接口发送HTTP 请求报文并从它的套接字接口接收HTTP响应报文。</p>
<p>服务器从它的套接字接口接收HTTP请求报文和向它的套接字接口发送 HTTP 响应报文。一旦客户向它的套接字接口发送 一个请求报文，该报文就脱离了客户控制并进入 TCP 的控制 。</p>
<p>最大特点：HTTP协议不用担心数据丢失，也不关注TCP从网络的数据丢失和乱序故障中恢复的细节。</p>
<p>2、无状态协议<br>无状态协议，即不维护客户先前的状态信息。<br>例如访问某个网页访问到一半时网络断掉了，当从新连上网再去访问时就要重新开始。</p>
<p>做成无状态的原因：维护状态的协议非常复杂，具体为：<br>（1）必须维护过去历史。<br>（2）如果server/client崩溃，它们各自的状态视图可能不一致，因此必须保持协调一致。</p>
<h3 id="2-2-2-非持续性连接和持续连接"><a href="#2-2-2-非持续性连接和持续连接" class="headerlink" title="2.2.2 非持续性连接和持续连接"></a>2.2.2 非持续性连接和持续连接</h3><p>HTTP连接可以分为持久性连接和非持久性连接。</p>
<p><strong>非持续连接</strong>：每个请求/响应对经过一个单独的TCP连接发送。</p>
<p><strong>持续连接</strong>：每个请求/响应对经过相同的TCP连接发送</p>
<p><strong>响应时间模型</strong></p>
<p>为了区别持久性连接和非持久性连接的时间、效率等，需要定义一些响应时间模型。</p>
<p>1、定义往返时间RTT</p>
<p>1个小分组从客户机到服务器再到客户机所花费的时间我们可以称之为RTT。</p>
<p>2、响应时间分析<br>（1）1个RTT用于建立TCP连接<br>（2）1个RTT用于HTTP请求/响应消息的交互<br>（3）HTML文件传输的时间=2RTT+传输时间<br>通过下图更直观的显示了时间响应模型：</p>
<p><img src="https://img-blog.csdnimg.cn/20210709111423816.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><strong>1.采用非持续连接的HTTP</strong></p>
<p>我们看看在非待续连接情况下 ，从服务楛向客户传送一个Web页面的步骤。假设该页面含有一个 HTML 基本文件和 10 个 JPEG 图形、并且这 11 个对象位于同 一 台服务器上。进一步假设该 HTML文件的 URL 为: <a href="http://www.someschool.edu/someDepartment/home.index%E3%80%82">http://www.someSchool.edu/someDepartment/home.index。</a><br>我们看看发生了什么情况 :</p>
<ol>
<li>HTTP客户进程在端口号80发起一个到服务器<a href="http://www.someschool.edu的tcp连接,该端口号是/">www.someSchool.edu的TCP连接，该端口号是</a> HTTP 的默认端口。在客户和服务器上分别有一个套接字与该连接相关联 。</li>
<li>HTTP客户经它的套接字向该服务器发送一个HTTP 请求报文。请求报文中包含了路径名/someDepartment/home.index (后面我们会详细讨论HTTP报文)。</li>
<li>HTTP 服务器进程经它的套接字接收该请求报文，从其存储器 (RAM 或磁盘)中 检索出对象<a href="http://www.someschool.edu/someDepartment/home.index%EF%BC%8C%E5%9C%A8%E4%B8%80%E4%B8%AAHTTP%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E4%B8%AD%E5%B0%81%E8%A3%85%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%B9%B6%E9%80%9A%E8%BF%87%E5%85%B6%E5%A5%97%E6%8E%A5%E5%AD%97%E5%90%91%E5%AE%A2%E6%88%B7%E5%8F%91%E9%80%81%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87">www.someSchool.edu/someDepartment/home.index，在一个HTTP响应报文中封装对象，并通过其套接字向客户发送响应报文</a> 。</li>
<li>HTTP服务器进程通知 TCP 断开该 TCP 连接 。 (但是直到TCP确认客户已经完整地收到响应报文为止，它才会实际中断连接。</li>
<li>HTTP 客户接收响应报文，TCP连接关闭。该报文指出封装的对象是一个HTML文件客户从响应报文中提取出该文件，检查该 HTML 文件，得到对10个JPEG 图形的引用 。</li>
<li> 对每个引用的 JPEG 图形对象重复前 4 个步骤。</li>
</ol>
<p>当浏览器收到 Web 页面后，向用户显示该页面 。 两个不同的浏览器也许会以不同的方式解释 ( 即向用户显示)该页面。HTTP 与客户如何解释一个Web页面毫无关系。HTTP规范([RFC 1945] 和[RFC 2616]) 仅定义了在HTTP客户程序与HTTP服务器程序之间的通信协议 。</p>
<p>每个TCP连接在服务器发送一个对象后关闭，该连接不为其他对象而持续下来。每个TCP连接只传输一个请求报文和响应报文。</p>
<p><strong>往返时间</strong></p>
<p>Round-Trip Time,RTT.该时间是指一个短分组从客户到服务器然后再返回客户所花费的时间。RTT包括分组传播时延、分组在中间路由器和交换机上的排队时延以及分组处理时延。</p>
<img src="F:\计算机网络\计算机网络.assets\image-20220601132924928.png" alt="image-20220601132924928" style="zoom: 33%;" />

<p>涉及三次握手过程。</p>
<p>即客户向服务器发送一个小TCP报文段，服务器用一个小 TCP 报文段做出确认和响应，最后，客户向服务器返回确认。三次握手中前两个部分所耗费的时间占用了一个 RTT。完成了三次握手的前两个部分后，客户结合三次握手的第三部分(确认)向该 TCP 连接发送一个 HTTP 请求报文。一旦该请求报文到达服务器，服务器就在该 TCP 连接上发送 HTML文件 。该 HTTP 请求/响应用去了另一个RTT。 因此，粗略地讲，总的响应时间就是两个 RTT 加上服务器传输 HTML 文件的时间。</p>
<p><strong>2.采用持续连接的HTTP</strong></p>
<p>非持续连接的缺点：</p>
<ol>
<li>必须为每个请求的对象建立和维护一个全新的连接。</li>
<li>每一个对象经受两倍RTT的交付时延。</li>
</ol>
<p>在持续连接的情况下：服务器发送响应后保持该TCP连接打开。在相同的客户与服务器之间，后续的请求和响应报文，能够通过相同的连接进行传送。例子：一个完整的Web页面可以用单个持续TCP连接进行传送。甚至位于同一台服务器的多个Web页面在从服务器发送给同一个客户时，可以在单个持续TCP连接上进行。对对象的这些请求可以一个接一个地发出，而不必等待对未决请求的回答。</p>
<p><strong>HTTP 1.0和HTTP 1.1的主要区别是什么?</strong></p>
<ol>
<li>长连接 : 在HTTP/1.0中，默认使用的是短连接，也就是说每次请求都要重新建立一次连接。HTTP是基于TCP/IP协议的,每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。因此最好能维持一个长连接，可以用个长连接来发多个请求。HTTP1.1起，默认使用长连接 ,默认开启Connection： keep-alive。 HTTP/1.1的持续连接有非流水线方式和流水线方式 。流水线方式是客户在收到HTTP的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。</li>
<li>带宽优化及网络连接的使用 : HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>
<li>Host域：在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。HTTP1.0是没有host域的，HTTP1.1才支持这个参数。</li>
<li>错误状态响应码 : 在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li>
<li>缓存处理 : 在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li>
</ol>
<p><strong>HTTP2.0的优化</strong></p>
<ol>
<li>新的二进制格式：HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</li>
<li>多路复用：在同一个TCP连接中，同一时刻可以发送多个请求和响应,下一次的请求不需要等待上一个响应来之后再发送。但响应的顺序是不变的，FIFO（先进先出）。2.0之前是同一个连接只能用一次， 如果开启了keep-alive，虽然可以用多次，但是同一时刻只能有一个HTTP请求。</li>
<li>HTTP2.0的多路复用主要是指：因为http2.0的传输是基于二进制帧的。每一个TCP连接中承载了多个双向流通的流，每一个流都有一个独一无二的标识和优先级，而流就是由二进制帧组成的。二进制帧的头部信息会标识自己属于哪一个流，所以这些帧是可以交错传输，然后在接收端通过帧头的信息组装成完整的数据。这样就解决了线头阻塞的问题，同时也提高了网络速度的利用率。</li>
<li>header压缩，HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用HPACK算法对header的数据进行压缩，避免了重复header的传输，又减小了需要传输数据的大小，基本原理是客户端和服务端分别缓存一份索引表，如果头部存在于索引表，则用对应的索引值；否则进行霍夫曼编码，并加入索引表。参考</li>
<li>服务器推送， 当我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源。服务器端推送的这些资源其实存在客户端的某处地方，客户端直接从本地加载这些资源就可以了，不用走网络，速度自然是快很多的。</li>
</ol>
<h3 id="2-2-3-HTTP报文格式"><a href="#2-2-3-HTTP报文格式" class="headerlink" title="2.2.3 HTTP报文格式"></a>2.2.3 HTTP报文格式</h3><p>HTTP报文是面向文本的，报文中的每一个字段都是一些ASCII码串，每个字段的长度是不确定的。HTTP报文传过来的都是一堆的0x ASCII码，例如” 41 63 63 65 70 74”这段十六进制ASCII码串对应的是“accept” 单词。</p>
<p>这些十六进制的数字经过浏览器或者专用工具比如wireshark或fiddler的翻译，可以得到HTTP的报文结构。</p>
<h5 id="请求头部"><a href="#请求头部" class="headerlink" title="请求头部"></a>请求头部</h5><p>请求头部为请求报文添加了一些附加信息，由“名/值”对组成，每行一对，名和值之间使用冒号分隔。请求头部通知服务器有关于客户端请求的信息。比较常见的有：</p>
<p><img src="https://img-blog.csdnimg.cn/70810659bd9e4ffd831dc14464e997a9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAWXNtaW5nODg=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>HTTP有两种报文：请求报文和响应报文。</p>
<p><strong>1.请求报文</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">GET http://jsuacm.cn/ HTTP/1.1</span><br><span class="line">Host: jsuacm.cn</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.25 Safari/537.36 Core/1.70.3877.400 QQBrowser/10.8.4506.400</span><br><span class="line">Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line"></span><br><span class="line">//”请求数据”(GET方式的请求一般不包含)</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/28f0146f4568480abf9afe951dbfddc9.png" alt="在这里插入图片描述"></p>
<p><strong>可见HTTP的请求报文由四部分组成：请求行(request line)、请求头部(header)、空行和请求数据(request data)</strong></p>
<p>第一行：请求行(方法字段、URL字段和HTTP版本字段，<strong>们用空格分隔</strong>。例如：GET <a href="http://jsuacm.cn/template/jsu/css/modifypage-1.css">http://jsuacm.cn/template/jsu/css/modifypage-1.css</a> HTTP/1.1)</p>
<p>请求方法字段：HTTP协议的请求方法有GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT。GET和POST是最常用的请求方法。</p>
<p>请求头部的最后会有一个空行，表示请求头部结束，接下来为请求数据。</p>
<p>后继行：首部行</p>
<p>首部行：Host 指明对象所在的主机。</p>
<p>Connection：close首部行，告诉服务器是否使用持续连接，它要求服务器在发送完被请求的浏览器的类型。</p>
<p>Accept-language：首部行表示用户想得到该对象的法语版本(如果服务器中有这样的对象)；否则，服务器应当发送它的默认版本。</p>
<p>Accpet-language：首部行仅仅是HTTP中可用的众多内容协商首部之一。</p>
<p>首部行后有一个”实体体“。</p>
<p>使用Get方法时实体体为空，使用POST方法才使用该实体体。</p>
<p><strong>POST</strong></p>
<p>提交表单，搜索：POST方法。</p>
<p>和get一样很常见，对于上面提到的不适合使用GET方式的情况，可以考虑使用POST方式，因为使用POST方法可以允许客户端给服务器提供信息较多。POST方法将请求参数封装在HTTP请求数据中，以名称/值的形式出现，可以传输大量数据，这样POST方式对传送的数据大小没有限制，而且也不会显示在URL中。</p>
<p><strong>GET</strong></p>
<p>HTML表单经常使用GET方法。</p>
<p>最常见的一种请求方式，当客户端要从服务器中读取文档时，当点击网页上的链接或者通过在浏览器的地址栏输入网址来浏览网页的，使用的都是GET方式。GET方法要求服务器将URL定位的资源放在响应报文的数据部分，回送给客户端。使用GET方法时，请求参数和对应的值附加在URL后面，利用一个问号（“?”）代表URL的结尾与请求参数的开始，传递参数长度受限制。</p>
<p>GET方式的请求一般不包含”请求数据”部分，请求数据以地址的形式表现在请求行。显然，这种方式不适合传送私密数据。另外，由于不同的浏览器对地址的字符限制也有所不同，一般最多只能识别1024个字符，所以如果需要传送大量数据的时候，也不适合使用GET方式。<br><strong>HEAD</strong></p>
<p>HEAD方法类似GET方法。本质和get一样，只不过服务端接受到HEAD请求后只返回响应头，而不会发送响应内容。当我们只需要查看某个页面的状态的时候，使用HEAD是非常高效的，因为在传输的过程中省去了页面内容。</p>
<p><strong>PUT</strong></p>
<p>PUT 方法常与 Web 发行工具联合使用，它允许用户上传对象到指定的 Web 服务 器上指定的路径(目录)。PUT方法也被那些需要向 Web服务器上传对象的应用程序使 用 。和post类似，html表单不支持，发送资源与服务器，并存储在服务器指定位置，可用于替换资源，要求客户端事先知道该位置。</p>
<p><strong>DELETE</strong></p>
<p>DELETE 方法允许用 户或者应用程序删除Web服务器上的对象。请求服务器删除某资源。和put都具有破坏性，可能被防火墙拦截。如果是https协议，则无需担心。</p>
<p>CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。就是把服务器作为跳板，去访问其他网页然后把数据返回回来，连接成功后，就可以正常的get、post了。</p>
<p>OPTIONS：获取http服务器支持的http请求方法，允许客户端查看服务器的性能，比如ajax跨域时的预检等。</p>
<p>TRACE：回显服务器收到的请求，主要用于测试或诊断。一般禁用，防止被恶意攻击或盗取信息。</p>
<p><strong>2.HTTP响应报文</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Connection: close</span><br><span class="line">Date: Wed, 20 Oct 2021 06:46:15 GMT</span><br><span class="line">Server: nginx/1.18.0 (Ubuntu)</span><br><span class="line">Last-Modified Wed, 20 Oct 2021 06:11:15 GMT</span><br><span class="line">Content-Length: 737265</span><br><span class="line">Content-Type: text/html</span><br></pre></td></tr></table></figure>

<p>三部分：初始状态行、6个首部行、然后是实体体。</p>
<p>实体体：报文主要部分，包含了所请求的对象本身。状态行有3个字段：协议版本字段、状态码和相应状态信息。</p>
<blockquote>
<p> 首部行:</p>
</blockquote>
<p>Connection：close首部行告诉客户，发送完将关闭该TCP连接。</p>
<p>Date：首部行指示服务器产生并发送该响应报文的日期和时间。</p>
<p>Server：由什么服务器产生。类似请求报文中的User-Agent：首部行。</p>
<p>Last-Modified：首部行指示了对象创建或者最后修改的日期和时间。</p>
<p>Content-Length：首部行指示了实体体中的对象是HTML文本。</p>
<p>Content-Type：首部行指示了实体体中的对象是HTML文本。</p>
<p><img src="F:\计算机网络\计算机网络.assets\image-20220603233418699.png" alt="image-20220603233418699"></p>
<p><strong>状态行</strong></p>
<p>状态行由3部分组成，分别为：协议版本、状态码、状态码描述。其中协议版本与请求报文一致，状态码描述是对状态码的简单描述。</p>
<p>HTTP状态码</p>
<p><img src="https://img-blog.csdnimg.cn/08f780f945204228b2d30d141de06e38.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAWXNtaW5nODg=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><strong>响应头部</strong></p>
<p>常见响应头部及描述如下：</p>
<p><img src="https://img-blog.csdnimg.cn/e0fdcf851081478f8d21d383829528d1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAWXNtaW5nODg=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><strong>空行</strong></p>
<p>响应头部的最后会有一个空行，表示响应头部结束，接下来为响应数据。与请求报文一致。</p>
<p><strong>响应体</strong></p>
<p>用于存放需要返回给客户端的数据信息。fiddler抓出来的一段HTTP响应数据是一段HTML。</p>
<h3 id="2-2-4-用户与服务器的交互-cookie"><a href="#2-2-4-用户与服务器的交互-cookie" class="headerlink" title="2.2.4 用户与服务器的交互:cookie"></a>2.2.4 用户与服务器的交互:cookie</h3><p>HTTP服务器是无状态的（也就是不记录请求服务的客户机的信息），但是有时候Web站点希望可以识别用户，以实现诸如限制用户访问和识别用户身份的功能。为此，Web站点使用了cookie技术（注意：cookie不属于HTTP协议，他是补充HTTP某方面功能性不足的技术）。</p>
<p>cookie有四个组件：</p>
<ol>
<li>在HTTP响应报文中保留一个cookie首部行</li>
<li>在HTTP请求报文中保留一个cookie首部行</li>
<li>用户端系统中保留有一个cookie文件，并由用户的浏览器进行管理</li>
<li>位于Web站点的一个管理cookie的后端总数据库</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20210710111611842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>cookie可以标识用户，后继会话中，浏览器向服务器传递一个cookie首部，服务器标识用户。因此cookie可以在无状态的HTTP之上建立一个用户会话层。</p>
<p>cookies带来了很多方便和便利的地方。常见的有：<br>（1）身份认证：例如我们在登录某个网站时填写登录表单，只填写一次即可。<br>（2）用户会话状态恢复：将上次访问的会话状态记录下来，等下次再访问的时候可以恢复到上次的状态，而不需要重头开始。<br>（3）虚拟购物车：例如我们在逛淘宝时看到心仪的商品会加入到购物车中，等到下一次重新打开时购物车里的东西不会消失。<br>（4）推荐广告：广告公司通过网站获得信息，为他们的广告投放提供便利。</p>
<h3 id="2-2-5-Web缓存"><a href="#2-2-5-Web缓存" class="headerlink" title="2.2.5 Web缓存"></a>2.2.5 Web缓存</h3><p>也叫**代理器(proxy server)**：能够代表初始Web服务器来满足HTTP请求的网络实体。Web缓存器有自己的磁盘存储空间，并在存储空间中保存最近请求过的对象的副本。</p>
<img src="F:\计算机网络\计算机网络.assets\image-20220604195238630.png" alt="image-20220604195238630" style="zoom:67%;" />

<p>假设浏览器正在请求对象<a href="http://www.someschool.edu/campus.gif%EF%BC%8C%E5%B0%86%E4%BC%9A%E5%8F%91%E7%94%9F%E4%B8%80%E4%B8%8B%E6%83%85%E5%86%B5%EF%BC%9A">http://www.someschool.edu/campus.gif，将会发生一下情况：</a></p>
<p>1)浏览器创建一个到Web缓存器的TCP连接，并向Web缓存器中的对象发送一个HTTP请求。</p>
<p>2)Web缓存器进行检查，看看本地是否存储了该对象副本。如果有， Web 缓存器就向客户浏览器用HTTP响应报文返回该对象 。</p>
<p>3)如果Web缓存器中没有该对象，它就打开一个与该对象的初始服务器(即 <a href="http://www.someschool.edu/">www.someschool.edu</a>) 的TCP连接。Web缓存器则在这个缓存器到服务器的TCP连接上发送一个对该对象的HTTP 请求。在收到该请求后，初始服务器向该 Web 缓存器发送具有该 对象的 HTTP 响应 。</p>
<p>4)当 Web缓存器接收到该对象时，它在本地存储空间存储一份副本，并向客户的浏览器用 HTTP 响应报文发送该副本(通过现有的客户浏览器和 Web 缓存器之间的 TCP 连接) 。</p>
<p>值得注意的是 Web 缓存器既是服务器又是客户。当它接收浏览器的请求并发回响应时，它是一个服务器。当它向初始服务器发出请求并接收响应时，它是一个客户。</p>
<p>这里需要注意的是缓存器既是服务器又是客户机，简单来说：<br>（1）对客户端来说是服务器<br>（2）对原始服务器来说是客户端<br>大学、公司是使用缓存器的典型。</p>
<p>那么为什么需要Web缓存器呢？主要原因有以下三点：<br>（1）减少对客户机请求的响应时间<br>（2）减少内部网络与接入链路上的通信量<br>（3）能从整体上大大降低因特网的Web流量</p>
<p>通过内容分发网络(CDN)，Web缓存器正在因特网中发挥着越来越重要的作用。</p>
<h3 id="2-2-6-条件GET方法"><a href="#2-2-6-条件GET方法" class="headerlink" title="2.2.6 条件GET方法"></a>2.2.6 条件GET方法</h3><p>在使用Web缓存技术时要用一种新的方法，叫GET方法。<br>GET方法目的：证实缓存器中的对象是否为最新。<br>方法具体内容为：<br>（1）缓存器：在请求报文中包含对象最后修改时间。以判断从缓存器中得到的信息是否为最新。<br>（2）服务器：如果对象是最新的那么响应报文中不包含对象，否则需要包含最新对象。</p>
<h2 id="2-3-因特网中的电子邮件"><a href="#2-3-因特网中的电子邮件" class="headerlink" title="2.3 因特网中的电子邮件"></a>2.3 因特网中的电子邮件</h2><p>包括3部分：用户代理、邮件服务器和简单邮件传输协议(SMTP)。</p>
<p>清楚报文队列概念。</p>
<h3 id="2-3-1-SMTP"><a href="#2-3-1-SMTP" class="headerlink" title="2.3.1 SMTP"></a>2.3.1 SMTP</h3><p>SMTP是因特网电子邮件的核心。</p>
<p>SMTP协议是互联网上最古老的应用之一，是电子邮件所采用的协议，是电子邮件发送电子邮件时的协议。</p>
<p>用户代理：运行在客户端的软件。</p>
<p>作用：<br>（1）它允许用户阅读，回复，转发，保存，编辑邮件消息。<br>（2）发送/接收邮件消息到/从服务器。<br>（3）运行邮件协议。</p>
<p><strong>邮件服务器</strong>：也就是我们常说的邮箱存放的位置。</p>
<p>作用：<br>（1）用邮箱存放用户接收的邮件消息。事实上现在绝大部分邮件服务器也同时存放发送的邮件。<br>（2）在邮件服务器上有一个外出报文队列，在里面放的是用户将要发送的邮件。邮件服务器可能需要很多邮件要发送，这时需要排队。<br>（3）运行邮件信息。邮件服务器要通过运行邮件协议来进行邮件的发送。</p>
<p>SMTP特点：</p>
<p>（1）使用TCP协议<br>（2）服务器端口号为25<br>（3）直接传送：SMTP协议是一种直接传送的协议。即发送服务器与接收服务器直连，没有经过中转。<br>（4）采用命令/应答的交互方式。<br>命令：ASCII文本格式<br>应答：状态码及其短语<br>（5）邮件消息必须是7-bit ASCII：邮件消息必须是标准ASCII码，因为邮件协议比较古老，设计者在设计邮件协议时并没有考虑到其他国家即非英语的国家使用邮件时怎么办。</p>
<p>三个阶段：（1）握手<br>（2）传输邮件消息<br>（3）结束</p>
<p><img src="F:\计算机网络\计算机网络.assets\image-20220604215509064.png" alt="image-20220604215509064"></p>
<p>SMTP不向中间邮件服务器发送邮件</p>
<p>首先，客户 SMTP (运行在发送邮件服务器主 机上)在 25 号端口建立一个到服务器 SMTP (运行在接收邮件服务器主机上)的 TCP 连接。如果服务器没有开机，客户会 在稍后继续尝试连接。一旦连接建立，服务器和客户执行某些应用层的握手，就像人们在互相交流前先进行自我介绍一样。SMTP的客户和服务器在传输信息前先相互介绍。在 SMTP 握手的阶段， SMTP 客户指示发送方的邮件地址(产生报文的那个人) 和接收方的邮件地址。一旦该 SMTP 客户和服务器彼此介绍之后，客户发送该报文。SMTP 能依赖 TCP 提供的可靠数据传输无差错地将邮件投递到接收服务器。该客户如果有另外的报文要发送到该服务器，就在该相同的TCP连接上重复这种处理；否则，它指示 TCP关闭连接。</p>
<p>下面我们来看一下SMTP客户端和服务器的命令交互：</p>
<p><img src="F:\计算机网络\计算机网络.assets\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70#pic_center.png" alt="在这里插入图片描述"></p>
<p>蓝色：我们需要输入的命令<br>黑色：给出的应答<br>（1）当我们连接服务器时，服务器会给出一个220响应，表示连上了。<br>（2）之后客户端要握手，握手的命令是HELO，后面给出一个域。<br>（3）S给出250回应，表示握手成功，后面的短语也可以自己定义。<br>（4）接下来C给出MAIL FROM命令告诉服务器我要以这个电子邮件作为发送方来发送邮件。<br>（5）S继续给出250表示可以发送。<br>（6）然后C使用RCPT TO命令来给出我要将邮件发送到哪个地址。<br>（7）服务器端收到命令以后再次给出250回应表示可以.<br>（8）给出354的提示告诉客户端你现在可以写邮件了，邮件要以单独的句号作为结束，而且句号必须独占一行。<br>（9）接下来就是客户端写邮件，当写完以后送到服务器端。（10）服务器端再次给出250回应表示这个消息被接收了放到队列里准备被发送。<br>（11）C给出QUIT命令退出。<br>（12）S给出221回应表示连接结束。<br>注意：SMTP通过回车换行、句号、回车换行来判断消息的结束。</p>
<h3 id="2-3-2-与HTTP的对比"><a href="#2-3-2-与HTTP的对比" class="headerlink" title="2.3.2 与HTTP的对比"></a>2.3.2 与HTTP的对比</h3><p>（1）HTTP是拉协议，即用户把消息拉下来；SMTP是推协议，即用户把消息推出去。<br>（2）都有ASCII命令/应答交互，状态码。SMTP要求报文采用7比特ASCII码格式。HTTP不受限制。<br>（3）HTTP：每个对象封装在它各自的HTTP响应报文中发送；SMTP：一个邮件内各个对象置于同一个邮件消息的多目的发送。</p>
<h3 id="2-3-3-邮件报文格式"><a href="#2-3-3-邮件报文格式" class="headerlink" title="2.3.3 邮件报文格式"></a>2.3.3 邮件报文格式</h3><p>邮件消息格式是在RFC 822里面规定的。</p>
<p>每一个典型的邮件报文都包含首部行和报文体。</p>
<p>一个标准的邮件格式分为头部和信体两部分，头部由多个头部行构成。列出最常见的三个。<br>（1）To：发给谁<br>（2）From：谁发送的<br>（3）Subject：邮件的主题<br>在写邮件时这三个必不可少。<br>注意：这里的To、From是邮件内容组成部分，这些头部不同于SMTP命令。<br>头部后再加一个空行之后跟邮件的主体，也就是邮件的信体。</p>
<p>首部行和报文体用空格分割。</p>
<p><img src="https://img-blog.csdnimg.cn/20210712122222479.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from:</span><br><span class="line">to:</span><br><span class="line">subject:</span><br></pre></td></tr></table></figure>

<p>报文首部之后，紧接着一个空白行，然后是以ACSII格式表示的报文体。输入telnet serverName25。</p>
<h3 id="2-3-4-邮件访问协议"><a href="#2-3-4-邮件访问协议" class="headerlink" title="2.3.4 邮件访问协议"></a>2.3.4 邮件访问协议</h3><p><strong>1.访问类型:</strong></p>
<p>邮件访问协议的作用是从服务器中取出邮件。常用的邮件访问协议有三类。<br>（1）POP3第三版的邮局协议：授权、下载邮件<br>（2）IMAP因特网邮件访问协议：相比POP，具有更多特性，比如分类管理服务器上的邮件。<br>（3）HTTP：例如Gmail、Hostmail、QQ邮箱、网易邮箱等都提供了使用HTTP来进行邮件访问的功能。</p>
<p><img src="F:\计算机网络\计算机网络.assets\image-20220604222857726.png" alt="image-20220604222857726"></p>
<h4 id="1-POP3协议"><a href="#1-POP3协议" class="headerlink" title="1.POP3协议"></a>1.POP3协议</h4><p>POP协议使用最多的是第三个版本，所以也叫POP3。包括3个阶段。<br>（1）特许<br>（2）事务处理<br>（3）更新</p>
<p><strong>特许阶段</strong>：用户代理发送(以明文形式)用户名和口令以鉴别用户。</p>
<p>主要有两个命令：user<user name>和pass<password></p>
<p>服务器对命令有两个回答:+OK(指示前面命令正常)和-ERR(指示前面命令出现某些差错)。</p>
<img src="https://img-blog.csdnimg.cn/20210712134235520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:67%;" />

<p>当连接到server时给出连接响应，服务器等待客户端给出命令；<br>客户端发送user bob命令过去；<br>S接收到以后C再给出password；<br>若用户名和密码没有问题，S给出OK回应，OK后的短语可以自行定义。</p>
<p><strong>事务处理阶段</strong>：用户代理取回报文，同时在这个阶段用户代理还能进行如下操作：对报文做删除标记，取消报文删除标记，以及获取邮件的统计信息。</p>
<p>当我们获得授权以后就进入到事务处理阶段。<br>在事务处理阶段客户端主要有以下几个命令可以使用：<br>（1）list：列出邮件编号，看一下服务器上有哪些邮件，服务器端给出的应答比较简单它给出若干个邮件的序号以及邮件的大小。<br>（2）retr：按编号取邮件<br>（3）dele：删除邮件。<br>（4）quit：<br>例子如下：<br><img src="https://img-blog.csdnimg.cn/20210712134420726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>更新阶段</strong>：客户发出quit命令后，结束该POP3会话。</p>
<h4 id="2-IMAP"><a href="#2-IMAP" class="headerlink" title="2.IMAP"></a>2.IMAP</h4><p>POP3无法为用户提供任何创建远程文件夹并为报文指派文件夹的方法。</p>
<p>IMAP是一个邮件访问协议，但是它比POP3具有更多的特色。</p>
<p>IMAP服务器把每个报文与一个文件夹联系起来：当报文第一次到达服务器时，它与收件人的INBOX文件夹相关联。收件人则能够把邮件移到 一个新 的、用户创建的文件夹中，阅读邮件，删除邮件等。IMAP 协议为用户提供 了创建文件夹以及将邮件从一个文件夹移动到另一个文件夹的命令。IMAP 还为用 户提供了在远程文件夹中查 询邮件的命令，按指定条件去查询匹配的邮件 。 值得注意的是，与POP3不同，IMAP服务器维护了IMAP会话的用户状态信息，例如，文件夹的名字以及哪些报文与哪些文件夹相关联。</p>
<p>IMAP的另一个重要特性是它具有允许用户代理获取报文某些部分的命令 ) 例如，一个用户代理可以只读取一个报文的报文首部，或只是一个多部分MIME报文的一部分。当用户代理和其邮件服务器之间使用低带宽连接 (如一个低速调制解调器链路)的时候，这个特性非常有用。使用这种低带宽连接时，用户可能并不想取回他邮箱中的所有邮件，尤<br>其要避免可能包含如音频或视频片断的大邮件 。</p>
<p><strong>POP3与IMAP</strong><br>之前使用的都是Download-and-delete方式，但是这种方式有一个问题，当换了一个客户端例如在公司用电脑收取邮件后回家用手机查看邮件时就看不到了，因为这些邮件在服务器上已经被删掉了。所以很多时候我们采用的是另一种模式叫Download-and-keep模式，这种模式的特点是下载邮件但是不删掉，当换一个客户端时还是可以阅读邮件。这时只要不使用delete命令就可以。<br>另外POP3的会话是无状态的即如果中间中断了就必须要重新操作。<br>POP3协议比较简单容易实现，但功能是有限的，所以后来人们开发了其它的邮件接收协议，这些协议可以支持更复杂的功能，其中最常见的就是IMAP，相比POP3而言IMAP有如下特征：<br>（1）保存所有邮件消息在一个位置：服务器，这时无论在哪个客户端操作，在其它客户端都可以看到操作的结果。<br>（2）允许用户在服务器的各文件夹中管理邮件消息<br>（3）IMAP可以维护用户会话的状态信息，最典型的例子就是它可以把文件夹和邮件消息的ID关联起来，即可以把邮件放到不同的文件夹里面，如同在本地操作文件系统的目录一样，这样就非常方便。<br>注意：在邮箱里面的各种文件夹其实是一个虚拟的，它和我们文件系统的文件夹是有区别的，但是不管怎么样它方便了用户的使用。</p>
<h4 id="3-基于Web的电子邮件"><a href="#3-基于Web的电子邮件" class="headerlink" title="3.基于Web的电子邮件"></a>3.基于Web的电子邮件</h4><p>在这种情况下，用户代理是普通的浏览器，用户和他远程邮箱之间的通信则通过HTTP进行。当一个收件人想从他的邮箱中访问一个报文时，该电子邮件报文从Bob的邮件服务器发送到他的浏览器。使用的是HTTP而不是POP3或IMAP协议。</p>
<p>当发件人(如 Alice) 要发送一封电子邮件报文时，该电子邮件报文从 Alice 的浏览器发送到她的邮件服务器，使用的是HTTP而不是SMTP, 然而，Alice-的邮件服务器在与其他的邮件服务器之间发送和接收邮件时，仍然使用的是 SMTP。</p>
<h2 id="2-4-DNS：因特网的目录服务"><a href="#2-4-DNS：因特网的目录服务" class="headerlink" title="2.4 DNS：因特网的目录服务"></a>2.4 DNS：因特网的目录服务</h2><p>主机名(hostname):<a href="http://www.facebook.com./">www.facebook.com。</a></p>
<p>主机也可以用IP地址标识。</p>
<h3 id="2-4-1-DNS提供的服务"><a href="#2-4-1-DNS提供的服务" class="headerlink" title="2.4.1 DNS提供的服务"></a>2.4.1 DNS提供的服务</h3><p>DNS(Domain Name System，域名系统)作用：<strong>在IP地址和主机名之间建立连接，通俗的说就是给互联网上的主机取名字。主机名到IP地址转换的目录服务。</strong></p>
<p>DNS即域名系统本质上是由各种各样的服务器来完成相关功能的，这些服务器成为DNS服务器，DNS服务器提供了四个重要的功能。<br>（1）主机名到IP地址的转换；<br>（2）DNS可以提供<strong>主机别名这样的服务</strong>，也就是说一个主机可以有一个规范主机名和多个主机别名，例如现实生活中给别人起外号一样。<br>（3）可以为邮件服务器取别名。<br>（4）可以提供负载分配的功能：即可实现冗余服务器，一个IP地址集合可以对应于用一个规范主机名。这在如今互联网飞速发展的情况下非常有用。例如很多大型网站域名是统一的，例如<a href="http://www.163.com，但是后台肯定是一个庞大的服务器集群为域名提供相关服务。这时怎么做负载分配呢？DNS这时可以起到很重要的作用。">www.163.com，但是后台肯定是一个庞大的服务器集群为域名提供相关服务。这时怎么做负载分配呢？DNS这时可以起到很重要的作用。</a></p>
<p>DNS的特点：</p>
<p>①一个由分层的DNS服务器实现的分布式数据库；</p>
<p>②一个使得主机能够查询分布式数据库的应用层协议。DNS服务器通常是运行在BIND软件上的UNIX及其。DNS协议运行在UDP之上，端口是53。DNS服务器实现域名转换（域名/地址转换）。也就是说在DNS里面涉及到了IP地址，这个是网络层的构成元素，但是DNS是在应用层实现转换的，所以DNS是一个应用层协议。</p>
<p><a href="https://zhuanlan.zhihu.com/p/57987304">10分钟理解TCP、UDP 和端口号 - 知乎 (zhihu.com)</a></p>
<p>DNS协议是应用层协议。</p>
<p>DNS 通常是由其他应用层协议所使用的，包括 HTTP、SMTP和 FTP，将用户提供的主机名解析为IP地址。 举一个例子，考虑运行在某用户主机上的一个浏览器 (即一个HTTP客户)请求URL <a href="http://www.someschooledu/index.html%E9%A1%B5%E9%9D%A2%E6%97%B6%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%E7%8E%B0%E8%B1%A1%E3%80%82%E4%B8%BA%E4%BA%86%E4%BD%BF%E7%94%A8%E6%88%B7%E7%9A%84%E4%B8%BB%E6%9C%BA%E8%83%BD%E5%A4%9F%E5%B0%86%E4%B8%80%E4%B8%AAHTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E5%8F%91%E9%80%81%E5%88%B0Web%E6%9C%8D%E5%8A%A1%E5%99%A8">www.someschooLedu/index.html页面时会发生什么现象。为了使用户的主机能够将一个HTTP请求报文发送到Web服务器</a> <a href="http://www.someschool.edu/">www.someschool.edu</a>, 该用户主机必须 获得www. someschool. edu的IP地址。其做法如下:</p>
<ol>
<li>同一台用户主机上运行着 DNS 应用的客户端 .</li>
</ol>
<ol start="2">
<li>浏览器从上述 URL 中抽取出主机名 www. someschool. edu、并将这台主机名传给DNS 应用的客户端 。</li>
<li>DNS 客户向 DNS 服务器发送 一 个包含主机名的请求 。</li>
<li>DNS 客户最终会收到一份回答报文，其中含有对应于该主机名的 IP地址。</li>
<li>一 旦浏览器接收到来自 DNS 的该 IP 地址，它能够向位千该 IP 地址 80 端口的HTTP服务器进程发起一个 TCP连接。</li>
</ol>
<p>从这个例子中，我们可以看到 DNS 给使用它的因特网 应用带来了额外的时延，有时还相当可观。幸运的是，如我们下面讨论的那样，想获得的 IP 地址通常就缓存在 一个“附近的”DNS 服务器中，这有助于减少 DNS 的网络流量和 DNS 的平均时延。</p>
<p>DNS的其他服务有：</p>
<ol>
<li><strong>主机别名(host aliasing)：</strong>有着复杂主机名的主机能拥有一个或者多个别名。规范主机名和主机别名。</li>
<li><strong>邮件服务器别名(mail server aliasing)：</strong>电子邮件程序通过调用DNS，对提供的主机名别名进行解析，以获得该主机的规范主机名及其IP地址。</li>
<li>**负载分配(load distribution):**DNS也用于在冗余的服务器之间进行负载分配。 繁忙的站点被冗余分布在多台服务器上，每台服务器均运行在不同的端系统上，每个有着不同的IP地址。一个IP地址集合与同一个规范主机名相联系。DNS数据库中存储着这些IP地址集合。当客户对映射到某地址集合的名字发出一个DNS请求时，该服务器用IP地址的整个集合进行响应。</li>
</ol>
<h3 id="2-4-2-DNS工作机理概述"><a href="#2-4-2-DNS工作机理概述" class="headerlink" title="2.4.2 DNS工作机理概述"></a>2.4.2 DNS工作机理概述</h3><p>概述：假设运行在用户主机上的某些应用程序(如Web浏览器或邮件阅读器)需要将主机名转换为 IP 地址这些。应用程序将调用DNS的客户端，并指明需要被转换的主机名 (在很多基于 UNIX 的机器上，应用程序为了执行这种转换需要调用函数 gethostbyname())。用户主机上的 DNS 接收到后，向网络中发送 一 个 DNS 查询报文。所有的 DNS 请求和 回答报文使用 UDP 数据报经端口 53 发送。经过若干毫秒到若干秒的时延后，用户主机上的DNS接收到一个提供所希望映射的 DNS 回答报文。这个映射结果则被传递到调用 DNS 的应用程序。因此，从用户主机上调用应用程序的角度看，DNS 是一个提供简单、直接的转换服务的黑盒子。但事实上，实现这个服务的黑盒子非常复杂，它由分布于全球的大量DNS服务器以及定义了DNS服务器与查询主机通信方式的应用层协议组成 。</p>
<p>DNS 的一种简单设计是在因特网上只使用一个DNS 服务器，该服务器包含所有的映射。在这种集中式设计中，客户直接将所有查询直接发往单一的 DNS 服务器，同时该DNS服务器直接对所有的查询客户做出响应。尽管这种设计的简单性非常具有吸引力，但它不适用于当今的因特网，因为因特网有着数量巨大(并持续增长)的主机。这种集中式设计的问题包括：</p>
<p>**单点故障(a single point of failure):**如果该DNS服务器崩溃，互联网瘫痪。</p>
<p>**通信容量(traffic volume):**单个DNS服务器处理所有DNS查询。</p>
<p>**远距离的集中式数据库(distant):**时延严重。</p>
<p>**维护(maintenance):**单个DNS服务器会频繁更新，集中式的DNS维护比较麻烦</p>
<p>扩展起来也不方便。</p>
<p><strong>1.分布式、层次数据库</strong></p>
<p>下图是分布式、层次数据库的架构：</p>
<p><img src="https://img-blog.csdnimg.cn/20210712215031502.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>DNS使用大量DNS服务器，分布在全世界范围内。没有一台DNS服务器拥有因特网上所有主机的映射。有3种类型的服务器：根DNS服务器、顶级域(TLD)DNS服务器和权威DNS服务器。</p>
<p>假定一个 DNS 客户要决定主机名 www. amazon. com 的 IP 地址 。 粗略说来，将发生下列事件。客户首先与根服务器之一联系，它将返回顶级域名 com 的 TLD 服务器的 IP 地址。该客户则与这些 TLD 服务器之一 联系，它将为 amazon. com 返回权威服务器的 IP 地址。 最后，该客户与amazon.com权威服务器之一联系，它为主机名<a href="http://www.amazon.com返回其/">www.amazon.com返回其</a> IP 地址。我们将很快更为详细地考察DNS查找过程。</p>
<p>在整个DNS系统里面我们是按照分层的方式来组织的。<br>最上面的一层叫做根域名服务器，root服务器下面有若干顶级服务器，这些服务器负责某一类域名的管理。顶级域服务器的下层是若干权威域DNS服务器。这些权威DNS服务器就负责某一个顶级域名的解析。例如google.com负责所有google.com域名的解析。在权威DNS服务器下面还可以设置更下层的域名解析服务器。例如google.com下面还有很多分公司，每个公司的都有自己的域名解析服务器。<br>下面举一个例子：<br>在这样一个分布、层次化的数据库里客户机如何确定主机名<a href="http://www.amazon.com的IP地址呢？">www.amazon.com的IP地址呢？</a><br>（1）客户机查询根服务器的得到com DNS服务器的IP地址；<br>（2）客户机查询com DNS服务器得到amazon.com DNS服务器的IP地址；<br>（3）客户机查询amazon.com DNS服务器得到<a href="http://www.amazon.com的ip地址./">www.amazon.com的IP地址。</a></p>
<p><strong>1.根DNS服务器：</strong>有400多个根名字服务器遍及全世界。这些根名字服务器由13个不同的组织管理。根名字服务器的 全部清单连同管理它们的组织及其 IP 地址可以在 [RootServers2016] 中找到。根名字服务器提供TLD服务器的IP地址。</p>
<p><strong>2.顶级域服务器：</strong></p>
<p>顶级域服务器构成体系：互联网的设计者把顶级域名分为两类：<br>（1）用途域名：com、org、net、edu、gov等。<br>（2）国家顶级域名：uk、fr、ip、cn等</p>
<p>TLD服务器体哦提供了权威DNS服务器的IP地址。</p>
<p><strong>3.权威DNS服务器：</strong></p>
<p>权威DNS域名服务器是真正的负责某一具体域名的解析工作。<br>在因特网上具有公共可访问主机（例如Web服务器和邮件服务器）的每个组织机构必须提供公共可访问的DNS记录，这些记录将这些主机的名字映射为IP地址。组织机构的权威DNS服务器负责保存这些DNS记录。<br>多数大学和公司维护它们基本权威DNS服务器。</p>
<p><strong>4.本地DNS服务器(local DNS server)</strong></p>
<p>每个ISP都有一台本地DNS服务器。当主机与某个ISP连接时，该ISP提供一台主机的IP地址，该主机具有一台或多台其本地DNS服务器的IP地址。</p>
<h5 id="1-DNS查询方法"><a href="#1-DNS查询方法" class="headerlink" title="1.DNS查询方法"></a>1.DNS查询方法</h5><p>1、<a href="https://so.csdn.net/so/search?q=%E9%80%92%E5%BD%92%E6%9F%A5%E8%AF%A2&spm=1001.2101.3001.7020">递归查询</a></p>
<p>递归查询核心：<a href="https://so.csdn.net/so/search?q=%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90&spm=1001.2101.3001.7020">域名解析</a>的负担交给被查询的域名服务器。</p>
<p>下图为递归查询的流程：</p>
<img src="https://img-blog.csdnimg.cn/20210713101428834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />



<p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220607163941673.png" alt="image-20220607163941673"></p>
<p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220607163947253.png" alt="image-20220607163947253"></p>
<p>首先cis.poly.edu这台主机想去查询gaia.cs.umass.edu这台主机的域名所对应的IP地址，<br>（1）客户机会将查询请求发送给本地DNS服务器，这个地方用dns.poly.edu来代表，<br>（2）本地域名服务器会去问根域名服务器谁在管理gaia.cs.umass.edu这个域名，<br>（3）根域名服务器说我不知道谁在管，但是我知道谁在管.edu，我可以帮你去问它，这时根域名服务器去联系管理.edu这个顶级域名的顶级域名服务器<br>（4）管理.edu的顶级域服务器说我不知道gaia.cs.umass.edu这个域名的IP地址，但是我知道谁在管cs.umass.edu，我帮你去问它，于是它联系管理cs.umass.edu的服务器也就是权威域名服务器dns.cs.umass.edu.<br>（5）dns.cs.umass.edu得到信息后说你找对人了，我知道gaia.cs.umass.edu的IP地址是多少，然后它把信息返回给管理.edu的顶级域服务器<br>（6）管理.edu的顶级域名服务器将信息返回给根服务器<br>（7）根服务器又把结果返回给dns.poly.edu本地DNS服务器<br>（8）最后本地DNS服务器将结果返回给客户机<br>这样就完成了一次DNS的查询。<br>在查询过程中每一次的查询都是在被询问者的帮助下完成。</p>
<p><strong>2.迭代查询</strong></p>
<p>递归有一个问题：被查询者被查询的域名服务器它的负载会不会很重？尤其是对于根域名服务器而言，大家都去问它，它要帮助大家，会造成比较重的负担。这时就出现的迭代查询。<br>迭代查询原理：我不知道这个信息。但是其他人知道，你去问其他人就可以了。被询问者不会帮助你去查询，而是告诉你你可以另外去找谁。</p>
<img src="https://img-blog.csdnimg.cn/20210713102233828.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

<p>（1）客户机去问本地的DNS服务器<br>（2）本地的DNS 服务器去问根服务器<br>（3）根服务器会告诉本地域名服务器我不知道gaia.cs.umass.edu的IP地址是多少，但是我知道谁在管.edu，你去问它<br>（4）本地服务器根据根服务器的指引去访问管理.edu的顶级域名服务器<br>（5）顶级域名服务器告诉本地服务器说我并不知道你要查询的IP地址，但是我知道谁在管cs.umass.edu.<br>（6）本地DNS服务器根据顶级域名服务器提供的信息去找到dns.cs.umass.edu，对它进行查询<br>（7）将要查询的信息返回给DNS服务器<br>（8）本地DNS服务器再将结果传回给主机</p>
<p>递归查询中，所有查询都是递归的；迭代查询中，请求主机到本地DNS服务器是递归的，其他是迭代的。</p>
<h5 id="2-DNS缓存"><a href="#2-DNS缓存" class="headerlink" title="2.DNS缓存"></a>2.DNS缓存</h5><p>DNS 缓存，即DNS caching。</p>
<p>每次访问一个域名都要像刚才那样走一圈查询它的IP地址的话会导致互联网上的流量太大，同时速度也很慢，本地DNS服务器其实是可以把顶级域名服务器的IP地址（是很多权威域名服务器的查询信息）给缓存下来的，映射到本地存储器中。下一次当有人再去访问同样信息的时候就不用再去做刚才的查询而直接将缓存结果返回即可。</p>
<p>当然缓存信息需有一个有效的时间，这个时间称为TTL，服务器在一定时间（TTL）后将丢弃缓存信息。</p>
<p>这会导致一个问题就是缓存的条目可能会过期即可能本地DNS服务器查询的结果并不是最新。因为如果改条目对应的主机的IP改变了，只有当TTL到期时，本地DNS服务器的条目才会得到更新。</p>
<h3 id="2-4-3-DNS记录和报文"><a href="#2-4-3-DNS记录和报文" class="headerlink" title="2.4.3 DNS记录和报文"></a>2.4.3 DNS记录和报文</h3><p>资源记录(Resource Record)：共同实现DNS分布式数据库的所有DNS服务器。</p>
<p>RR提供了主机名到IP地址的映射。每个DNS回答报文包含了一条或多条资源记录。</p>
<p>资源记录是一个包含了下列字段的4元组：<code>（name，value，type，TTL）</code>。</p>
<p>TTL是该记录的生存时间：决定了从资源记录到应当从缓存中删除的时间。Name和Value的值取决于Type。</p>
<img src="计算机网络.assets/image-20220607165259006.png" alt="image-20220607165259006" style="zoom:50%;" />

<p><strong>type有四类：</strong><br>（1）Type=A<br>这时name=主机名；value=IP地址。<br>（2）Type=CNAME<br>这时name=主机别名；value=真实的规范主机名<br>例如：<a href="http://www.ibm.com的真名为servereast.backup2.ibm.com./">www.ibm.com的真名为servereast.backup2.ibm.com。</a><br>（3）Type=NS<br>这时name=域名（如foo.com）；value=该域权威名字服务器的主机名。<br>（4）Type=MX<br>这时name=邮件服务器的主机别名；value=邮件服务器的真实规范主机名。</p>
<p>如果一台DNS服务器用于某特定主机名的权威DNS服务器，那么该DNS服务器会有一条包含用于该主机名的类型A记录。</p>
<p>如果一台DNS服务器不是用于某特定主机名的权威DNS服务器，那么该DNS服务器会有一条类型NS记录，该记录对应于包含主机名的域；它还将包括一条类型A记录，记录提供了在NS记录的Value字段中的DNS服务器的IP地址。</p>
<h5 id="1-DNS报文"><a href="#1-DNS报文" class="headerlink" title="1.DNS报文"></a>1.DNS报文</h5><p>DNS有查询和回答报文，并且查询和回答报文有相同的格式。</p>
<p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220607173512065.png" alt="image-20220607173512065"></p>
<ul>
<li>首部区域：报文头部。</li>
</ul>
<p>第一个字段(标识符)：16比特，查询和应答报文使用相同的标识符，用于标识该查询。这个标识符会被复制到对查询的回答报文中，以便让客户用它来匹配发送的请求和接收到的回答。</p>
<p>标志：若干标志。1比特的”查询/回答“标志位指出报文是查询报文(0)还是回答报文(1)。</p>
<p>查询希望是/非递归查询-1/0<br>应答可/否获得（支持）递归查询-1/0<br>应答是/否来自权威名字服务器-1/0</p>
<ul>
<li>问题区域：包含着正在进行的查询信息。</li>
</ul>
<p>包括名字字段(正在被查询的主机名字)；类型字段，指出有关该名字的正被询问的问题类型，例如主机地址是与一个名字相关联(类型A)还是与某个名字的邮件服务器相关联(类型MX)。</p>
<ul>
<li><p>回答区域：对于查询、应答的资源记录可以有多个资源记录，因为可以有多个IP地址。</p>
</li>
<li><p>权威区域：域对应的权威名字服务器的信息。</p>
</li>
<li><p>附加区域：权威名字服务器的IP地址等其它有帮助的记录。</p>
</li>
</ul>
<p><code>nslookup</code>：向某些DNS服务器发送一个DNS查询报文</p>
<h5 id="2-在DNS数据库中插入记录"><a href="#2-在DNS数据库中插入记录" class="headerlink" title="2.在DNS数据库中插入记录"></a>2.在DNS数据库中插入记录</h5><p>例如：刚刚创建一个”网络乌托邦“公司<br>（1）如果你想在注册登记机构注册你的域名networkutopia.com，则：<br>1）需要提供你自己的基本权威DNS服务器和辅助权威DNS服务器的名字和IP地址<br>2）该**注册登记机构<a href="%E6%98%AF%E4%B8%80%E4%B8%AA%E5%95%86%E4%B8%9A%E5%AE%9E%E4%BD%93">^注</a>**将下列两条资源记录插入注册机构的DNS系统中：<br>（networkutopia.com,dns1.networkutopia.com,NS）<br>（dns1.networkutopia.com，212.212.212.1，A）</p>
<p>（2）如果你想建立一个网站，则可以将网址<a href="http://www.networkutopia.com以类型a的方式记录到你的权威dns服务器dns1.networkutopia.com中./">www.networkutopia.com以类型A的方式记录到你的权威DNS服务器dns1.networkutopia.com中。</a><br>（3）如果你想建一个邮件服务器，则可以将mail.networkutopia.com以类型MX的方式记录到你的权威DNS服务器dns1.networkutopia.com中。<br>自此你就把你的域名体系连入了internet。</p>
<p>一个人要访问一个网站，主机首先向其本地的DNS服务器发送请求。该本地服务器接着则联系一个TLD com服务器。该TLD服务器包含前面列出的类型NS和类型A资源记录，因为注册登记机构将这些资源记录插入所有的TLD com的服务器。该TLD com服务器向Alice的本地DNS服务器发送一个回答，该回答包含了这两条资源记录。 该本地DNS 服务器则向212.212.212.1 发送一个 DNS查询，请求对应于 <a href="http://www.networkutopia.com的类型a记录.该记录提供了所希望的/">www.networkutopia.com的类型A记录。该记录提供了所希望的</a> Web 服务器的 IP 地址，如 212. 212. 71. 4, 本地 DNS 服务器将该地址回传给 Alice 的主机 。Alice的浏览器此时能够向主机 212. 212. 71. 4 发起一个 TCP 连接，并在该连接上发送一个HTTP请求。</p>
<p><strong>DNS安全问题</strong></p>
<p>（1）基于主机耗尽型的DNS查询拒绝服务（DDos）攻击：对根域名服务器或顶级域名服务器发起拒绝服务攻击。<br>（2）基于宽带耗尽型的DNS反弹式拒绝服务攻击：伪造客户地址向大量的DNS服务器发出请求，导致客户被回复淹没。<br>（3）重定向攻击：中间人攻击、DNS中毒攻击（发送欺骗的域名解析结果给DNS服务器）<br>影响个人用户的DNS安全威胁有：<br>（1）本机Host文件被篡改<br>（2）DNS胁持<br>（3）DNS污染</p>
<h2 id="2-5-P2P文件分发"><a href="#2-5-P2P文件分发" class="headerlink" title="2.5 P2P文件分发"></a>2.5 P2P文件分发</h2><p>P2P：间歇连接的对等方彼此直接通信。</p>
<p>比较流行的P2P文件分发协议：BitTorrent</p>
<h3 id="1-P2P体系结构的拓展性"><a href="#1-P2P体系结构的拓展性" class="headerlink" title="1.P2P体系结构的拓展性"></a>1.P2P体系结构的拓展性</h3><img src="计算机网络.assets/image-20220607190223736.png" alt="image-20220607190223736" style="zoom:50%;" />

<p>比较分发时间，P2P是越来越缓。</p>
<h4 id="集中式目录结构："><a href="#集中式目录结构：" class="headerlink" title="集中式目录结构："></a>集中式目录结构：</h4><p>在这种模式中有个中央目录服务器为P2P提供目录服务。这种集中式目录架构最早来自于”Napster“公司的设计。<br>在集中式目录架构中：<br>（1）当对等方启动时，它通知目录服务器以下信息：<br>1）IP地址<br>2）可供共享的对象名称<br>（2）当一个用户要在集中式的目录里面找寻某个资源时会去访问目录服务器。例如Alice查询文件”Hey Jude“<br>（3）服务器会告诉它哪些用户在线，然后这些用户上面有哪些资源，进一步的再去联系这些用户。然后从这些用户处下载相关资源。例如Alice向Bob请求文件。<br>如下图所示：</p>
<img src="https://img-blog.csdnimg.cn/20210713163434541.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

<p>相对于纯P2P而言，集中式目录有一些问题，因为文件传输是分散的，但是定位内容的过程是高度集中的因此可能会导致：<br>（1）单点故障<br>（2）性能瓶颈<br>（3）侵犯版权</p>
<h3 id="2-BitTorrent"><a href="#2-BitTorrent" class="headerlink" title="2.BitTorrent"></a>2.BitTorrent</h3><p>BitTorrent是一种用于文件分发的流行P2P协议。</p>
<p>洪流：参与一个特定文件分发的的所有对等方的集合。</p>
<p>文件块：当一个洪流中的对等方彼此下载等长度的文件块，典型块的长度为256KB。</p>
<p>可以使用最稀缺优先技术，得到更为迅速的分发。</p>
<p>P2P技术中使用最广泛的还有文件分发，文件分发最基础的技术来自于BitTorrent。<br>BitTorrent是一种用于文件分发的流行P2P协议。<br>参与一个特定文件分发的所有对等方的集合被称为一个洪流即torrent。<br>一个洪流中的对等方彼此下载等长度的文件快（chunk），典型块长度为256KB。</p>
<p><strong>1、追踪器tracker</strong><br>在BitTorrent里有个服务器我们称之为追踪器tracker，它可以跟踪参与洪流的所有对等方。<br>从这个角度来说Bit有一个目录服务器，它负责管理在某一次下载里面各客户端的情况。大家如果使用过Bit下载软件，看到过这些软件的工作日志就会发现这些软件在下载某个文件时一开始会根据Bit种子里边的信息去连接某些tracker服务器，然后去找寻洪流的信息，之后接入这些洪流。<br>例如Alice要加入某个洪流的下载，她要从追踪器获得对等方列表，获得列表以后就会知道可以和谁去交换文件信息、交换资源了。</p>
<p><strong>2、设计原则</strong><br>在Bit里有如下设计原则：<br>（1）请求文件快<br>1）要保证在任何给定的时刻，不同的对等方拥有不同的文件块子集。<br>2） 每个对等方会周期性的询问其它每个连接的对等方当前所拥有的文件块列表。<br>3）对等方将请求下载最稀缺的文件快。<br>（2）发送文件块<br>1）Alice发送文件块的对象是所有邻居中向自己发送速率最快的4个。 其它邻居被阻塞，但是每10秒会重新计算速率。<br>为了防止”穷者越穷、富者越富“的状况每30秒会随机选择一个其它邻居，发送文件块。</p>
<p><strong>DHT（分布式Hash表）</strong></p>
<p>再介绍一下在P2P技术中被广泛使用的DHT技术。<br>DHT可以看成一个分布式的P2P数据库。这个数据库由许多（key，value）键值对构成。<br>所有（key，value）对被分发到成千上万的对等方用户群中，对等方利用key来查询DHT，DHT返回与之匹配的value。此外对等方还可以插入（key，value）对。</p>
<blockquote>
<p><strong>1、键值分配</strong></p>
</blockquote>
<p>在DHT中核心问题为如何分配键值对给各对等方呢？基本思想为：<br>（1）把每个key转化成一个整数。<br>（2）给每个对等方分配一个整数标识符。<br>（3）把键值对分配给标识符离key最近的那个对等方。<br>具体做法为：<br>（1）给每个对等方分配一个[0,2 n − 1 2^n-12<br>n<br> −1]之间的整数标识符，n为某给定值。<br>（2）每个标识符由n比特构成。<br>（3）需要每个key也在同样的范围内。<br>（4）为得到整数key，将原key做hash<br>将一个key映射到相同范围内时使用到了数据结构中的hash技术。把key做hash运算，将它映射到与标识符相同的一个范围内。这就是为什么叫做分布式hash表的原因，因为在里面使用了hash技术。<br>将key数据化后就可以将key分配给具有最近邻ID的对等方。最邻近被定义为该key的直接后继。<br>例如n=4即给对等方分配[0,15]的整数标识符，peers:1、3、4、5、8、10、12、14。<br>当key=13时直接后继为14；<br>当key=15时直接后继为1，因为是按照环的形式。<br>环形如下：</p>
<img src="https://img-blog.csdnimg.cn/20210713193645192.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

<p>每个对等方仅和其直接后继和直接前任联系。</p>
<img src="https://img-blog.csdnimg.cn/2021071319410425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

<p>例如1110被存放在最邻近的直接后继里面，最邻近的直接后继就是1111，0011查找哪个负责1110只能询问0100，依次往后，找到1111后，1111给0011返回信息说我负责1110。这就是环形DHT里键值对查找过程。</p>
<p>由上图我们看到环形DHT比较非时间，下面来介绍带捷径的环形DHT：</p>
<p>带捷径的环形DHT除了包括直接前任、后继之外还包括捷径方的IP。<br>如下图：<br><img src="https://img-blog.csdnimg.cn/20210713194500646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>3有一个捷径方8，可以直接将消息发给8，8也可以直接将消息发给15，与环形DHT相比，消息数从6减至2.</p>
<h2 id="2-6-视频流和分发内容网"><a href="#2-6-视频流和分发内容网" class="headerlink" title="2.6 视频流和分发内容网"></a>2.6 视频流和分发内容网</h2><h3 id="2-6-1-因特网视频"><a href="#2-6-1-因特网视频" class="headerlink" title="2.6.1 因特网视频"></a>2.6.1 因特网视频</h3><p>这些视频是预先存储在服务器上。</p>
<p>4K超过10Mbps。</p>
<ol>
<li><p><a href="https://zhuanlan.zhihu.com/p/183956523">什么是4K - 知乎 (zhihu.com)</a></p>
</li>
<li><p><a href="https://new.qq.com/omn/20210513/20210513A03JJK00.html">详解分辨率1080P、2K、4K、8K的含义和区别！_腾讯新闻 (qq.com)</a></p>
</li>
</ol>
<h3 id="2-6-2-HTTP流和DASH"><a href="#2-6-2-HTTP流和DASH" class="headerlink" title="2.6.2 HTTP流和DASH"></a>2.6.2 HTTP流和DASH</h3><p>在HTTP流中，视频存储在HTTP服务器中作为一个普通的文件，每个文件有一个特定的URL。当用户要看该视频时，客户与服务器创建一个TCP连接并发送对该URL的 HTTP GET 请求。服务器则以底层网络协议和流量条件允许的尽可能快的速率 ，在一个HTTP响应报文中发送该视频文件。 在客户一侧，字节被收集在客户应用缓存中，一旦该缓存中的字节数量超过预先设定的门限，客户应用程序就开始播放，特别是，流式视频应用程序周期性地从客户应用程序缓存中抓取帧，对这些帧解压缩并且在用户屏幕上展现 ，因此，流式视频应用接收到视频就进行播放，同时缓存该视频后面部分的帧 。</p>
<p>尽管HTTP流在实践中已经得到了广泛的部署。但缺陷是所有客户接收到相同编码的视频，不同客户带宽不同。</p>
<p>所以导致了一种新的HTTP流的研发，即DASH(经HTTP的动态适应性流)。在DASH中，视频编码为几个不同的版本，其中每个版本具有不同的比特率，对应于不同的质量水平。客户动态地请求来自不同版本且长度为几秒 的视频段数据块。当可用带宽量较高时，客户自然地选择来自高速率版本的块;当可用带宽量较低时，客户自然地选择来自低速 率版本的块。客户用 HTTP GET请求报文一次选择一个不同的块 [Akhshahi 2011]。</p>
<p>DASH允许客户使用不同的以太网接入速率流式播放具有不同编码速率的视频。每个视频存储在HTTP服务器中，每个版本都有一个不同的URL。HTTP服务器也有一个告示文件。DASH允许在客户自由地在不同的质量等级之间切换。</p>
<h3 id="2-6-3-内容分发网"><a href="#2-6-3-内容分发网" class="headerlink" title="2.6.3 内容分发网"></a>2.6.3 内容分发网</h3><p>单一的数据中心会导致：</p>
<ul>
<li>停滞时延</li>
<li>浪费网络带宽，增加支付费用</li>
<li>代表一个单点故障</li>
</ul>
<p>应对措施：<strong>CDN内容分发网</strong>：CDN管理分布在多个地理位置上的服务器，在其中存储视频副本。</p>
<p>CDN通常采用两种不同的服务器安置原则：</p>
<ul>
<li>深入：第一个原则由Akamai首创，该原则是通过在遍及全球的接入ISP中部署服务器集群来深入到ISP的接入网中。Akamai在大约1700个位置采用这种方法部署集群。目标是靠近端用户，改善时延和吞吐量。</li>
<li>邀请做客：通过少量关键位置建造大集群邀请ISP做客，维护和管理较低，时延和吞吐量代价大。</li>
</ul>
<p>一旦CDN的集群准备就绪，它就可以跨集群复制内容。</p>
<p><strong>1.CDN操作</strong></p>
<p>大多数CDN利用DNS来截获和重定向请求。</p>
<img src="计算机网络.assets/image-20220608162107067.png" alt="image-20220608162107067" style="zoom:50%;" />

<img src="计算机网络.assets/image-20220608162112784.png" alt="image-20220608162112784" style="zoom:50%;" />

<h3 id="2-6-4-学习案例：Netflix、YouTube和“看看”"><a href="#2-6-4-学习案例：Netflix、YouTube和“看看”" class="headerlink" title="2.6.4 学习案例：Netflix、YouTube和“看看”"></a>2.6.4 学习案例：Netflix、YouTube和“看看”</h3><h4 id="1-Netflix"><a href="#1-Netflix" class="headerlink" title="1.Netflix"></a>1.Netflix</h4><p>分发视频：亚马逊云和自己专用的CDN基础设施。</p>
<p>Netflix的功能的Web网站完全运行在亚马逊服务器上。</p>
<p>亚马逊云：</p>
<ul>
<li><strong>内容摄取：</strong>在Netflix能够向它的用户分发某电影之前，它必须首先获取和处理该电影。Netflix接收制片厂电影的母带，并且将其上载到亚马逊云的主机上。</li>
<li><strong>内容处理：</strong>亚马逊云中的机器为每部电影生成许多不同格式，以适合在桌面计算机、智能手机和电视机相连的游戏机上运行不同类型的客户视频播放器。</li>
<li><strong>向其CDN上载版本</strong>:向亚马逊主机云上载这些版本。</li>
</ul>
<p>Netflix雇佣了三个第三方CDN公司来分发它视频内容。通过这些CDN分发它的视频内容。自那时起，Netflix创建了自己专用的CDN，现在它从这些专用CDN发送它的视频。</p>
<h4 id="2-YouTube"><a href="#2-YouTube" class="headerlink" title="2.YouTube"></a>2.YouTube</h4><p>谷歌和YouTube协议是专用的。利用CDN技术来分发它的视频。在不同的IXP和ISP位置安装服务器集群和巨大的数据中心。谷歌的集群策略将客户定向到某个集群。</p>
<h4 id="3-看看"><a href="#3-看看" class="headerlink" title="3.看看"></a>3.看看</h4><p>P2P模式。</p>
<h2 id="2-7-套接字编程：生成网络应用"><a href="#2-7-套接字编程：生成网络应用" class="headerlink" title="2.7 套接字编程：生成网络应用"></a>2.7 套接字编程：生成网络应用</h2><p>典型的网络应用由一对程序构成：客户程序和服务器程序。</p>
<p>客户进程和服务器进程通过套接字读出和写入数据在彼此之间通信。</p>
<p>网络应用程序包含协议标准和专用的网络应用程序。</p>
<p>如果要在应用层调用传输层的服务，进行相关程序的设计，就要涉及到套接字编程。套接字也称之为Socket，本质上它就是利用传输层提供的一系列Api来进行网络应用程序的设计。</p>
<p>网络应用程序如果要进行套接字编程，需要明确的创建、使用及释放套接字。</p>
<p>套接字编程是典型的C/S模式。</p>
<p>从下图中可以形象的看到套接字的作用：<br><img src="https://img-blog.csdnimg.cn/20210714092804173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>（1）套接字是一个主机本地应用程序所创建的，为操作系统所控制的接口。<br>（2）应用程序通过这个接口，使用传输层提供的服务，跨网络发送/接收消息到/从其它应用进程。</p>
<h3 id="2-7-1-UDP套接字编程"><a href="#2-7-1-UDP套接字编程" class="headerlink" title="2.7.1 UDP套接字编程"></a>2.7.1 UDP套接字编程</h3><p>将目的地址附在该分组身上。</p>
<p>（1）当用UDP进行套接字编程时没有初始握手手段；<br>（2）发送方明确将接收方的IP地址和端口号加入到每个分组。<br>（3）服务器必须从接收到的分组中析取发送方进程的IP地址、端口号。<br>这种方式在发送数据时可能被乱序收到或丢失。<br>从应用程序的角度来看UDP在客户和服务器之间提供一组字节的不可靠传输。</p>
<p>在发送进程能够将数据分组推出套接字之门之前、当使用 UDP 时，必须先将目的地址附在该分组之上。在该分组传过发送方的 套接字之后，因特网将使用该目的地址通过因特网为该分组选路到接 收进程的套接字。当分组到达接收套接字时，接收进程将通过该套接字取回分组，然后检查分组内容并采取适当动作。</p>
<p>端口号：标识符。</p>
<p>目的主机ip地址就是目的地址的一部分。因为主机的IP地址是目的地一部分，通过在分组中包括目的地的IP地址，因特网中的路由器将能够通过因特网分组选路到目的主机。一台主机可能运行许多网络应用进程，每个进程具有一个或多个套接字。<strong>当生成一个套接字时，就为它分配一个称为端口号的标识符。</strong>分组的目的地址也包括该套接字的端口号。</p>
<p>目的地址由目的主机IP地址和目的地套接字端口号组成。</p>
<p><strong>交互流程：</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20210714102410172.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>（1）服务器对入栈请求创建套接字，端口是x。<br>（2）客户机如果要给服务器端发送数据，它也创建一个套接字，这个套接字使用服务器的ip地址和服务器的端口，直接使用这个套接字发送数据包请求。<br>（3）服务器从服务器套接字中读请求。<br>（4）服务器收到请求后将应答写到服务器套接字上面，在写应答上面有客户机主机地址和端口号。<br>（5）客户机从套接字上面读取应答。<br>（6）这个过程一直进行，客户机如果收发完毕就退出，而服务器又回到前一步继续等待下一个客户机套接字请求的到来。</p>
<h3 id="2-7-2-TCP套接字编程"><a href="#2-7-2-TCP套接字编程" class="headerlink" title="2.7.2 TCP套接字编程"></a>2.7.2 TCP套接字编程</h3><p>套接字编程有面向连接和无连接两种实际上就是TCP套接字编程和UDP套接字编程。<br>可以使用源端口号来区别客户。<br>使用TCP进行套接字编程时客户必须初始联系服务器，这时服务器进程必须先运行，创建套接字来迎候客户的初始联系。<br>那么客户如何初始联系服务器呢？主要有3个步骤：<br>（1）创建客户本地TCP套接字。<br>（2）指定服务器进程的IP地址和端口号。<br>（3）一旦客户创建套接字，客户TCP就发起3次握手并建立与服务器TCP连接。<br>一旦客户初始联系服务器，服务器TCP为服务器进程创建1个新的套接字与客户通信。这里允许服务器与多个客户通信，而端口号被用来区分客户。<br>从应用程序的角度来看，TCP为客户和服务器提供了可靠的、顺序</p>
<p><strong>TCP客户/服务器套接字交互流程</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20210714101520897.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>（1）服务器创建一个在端口x上的套接字，然后等待连入请求<br>（2）在服务器等待连入请求的过程中客户机如果要连接服务器它会创建一个到服务器的IP地址然后和服务器的端口号x相连接的套接字。<br>（3）使用这个套接字和服务器进行TCP连接建立<br>（4）连接建立好以后客户机使用套接字向服务器端发送相关请求。<br>（5）服务器端读到请求以后使用写应答的方式把数据发送给客户机。<br>（6）客户机读取应答，当所有的读写操作都进行完成以后，客户机关闭套接字。<br>（7）服务器也关闭套接字<br>注意：服务器这时关闭的是客户机刚才建立的TCP连接上所对应的套接字，但是监听套接字还在，因为监听套接字要等待下一次的到来。</p>
<h1 id="第三章-运输层"><a href="#第三章-运输层" class="headerlink" title="第三章 运输层"></a>第三章 运输层</h1><h2 id="3-1-概述和运输层服务"><a href="#3-1-概述和运输层服务" class="headerlink" title="3.1 概述和运输层服务"></a>3.1 概述和运输层服务</h2><p><strong>逻辑通信：</strong>运输层协议为运行在不同主机的应用进程之间提供了逻辑通信。应用进程通过运输层提供的逻辑通信功能彼此发送报文。</p>
<p>运输层协议在端系统中而不是在路由器实现。</p>
<p>运输层协议是在端系统中而不是在路由器中实现的。在发送端，运输 层将从发送应用程序进程接收到的报文转换成运输层分组，用因特网术语来讲该分组称为运输层报文段 (segment) 。 实现的方法(可能)是将应用报文划分为较小的块，并为每块加上一个运输层首部以生成运输 层 报文段 。 然后，在发送端系统中，运输层将这些报文段传递给网络层，网路层将其封装成网络层分组(即数据报)并向目的地发送 。 注意到下列事实是重要的：网络路由器仅作用千该数据报的网络层字段；即它们不检查封装在该数据报的运输层报文段的字段。在接收端，网络层从数据报中提取运输层报文段，并将该报文 段向上交给运输层 。运输层则处理接收到的报文段，使该报文段中的数据为接收应用进程使用。</p>
<p>传输层主要为在两个不同的主机上运行的应用程序之间提供<strong>逻辑</strong>通信。</p>
<p>传输层协议运行在端系统。</p>
<p>（1）发送方：将应用程序报文分成数据段传递给网络层。<br>（2）接收方：将数据段重新组装成报文传递到应用层。<br>注：不只有一个传输层协议可以用于应用程序。例如TCP和UDP。</p>
<h3 id="3-1-1-运输层和网络层的关系"><a href="#3-1-1-运输层和网络层的关系" class="headerlink" title="3.1.1 运输层和网络层的关系"></a>3.1.1 运输层和网络层的关系</h3><p>运输层为运行在不同主机上的进程之间提供了逻辑通信。</p>
<p>例子：应用层报文=信封上的字符；进程=堂兄弟姐妹；主机(端系统)=家庭；运输层协议=Ann和Bill；网络层协议=邮政服务；</p>
<p>运输协议提供的服务受制于底层网络协议的服务模型。如果网络层协议无法为主机之间发送的运输层报文段提供时延或贷款保证。</p>
<p>运输协议也能为应用程序提供可靠的数据传输服务。</p>
<h3 id="3-1-2-因特网运输层概述"><a href="#3-1-2-因特网运输层概述" class="headerlink" title="3.1.2 因特网运输层概述"></a>3.1.2 因特网运输层概述</h3><p>UDP：用户数据报协议</p>
<p>TCP：传输控制协议</p>
<p>运输层协议称为<strong>报文段</strong>。网络层分组：数据报。</p>
<p>网络层的协议：IP，网际协议。IP为主机之间提供逻辑通信，交换报文段。IP是不可靠服务。每台主机有一个IP地址。</p>
<p>两个端系统间的IP交付服务拓展到运行在端系统上的两个进程之间的交付服务。<strong>将主机之间交付拓展到进程间交付被称为运输层的多路复用与多路分解</strong></p>
<p>TCP提供可靠数据传输，通过使用流量控制、序号、确认和定时器，TCP确保正确地、按序地将数据从发送进程交付给接收进程。TCP还提供拥塞控制。</p>
<h2 id="3-2-多路复用与多路分解"><a href="#3-2-多路复用与多路分解" class="headerlink" title="3.2 多路复用与多路分解"></a>3.2 多路复用与多路分解</h2><p>概念：由网络层提供的主机到主机交付服务延申到为运行在主机上的应用程序提供进程到进程的交付服务。</p>
<p>那么到底是如何进行多路复用与多路分解的呢？<br>在接收主机多路分解：将接收到的数据段传递到正确的<a href="https://so.csdn.net/so/search?q=%E5%A5%97%E6%8E%A5%E5%AD%97&spm=1001.2101.3001.7020">套接字</a>。<br>在发送主机多路复用：从多个套接字收集数据，用首部封装数据，然后将报文段传递到<a href="https://so.csdn.net/so/search?q=%E7%BD%91%E7%BB%9C%E5%B1%82&spm=1001.2101.3001.7020">网络层</a>。<br>过程如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210714142523376.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>一个进程有多个套接字。</p>
<p>多路分解：将运输层报文段中的数据交付到正确的套接字的工作称为多路分解。</p>
<p>多路复用：在源主机从不同的套接字中收集数据块，并为每个数据块封装上首部信息从而生成报文段，然后将报文段传递到网络层，这些工作称为多路复用。</p>
<p>运输层多路复用要求：</p>
<p>①套接字有唯一标识符；</p>
<p>②每个报文段有特殊字段来指示该报文段所要交付到的套接字。</p>
<img src="计算机网络.assets/image-20220610134310892.png" alt="image-20220610134310892" style="zoom: 33%;" />

<p>这些特殊字段是<strong>源端口号字段和目的端口号字段</strong>。端口号是一个16比特的数，其大小在0<del>65535之间。 0</del>1023范围的端口号称为周知端口号，受限制，保留给相关应用层协议使用。</p>
<p>在主机上的每个套接字能够分配一个端口号，当报文段到达主机时，运输层检查报文段中的目的端口号，并将其定向到相应的套接字。然后报文段中的数据通过套接字进入其所连接的进程。如我们将看到的那 样，UDP大体上是这样做的。然而，也将如我们所见， TCP 中的多路复用与多路分解更为复杂。</p>
<p><strong>1.无连接的多路复用与多路分解</strong></p>
<p>分解的过程中有无连接的多路分解。<br>（1）用端口号创建套接字：<br>DatagramSocket ServerSocket1=new DatagramSocket (9911);<br>DatagramSocket ServerSocket2=new DatagramSocket (9922)<br>UDP套接字由目的IP地址和目的端口号指定<br>（2）当主机收到UDP数据段时检查数据段中的目的端口号，用端口号指示UDP数据段属于哪个套接字。<br>（3）具有不同的源IP地址且/或源端口号，但具有相同目的的IP地址和目的端口号的IP数据报指向同样的套接字。<br>详细过程如图所示：<br><img src="https://img-blog.csdnimg.cn/20210714144853925.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>一个UDP套接字由一个二元组标识。该二元组包含一个目的IP地址和一个目的端口号。</p>
<p><strong>2.面向连接的多路复用和多路分解</strong></p>
<p>面向连接的多路分解中TCP套接字由4部分指定，分别为<strong>源IP地址</strong>、<strong>源端口号</strong>、<strong>目的IP地址</strong>和<strong>目的端口号</strong>。<br>接收主机使用所有的4个值将数据段定位到合适的套接字。<br>服务器主机支持很多同时使用的TCP套接字，每个套接字都用4部分来表示。Web服务器对每个连接的客户都有不同的套接字；非持久HTTP将对每个请求有一个不同的套接字。<br>面向连接多路分解过程图如下：<br><img src="https://img-blog.csdnimg.cn/20210714145612876.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /></p>
<p><strong>3.Web服务器与TCP</strong></p>
<p>报文段目的端口号跟服务器的端口有关。</p>
<h2 id="3-3-无连接运输：UDP"><a href="#3-3-无连接运输：UDP" class="headerlink" title="3.3 无连接运输：UDP"></a>3.3 无连接运输：UDP</h2><p>（1）UDP是“无修饰”、“不加渲染的”因特网传输层协议。<br>（2）UDP提供“尽最大努力”服务，即不保证可靠交付，同时也不使用拥塞控制。使得UDP数据段可能丢失或传递失序的报文到应用程序。<br>（3）UDP是面向无连接的协议，即在UDP接收者与发送者之间没有握手、每个UDP数据段的处理独立于其它数据段。<br>（4）UDP只在IP的数据报服务之上增加了很少一点的功能，即端口的功能和差错检测的功能。</p>
<p>为什么会有UDP呢？主要有以下几点：<br>（1）不需要建立连接，这样就减少了延迟。<br>（2）在发送者和接收者之间不需要连接状态，使得数据传输更简单。<br>（3）具有很小的数据段首部。<br>（4）没有拥塞控制，UDP能够用尽可能快的速度传递。 很适合多媒体通信的要求。</p>
<p>UDP例子：DNS。</p>
<p>DNS 是一个通常使用 UDP 的应用层协议的例子。当一台主机中的 DNS 应 用程序想要进行一次查询时，它构造了 一个DNS查询报文并将其交给 UD凡无须执行任何与运行在目的端系统中的UDP实体之间的握手，主机端的UDP为此报文添加首部字段 ，然后将形成的报文段交给网络层9网络层将此UDP报文段封装进一个IP数据报中，然后将其发送给一个名字服务器。在查询主机中的DNS应用程序则等待对该查询的响应。如果它没有收到响应(可能是由千底层网络丢失了查询或响应 ) ，则要么试图向另一个名字服务器发送该查询，要么通知调用的应用程序它不能获得响应。</p>
<h3 id="3-3-1-UDP报文段结构"><a href="#3-3-1-UDP报文段结构" class="headerlink" title="3.3.1 UDP报文段结构"></a>3.3.1 UDP报文段结构</h3><p><img src="https://th.bing.com/th/id/R.491a38d2eb9163bae67197bd99305c87?rik=SIk7s9SrvqrrRg&riu=http://upload-images.jianshu.io/upload_images/11034989-0030c15174f2d4b2.png&ehk=EImYWzVHhCy1YEC01edbm++XVDFJ2XhElQVFVOoHlZs=&risl=&pid=ImgRaw&r=0" alt="查看源图像"></p>
<p>数据字段包含一个查询报文/响应报文。</p>
<p>UDP首部4个字段，每个字段由2个字节组成。</p>
<p>长度字段指示了在UDP报文段中的字节数(首部加数据)。长度字段指明了包括首部在内的UDP报文段长度。</p>
<h3 id="3-3-2-UDP检验和"><a href="#3-3-2-UDP检验和" class="headerlink" title="3.3.2 UDP检验和"></a>3.3.2 UDP检验和</h3><p>提供差错检测功能。判断比特是否发生改变。</p>
<p>发送方的UDP对报文段中的所有16比特字的和进行反码运算。求和时遇到溢出要回卷。前两个先相加，再相加后一个，然后再进行反码运算。四个16比特字加在一起，如果有0，分组出现差错。</p>
<p>为什么UDP首先提供了检验和，就像许多链路层协议也提供检验差错那样。原因是不能保证源和目的之间的所有链路都提供差错检测。这是一个在系统设计中被称颂的<strong>端到端原则</strong>的例子。</p>
<h2 id="3-4-可靠数据传输原理"><a href="#3-4-可靠数据传输原理" class="headerlink" title="3.4 可靠数据传输原理"></a>3.4 可靠数据传输原理</h2><p>概念：数据可以通过一条可靠的信道传输，借助于可靠的信道，传输的数据比特就不会受到损坏。</p>
<img src="计算机网络.assets/image-20220611154012154.png" alt="image-20220611154012154" style="zoom:50%;" />

<p><strong>可靠数据传输协议</strong>：由于下层可靠数据传输协议的下层协议也许是不可靠的。</p>
<p><code>rdt_send()函数</code>:上层可以调用数据传输协议的发送方，它将要发送的数据交付给位于接收方的最高层。rdt表示可靠数据传输协议，_send表示rdt的发送端正在被调用。</p>
<p>在接收端，当分组从信道的接收端到达时，将调用rdt_rcv()。</p>
<p>当rdt协议想要向较高层交付数据时，将通过调用deliver_data()来完成。</p>
<p>除了交换含有带传送的数据分组之外，rdt的发送端和接收端还需往返交换控制分组。rdt的发送端和接收端都要通过调用udt_send()发送分组给对方。</p>
<h3 id="3-4-1-构造可靠数据传输协议"><a href="#3-4-1-构造可靠数据传输协议" class="headerlink" title="3.4.1 构造可靠数据传输协议"></a>3.4.1 构造可靠数据传输协议</h3><p><strong>1.经完全可靠信道的可靠数据传输协议:rdt 1.0</strong></p>
<p>首先考虑最简单的情况，即在完全可靠的信道上，没有bit错误、没有分组丢失。</p>
<p>这时发送方与接收方的有限状态机定义如下图：</p>
<img src="计算机网络.assets/image-20220611161336560.png" alt="image-20220611161336560" style="zoom:50%;" />

<p>显示了1.0发送和接收方的<strong>有限状态机</strong>的定义。</p>
<p>发送方和接收方有各自的FSM(有限状态机)。FSM在两个都只有一个状态，描述了协议从一个状态变迁到另一个状态。因此变迁必定是从一个状态返回到自身。</p>
<p>其中，发送方发送数据到下层信道，接收方从下层信道接收数据。发送方和接收方有各自的FSM，并且都只有一个状态，都是从一个状态返回到自身。</p>
<p>发送端通过rdt_send(data)事件接收来自较高层的数据，经过make_pkt(data)事件把上层的数据转换成下层可以识别的数据段，然后把data数据通过udt_send(packet)发到下层IP层。</p>
<p>接收方通过rdt_rcv(paclet)函数从IP层接收数据，收到信息包之后继续等待来自下层的调用，这个过程的事件主要是将数据段转换成数据，交给应用层。</p>
<p>对于rdt1.0总结一句话就是假设信道没有出错，只是做两个动作，一个是交付，一个是上传。</p>
<p><strong>2.经具有比特差错信道地可靠数据传输：rdt2.0</strong></p>
<p>基于重传机制的可靠数据传输协议称为<strong>自动重传请求</strong>(ARQ)协议。</p>
<p>rdt2.0的新机制</p>
<p>ARQ协议中还需要另外三种协议功能来处理存在比特差错的情况：</p>
<ol>
<li><strong>差错检测</strong>。接收方检测到何时出现了比特差错。需要有额外的比特，这些比特被汇集在rdt2.0数据分组的分组检验和字段中。</li>
<li><strong>接收方反馈</strong>。接收方提供明确的反馈信息给发送方，如ACK(肯定确认)和NAK(否定确认)。</li>
<li><strong>重传</strong>。接收方收到有差错的分组时，发送方将重传该分组报文。</li>
</ol>
<img src="计算机网络.assets/image-20220611200048263.png" alt="image-20220611200048263" style="zoom:50%;" />



<p>rdt2.0有两个发送状态：在最左边的状态中，发送端</p>
<p>注意：如果对一个事件没有动作，或没有就事件发送而采取了一个动作，将在横线上方或下方使用符号A表示。</p>
<p>在这个过程中发送方首先等待来自上层的调用，做两个事情，第一个是rdt_send(data)接收上层数据。snkpkt与1.0相比加了一个校验和，可以检测到是否发送错误，之后udp_send(snkpkt)将分组发送出去。之后发送方等待来自接收方的ACK或NAK分组。如果收到一个ACK分组，则发送方知道最近发送的分组已经被正确接收，此时协议返回到等待来自上层调用的状态；如果收到一个NAK分组，则该协议会重传最后一个分组并等待接收方为响应重传分组而回送的ACK或NAK分组。</p>
<p>rdt2.0中接收方的FSM同样只有一个状态，当分组到达时，接收方根据接收到的分组是否受损要么回答一个ACK，要么回答一个NAK。停等协议。</p>
<p>（1）当没有错误时整个发送方与接收方操作如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210717230301386.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>（2）当出现错误场景时发送方与接收方的操作如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210717230408252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>rdt2.0错误场景其实就是一个停等协议，什么是停等协议呢？就是发送方发送一个报文，然后等到接收方的响应，响应类型有ACK和NAK两种，如果是ACK则为正常数据交付，如果是NAK要进行重传。<br><strong>处理受损ACK和NAK时会发生如下三种情况：</strong><br>（1）发送方并不知道接收方发生了什么。例如当我们说话时接收方回答的”请重复一遍”，发送方会问“你说什么？”。<br>（2）增加足够的检验和比特，使发送方不仅可以差错检测，还可以回复差错。对于会产生差错但不丢失分组的信道，这就可以直接解决问题。<br>（3）发送方收到含糊不清的ACK或NAK分组。即冗余分组，冗余分组的困难在于接收方不知道它上次所发送的ACK或NAK是否被发送方正确收到。</p>
<p>rdt2.0致命缺陷：我们考虑当ACK/NAK混淆了会发生什么？这时就会发生上面提到的发送方并不知道接收方发生了什么，使得不能正确重发数据，可能会导致数据重复。解决方法：发送方给每个分组加一个序号，在ACK/NAK混淆时发送方重发当前分组，之后接收方会丢弃重复的分组但并不向上传递。</p>
<p>解决方法：在数据分组中添加一新字段。编号。<strong>即把发送数据分组的序号放在该字段</strong>。这样，接收方只需要检测序号就能发现是否重传了分组。rdt2.0是“停等”的，因此，只需要一位序号就够了。因为只有接收方和发送方都确认该分组传输完成了，才会传输下一个分组。只要前后两次分组的编号是不同的即可，不需要管分组编号是否重复。</p>
<p><img src="https://img-blog.csdnimg.cn/20190402224549142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5MDEwMTAx,size_16,color_FFFFFF,t_70" alt="img"></p>
<p> 接收方的状态也有4种，它反映出了希望接受的分组是0还是1。需要注意的是当接收方接收到的分组是失序的（也就是它正确接受了上一个分组），它返回ACK，当然也必须这样返回，因为这就是出现了第一次返回ACK受损。</p>
<p>如果序号正确，但是分组受损，那么返回一个NAK消息。如果不返回NAK，而是返回对上一个正确接受分组的ACK，这也能实现一样的效果。因为发送方收到以后就知道，你没有成功接受上一个分组之后的分组。也就是说，接收方只返回ACK即可，如果返回的ACK中的编号是发送方刚才发送的，那么说明接收正确；如果返回的ACK的编号是上次发送方上一次发送的数据编号，那么说明接受错误。</p>
<p><img src="https://img-blog.csdnimg.cn/20190405200510524.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5MDEwMTAx,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>经过上面的改造就形成了rdt2.1版本，此时我们的信道仍旧是<strong>只具备“比特可能受损”的特性。</strong></p>
<h1 id="拓展1：报文、报文段、分组、包、数据报、帧、数据流的概念区别"><a href="#拓展1：报文、报文段、分组、包、数据报、帧、数据流的概念区别" class="headerlink" title="拓展1：报文、报文段、分组、包、数据报、帧、数据流的概念区别"></a>拓展1：报文、报文段、分组、包、数据报、帧、数据流的概念区别</h1><p><strong>1.报文(message)</strong></p>
<p>我们将位于应用层的信息分组称为报文。报文是网络中交换与传输的数据单元，也是网络传输的单元。报文包含了将要发送的完整的数据信息，其长短不需一致。报文在传输过程中会不断地封装成分组、包、帧来传输，<strong>封装的方式就是添加一些控制信息组成的首部，那些就是报文头。</strong></p>
<p><strong>2.报文段（segment）</strong></p>
<p>通常是指起<strong>始点和目的地都是传输层的信息单元。</strong></p>
<p><strong>3.分组/包(packet)</strong></p>
<p>分组是在网络中传输的二进制格式的单元，为了提供通信性能和可靠性，每个用户发送的数据会被分成多个更小的部分。在每个部分的前面加上一些必要的控制信息组成的首部，有时也会加上尾部，就构成了一个分组。它的起始和目的地是网络层。</p>
<p><strong>4.数据报(datagram)</strong></p>
<p>面向无连接的数据传输，其工作过程类似于报文交换。采用数据报方式传输时，被传输的分组称为数据报。通常是指起始点和目的地都使用无连接网络服务的网络层的信息单元。(指IP数据报)</p>
<p><strong>5.帧(frame)</strong></p>
<p>帧是数据链路层的传输单元。它将上层传入的数据添加一个头部和尾部，组成了帧。它的起始点和目的点都是数据链路层。</p>
<p><strong>6.数据单元（data unit）</strong></p>
<p>指许多信息单元。常用的数据单元有服务数据单元（SDU）、协议数据单元（PDU）。SDU是在同一机器上的两层之间传送信息。PDU是发送机器上每层的信息发送到接收机器上的相应层（同等层间交流用的）。</p>
<p><strong>分层协议：</strong></p>
<p><a href="https://so.csdn.net/so/search?q=%E5%BA%94%E7%94%A8%E5%B1%82&spm=1001.2101.3001.7020">应用层</a>——消息</p>
<p>传输层——报文段(segment)/数据报(datagram) (注：TCP叫<strong>TCP报文段</strong>，UDP叫<strong>UDP数据报</strong>,也有人叫UDP段)</p>
<p>网络层——分组、数据包（packet）</p>
<p>链路层——帧（frame）</p>
<p>物理层——P-PDU（bit）</p>
<p><img src="https://img-blog.csdnimg.cn/20181201104548931.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2EzMTkyMDQ4,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>其实，segment，datagram，packet，frame是存在于同条记录中的，是基于所在协议层不同而取了不同的名字。我们可以用一个形象的例子对数据包的概念加以说明：我们在邮局邮寄产品时，虽然产品本身带有自己的包装盒，但是在邮寄的时候只用产品原包装盒来包装显然是不行的。必须把内装产品的包装盒放到一个邮局指定的专用纸箱里，这样才能够邮寄。这里，产品包装盒相当于数据包，里面放着的产品相当于可用的数据，而专用纸箱就相当于帧，且一个帧中通常只有一个数据包。<br>注：Datagram: This is used in 2 layers. If the network protocol is IP, the unit of data is called Datagram. At transport layer, if protocol is UDP, we use datagram there as well. Hence, we differentiate them as UDP Datagram, IP Datagram. (参考链接:Definition of Network Units: Fragment, Segment, Packet, Frame, Datagram)</p>
<p>TCP数据流(TCP stream)</p>
<p>Wireshark中是这么定义的：相同四元组(源地址，源端口，目的地址，目的端口)的包就为一条TCP流，即一条流有很多个包。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>专业基础</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>C++_Primer_Plus课后练习题集合</title>
    <url>/undefined/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/C-%E8%AF%AD%E8%A8%80/c-primer-plus%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0%E9%A2%98%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<p>C++ Primer Plus的复盘学习。<br>以下是书本课后编程练习的源代码。<br>编译链接环境：Visual Studio 2019 / Visual Studio Code / Dev C++</p>
<span id="more"></span>
<h1 id="chapter-2"><a href="#chapter-2" class="headerlink" title="chapter 2"></a>chapter 2</h1><ol>
<li>2.7.1<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">// practice 1</span><br><span class="line">void p2_1(void)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Ken&quot; &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &quot;China, Beijing City.&quot; &lt;&lt; std::endl;</span><br><span class="line"> </span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    p2_1();</span><br><span class="line">    getchar();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
结果：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ken</span><br><span class="line">China, Beijing City.</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<ol start="2">
<li>2.7.2<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">// practice 2</span><br><span class="line">void p2_2(void)</span><br><span class="line">&#123;</span><br><span class="line">    int ilong = 0;</span><br><span class="line">    int iyards = 0;</span><br><span class="line">    std::cout &lt;&lt; &quot;Input the distance in long:&quot;;</span><br><span class="line">    std::cin &gt;&gt; ilong;</span><br><span class="line">    iyards = 220 * ilong;</span><br><span class="line">    std::cout &lt;&lt; &quot;the distance in yards is &quot; &lt;&lt; iyards &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    p2_2();</span><br><span class="line">    getchar();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
结果：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input the distance in long:7</span><br><span class="line">the distance in yards is 1540</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<ol start="3">
<li>2.7.3<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">// practice 3</span><br><span class="line">void string1(void)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Three blind mice&quot; &lt;&lt; std::endl;</span><br><span class="line"> </span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void string2(void)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;See how they run&quot; &lt;&lt; std::endl;</span><br><span class="line"> </span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void p2_3(void)</span><br><span class="line">&#123;</span><br><span class="line">    string1();</span><br><span class="line">    string1();</span><br><span class="line">    string2();</span><br><span class="line">    string2();</span><br><span class="line"> </span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    p2_3();</span><br><span class="line">    getchar();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
结果：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Three blind mice</span><br><span class="line">Three blind mice</span><br><span class="line">See how they run</span><br><span class="line">See how they run</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<ol start="4">
<li>2.7.4<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">// practice 3</span><br><span class="line">void string1(void)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Three blind mice&quot; &lt;&lt; std::endl;</span><br><span class="line"> </span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void string2(void)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;See how they run&quot; &lt;&lt; std::endl;</span><br><span class="line"> </span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void p2_3(void)</span><br><span class="line">&#123;</span><br><span class="line">    string1();</span><br><span class="line">    string1();</span><br><span class="line">    string2();</span><br><span class="line">    string2();</span><br><span class="line"> </span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    p2_3();</span><br><span class="line">    getchar();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
结果：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Three blind mice</span><br><span class="line">Three blind mice</span><br><span class="line">See how they run</span><br><span class="line">See how they run</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<ol start="5">
<li>2.7.5<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">// practice 5</span><br><span class="line">double Celsius2Fahrenheit(double Celsius)</span><br><span class="line">&#123;</span><br><span class="line">    return (1.8 * Celsius + 32.0);</span><br><span class="line">&#125;</span><br><span class="line">void p2_5(void)</span><br><span class="line">&#123;</span><br><span class="line">    double Celsius = 0.0;</span><br><span class="line">    double Fahrenheit = 0.0;</span><br><span class="line">    std::cout &lt;&lt; &quot;Please enter a Celsius value :&quot;;</span><br><span class="line">    std::cin &gt;&gt; Celsius;</span><br><span class="line">    Fahrenheit = Celsius2Fahrenheit(Celsius);</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; Celsius &lt;&lt; &quot; degrees Celsius is &quot; &lt;&lt; Fahrenheit &lt;&lt; &quot; defrees Fahrenheit.&quot; &lt;&lt; std::endl;</span><br><span class="line"> </span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    p2_5();</span><br><span class="line">    getchar();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
结果：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Please enter a Celsius value :30</span><br><span class="line">30 degrees Celsius is 86 defrees Fahrenheit.</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<ol start="6">
<li>2.7.6<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">// practice 6</span><br><span class="line">double LightYears2Astronomical(double LightYears)</span><br><span class="line">&#123;</span><br><span class="line">    return (LightYears * 63240);</span><br><span class="line">&#125;</span><br><span class="line">void p2_6(void)</span><br><span class="line">&#123;</span><br><span class="line">    double lightYears = 0;</span><br><span class="line">    double astronomical = 0;</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; &quot;Enter the number of light years: &quot;;</span><br><span class="line">    std::cin &gt;&gt; lightYears;</span><br><span class="line"> </span><br><span class="line">    astronomical = LightYears2Astronomical(lightYears);</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; lightYears &lt;&lt; &quot; light years = &quot; &lt;&lt; astronomical &lt;&lt; &quot; astronomical units.&quot; &lt;&lt; std::endl;</span><br><span class="line"> </span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    p2_6();</span><br><span class="line">    getchar();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
结果：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Enter the number of light years: 42</span><br><span class="line">42 light years = 2.65608e+06 astronomical units.</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<hr>
<ol start="7">
<li>2.7.7<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">// practice 7</span><br><span class="line">void disTime(int hours, int minutes)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Time: &quot; &lt;&lt; hours &lt;&lt; &quot;:&quot; &lt;&lt; minutes &lt;&lt; std::endl;</span><br><span class="line"> </span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">void p2_7(void)</span><br><span class="line">&#123;</span><br><span class="line">    int hours = 0;</span><br><span class="line">    int minutes = 0;</span><br><span class="line">    std::cout &lt;&lt; &quot;Enter the number of hours: &quot;;</span><br><span class="line">    std::cin &gt;&gt; hours;</span><br><span class="line">    std::cout &lt;&lt; &quot;Enter the number of minutes: &quot;;</span><br><span class="line">    std::cin &gt;&gt; minutes;</span><br><span class="line">    disTime(hours, minutes);</span><br><span class="line"> </span><br><span class="line">    return;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    p2_7();</span><br><span class="line">    getchar();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
结果：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Enter the number of hours: 9</span><br><span class="line">Enter the number of minutes: 18</span><br><span class="line">Time: 9:18</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h1 id="chapter-3"><a href="#chapter-3" class="headerlink" title="chapter 3"></a>chapter 3</h1>]]></content>
      <categories>
        <category>学习</category>
        <category>计算机语言</category>
        <category>C++语言</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法学习</title>
    <url>/undefined/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B7%A5%E5%85%B7/Markdown-Typora/markdown%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Markdown-Typora教程"><a href="#Markdown-Typora教程" class="headerlink" title="Markdown/Typora教程"></a>Markdown/Typora教程</h1><blockquote>
<p>文章参考：菜鸟驿站、少数派；文章整理与编辑：nono</p>
</blockquote>
<blockquote>
<p>Typora 一直是我认为桌面端笔记应用应有的终极形态。用参考作者之前 <a href="https://sspai.com/post/54122">一篇文章</a> 中的话来说就是，「它的<strong>功能之强大、设计之冷静、体验之美妙、理念之先进</strong>，我认为值得所有笔记应用厂商学习。」</p>
<p>Typora 是一款<strong>支持实时预览的 Markdown 文本编辑器</strong>。它有 OS X、Windows、Linux 三个平台的版本，并且由于仍在测试中，是<strong>完全免费</strong>的。Markdown 是用来编写结构化文档的一种纯文本格式，它使我们在双手不离开键盘的情况下，可以对文本进行一定程度的格式排版。</p>
<p>由于目前还没有一个权威机构对 Markdown 的语法进行规范，各应用厂商制作时遵循的 Markdown 语法也是不尽相同的。其中比较受到认可的是 <a href="https://github.github.com/gfm/">GFM 标准</a>，它是由著名代码托管网站 <a href="https://github.com/">GitHub</a> 所制定的。Typora 主要使用的也是 GFM 标准。同时，你还可以在 <code>文件 - 偏好设置 - Markdown 语法偏好 - 严格模式</code> 中将标准设置为「更严格地遵循 GFM 标准」。具体内容你可以在官方的 <a href="http://support.typora.io/Strict-Mode/">这篇文档</a> 中查看。</p>
</blockquote>
<span id="more"></span>

<p><em>参考链接：</em></p>
<ol>
<li><a href="http://support.typora.io/Strict-Mode/">http://support.typora.io/Strict-Mode/</a></li>
<li><a href="https://sspai.com/post/54912/">Typora 完全使用详解 - 少数派</a></li>
</ol>
<h1 id="Markdown-教程"><a href="#Markdown-教程" class="headerlink" title="Markdown 教程"></a>Markdown 教程</h1><hr>
<p>Markdown 是一种<strong>轻量级标记语言</strong>，它允许人们使用<strong>易读易写的纯文本格式编写文档</strong>。</p>
<p>Markdown 语言在2004年’由约翰·格鲁伯（英语：John Gruber）创建。</p>
<p>Markdown 编写的文档可以导出 <strong>HTML</strong> 、<strong>Word</strong>、<strong>图像</strong>、<strong>PDF</strong>、<strong>Epub</strong> 等多种格式的文档。</p>
<p>Markdown 编写的文档后缀为 <strong><code>.md</code></strong>, <strong><code>.markdown</code></strong> 。</p>
<hr>
<h2 id="Markdown-应用"><a href="#Markdown-应用" class="headerlink" title="Markdown 应用"></a>Markdown 应用</h2><p>Markdown 能被使用来撰写电子书，如：Gitbook。</p>
<p>当前许多网站都广泛使用<code>Markdown</code>来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge等。</p>
<hr>
<h2 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h2><p>本教程将使用 Typora 编辑器来讲解 Markdown 的语法，Typora 支持 MacOS 、Windows、Linux 平台，且包含多种主题，编辑后直接渲染出效果。</p>
<p>支持导出HTML、PDF、Word、图片等多种类型文件。</p>
<p>Typora 官网：<a href="https://typora.io/">https://typora.io/</a></p>
<p>你也可以使用我们的在线编辑器来测试：<a href="https://c.runoob.com/front-end/712">https://c.runoob.com/front-end/712</a>。</p>
<hr>
<h2 id="有用的书籍"><a href="#有用的书籍" class="headerlink" title="有用的书籍"></a>有用的书籍</h2><p>《了不起的Markdown》：</p>
<ul>
<li><a href="https://item.jd.com/12669274.html">京东</a></li>
<li><a href="http://product.dangdang.com/27912444.html">当当</a></li>
</ul>
<hr>
<h2 id="测试实例"><a href="#测试实例" class="headerlink" title="测试实例"></a>测试实例</h2><p>Mardown 编写 Hello World! 语法：<code># Hello World!</code></p>
<p>将该代码格式粘贴到 Typora 效果如下：</p>
<div style="width:80%;margin:auto"><img src="/undefined/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B7%A5%E5%85%B7/Markdown-Typora/markdown%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/md1.gif" class="" title="测试实例"></div>

<h1 id="Markdown-标题"><a href="#Markdown-标题" class="headerlink" title="Markdown 标题"></a>Markdown 标题</h1><p>Markdown 标题有两种格式。</p>
<h2 id="1、使用-和-标记一级和二级标题"><a href="#1、使用-和-标记一级和二级标题" class="headerlink" title="1、使用 = 和 - 标记一级和二级标题"></a>1、使用 = 和 - 标记一级和二级标题</h2><p>= 和 - 标记语法格式如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">我展示的是一级标题</span></span><br><span class="line"><span class="section">=================</span></span><br><span class="line"></span><br><span class="line"><span class="section">我展示的是二级标题</span></span><br><span class="line"><span class="section">-----------------</span></span><br></pre></td></tr></table></figure>

<p>显示效果如下图：</p>
<div style="width:80%;margin:auto"><img src="/undefined/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B7%A5%E5%85%B7/Markdown-Typora/markdown%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/Untitled.png" class="" title="标题实例"></div>

<h2 id="使用-号标记"><a href="#使用-号标记" class="headerlink" title="使用 # 号标记"></a><strong>使用 # 号标记</strong></h2><p>使用 <strong><code>#</code></strong> 号可表示 1-6 级标题，一级标题对应一个 <strong><code>#</code></strong> 号，二级标题对应两个 <strong><code>#</code></strong> 号，以此类推。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure>

<p>显示效果如下图：<br><img src="..\markdown-study\Untitled 1.png" width="80%" alt="标题展示"></p>
<h1 id="Markdown-段落格式"><a href="#Markdown-段落格式" class="headerlink" title="Markdown 段落格式"></a>Markdown 段落格式</h1><h2 id="Markdown-段落"><a href="#Markdown-段落" class="headerlink" title="Markdown 段落"></a>Markdown 段落</h2><p>Markdown 段落没有特殊的格式，直接编写文字就好，<strong>段落的换行是使用两个以上空格加上回车</strong>。</p>
<p>显示效果如下图：<br><img src="..\markdown-study\Untitled 2.png" width="80%" alt="段落展示"></p>
<hr>
<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p>Markdown 可以使用以下几种字体：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*斜体文本*</span><br><span class="line">_斜体文本_</span><br><span class="line">**粗体文本**</span><br><span class="line">__粗体文本__</span><br><span class="line">***粗斜体文本***</span><br><span class="line">___粗斜体文本___</span><br></pre></td></tr></table></figure>

<p>显示效果如下所示：<br><img src="..\markdown-study\Untitled 3.png" width="80%"></p>
<hr>
<h2 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h2><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">***</span><br><span class="line"></span><br><span class="line">* * *</span><br><span class="line"></span><br><span class="line">*****</span><br><span class="line"></span><br><span class="line">- - -</span><br><span class="line"></span><br><span class="line">----------</span><br></pre></td></tr></table></figure>


<p>显示效果如下所示：<br><img src="..\markdown-study\Untitled 4.png" width="80%"></p>
<hr>
<h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 <strong>~~</strong> 即可，实例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RUNOOB.COM</span><br><span class="line">GOOGLE.COM</span><br><span class="line">~~BAIDU.COM~~</span><br></pre></td></tr></table></figure>

<p>显示效果如下所示：<br><img src="..\markdown-study\Untitled 5.png" width="80%"></p>
<hr>
<h2 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h2><p>下划线可以通过 HTML 的 <strong><code>&lt;u&gt;</code></strong> 标签来实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;u&gt;带下划线文本&lt;/u&gt;</span><br></pre></td></tr></table></figure>

<p>显示效果如下所示：</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/05A27273-B66D-43DE-A3DB-0D32FF024093.jpg" alt="https://www.runoob.com/wp-content/uploads/2019/03/05A27273-B66D-43DE-A3DB-0D32FF024093.jpg"></p>
<hr>
<h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><p>脚注是对文本的补充说明。</p>
<p>Markdown 脚注的格式如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[^要注明的文本]</span><br></pre></td></tr></table></figure>

<p>以下实例演示了脚注的用法：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">创建脚注格式类似这样 [^RUNOOB]。</span><br><span class="line"></span><br><span class="line">[<span class="symbol">^RUNOOB</span>]: <span class="link">菜鸟教程 -- 学的不仅是技术，更是梦想！！！</span></span><br></pre></td></tr></table></figure>

<p>演示效果如下：</p>
<img src="..\markdown-study\Untitled 6.png" width="80%">

<h1 id="Markdown-列表"><a href="#Markdown-列表" class="headerlink" title="Markdown 列表"></a>Markdown 列表</h1><p>Markdown 支持有序列表和无序列表。</p>
<p>无序列表使用星号(<em>****)、加号(<strong>+</strong>)或是减号(</em>*-<strong>)作为列表标记，这些标记后面要添加一个</strong>空格**，然后再填写内容：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span> 第一项</span><br><span class="line"><span class="bullet">*</span> 第二项</span><br><span class="line"><span class="bullet">*</span> 第三项</span><br><span class="line"></span><br><span class="line"><span class="bullet">+</span> 第一项</span><br><span class="line"><span class="bullet">+</span> 第二项</span><br><span class="line"><span class="bullet">+</span> 第三项</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 第一项</span><br><span class="line"><span class="bullet">-</span> 第二项</span><br><span class="line"><span class="bullet">-</span> 第三项</span><br></pre></td></tr></table></figure>

<p>显示结果如下：</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/89446A8E-6D83-4666-AACC-980145D5F070.jpg" alt="https://www.runoob.com/wp-content/uploads/2019/03/89446A8E-6D83-4666-AACC-980145D5F070.jpg"></p>
<p>有序列表使用数字并加上**<code>.</code>**号来表示(记得添加空格)，如：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 第一项</span><br><span class="line"><span class="bullet">2.</span> 第二项</span><br><span class="line"><span class="bullet">3.</span> 第三项</span><br></pre></td></tr></table></figure>

<p>显示结果如下：</p>
<img src="..\markdown-study\Untitled 7.png" width="80%">
### **列表嵌套**

<p>列表嵌套只需在子列表中的选项前面添加四个空格即可：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 第一项：</span><br><span class="line"><span class="bullet">    -</span> 第一项嵌套的第一个元素</span><br><span class="line"><span class="bullet">    -</span> 第一项嵌套的第二个元素</span><br><span class="line"><span class="bullet">2.</span> 第二项：</span><br><span class="line"><span class="bullet">    -</span> 第二项嵌套的第一个元素</span><br><span class="line"><span class="bullet">    -</span> 第二项嵌套的第二个元素</span><br></pre></td></tr></table></figure>

<p>显示结果如下：<br><img src="..\markdown-study\Untitled 8.png" width="80%"></p>
<h1 id="Markdown-区块"><a href="#Markdown-区块" class="headerlink" title="Markdown 区块"></a>Markdown 区块</h1><p>Markdown 区块引用是在段落开头使用 <strong><code>&gt;</code></strong> 符号 ，然后后面紧跟一个<strong>空格</strong>符号：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 区块引用</span></span><br><span class="line"><span class="quote">&gt; 菜鸟教程</span></span><br><span class="line"><span class="quote">&gt; 学的不仅是技术更是梦想</span></span><br></pre></td></tr></table></figure>

<p>显示结果:<br><img src="..\markdown-study\Untitled 9.png" width="80%"></p>
<p>另外区块是可以嵌套的，一个 <strong><code>&gt;</code></strong> 符号是最外层，两个 <strong><code>&gt;</code></strong> 符号是第一层嵌套，以此类推：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; 最外层</span><br><span class="line">&gt; &gt; 第一层嵌套</span><br><span class="line">&gt; &gt; &gt; 第二层嵌套</span><br></pre></td></tr></table></figure>

<p>显示结果如下：<br><img src="..\markdown-study\Untitled 10.png" width="80%"></p>
<h3 id="区块中使用列表"><a href="#区块中使用列表" class="headerlink" title="区块中使用列表"></a><strong>区块中使用列表</strong></h3><p>区块中使用列表实例如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 区块中使用列表</span></span><br><span class="line"><span class="quote">&gt; 1. 第一项</span></span><br><span class="line"><span class="quote">&gt; 2. 第二项</span></span><br><span class="line"><span class="quote">&gt; + 第一项</span></span><br><span class="line"><span class="quote">&gt; + 第二项</span></span><br><span class="line"><span class="quote">&gt; + 第三项</span></span><br></pre></td></tr></table></figure>

<p>显示结果如下：<br><img src="..\markdown-study\Untitled 11.png" width="80%"></p>
<h3 id="列表中使用区块"><a href="#列表中使用区块" class="headerlink" title="列表中使用区块"></a><strong>列表中使用区块</strong></h3><p>如果要在列表项目内放进区块，那么就需要在 <strong><code>&gt;</code></strong> 前添加四个空格的缩进。</p>
<p>列表中使用区块实例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 第一项</span><br><span class="line">    &gt; 菜鸟教程</span><br><span class="line">    &gt; 学的不仅是技术更是梦想</span><br><span class="line">* 第二项</span><br></pre></td></tr></table></figure>

<p>显示结果如下：<br><img src="..\markdown-study\Untitled 12.png" width="80%"></p>
<h1 id="Markdown代码"><a href="#Markdown代码" class="headerlink" title="Markdown代码"></a>Markdown代码</h1><p>如果是段落上的一个函数或片段的代码可以用<strong>反引号</strong>把它包起来（```），例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`printf()` 函数</span><br></pre></td></tr></table></figure>

<p>显示结果如下：<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/C928FDA3-E0A7-4AFF-AB2A-B3AF44F93DF9.jpg" alt="https://www.runoob.com/wp-content/uploads/2019/03/C928FDA3-E0A7-4AFF-AB2A-B3AF44F93DF9.jpg"></p>
<h2 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h2><p>代码区块使用 <strong>4个空格</strong>或者一个<strong>制表符（Tab 键）</strong>。</p>
<p>实例如下：<br><img src="..\markdown-study\Untitled 13.png" width="80%"></p>
<p>你也可以用 <strong>`````</strong> 包裹一段代码，并指定一种语言（也可以不指定）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(document).ready(function () &#123;</span><br><span class="line">    alert(&#x27;RUNOOB&#x27;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<p>显示结果如下：<br><img src="..\markdown-study\Untitled 14.png" width="80%"></p>
<h1 id="Markdown-链接"><a href="#Markdown-链接" class="headerlink" title="Markdown 链接"></a>Markdown 链接</h1><p>链接使用方法如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">链接名称</span>](<span class="link">链接地址</span>)</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">&lt;链接地址&gt;</span><br></pre></td></tr></table></figure>

<p>例如： 不算</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">这是一个链接 [<span class="string">菜鸟教程</span>](<span class="link">https://www.runoob.com</span>)</span><br></pre></td></tr></table></figure>

<p>显示结果如下：<br><img src="..\markdown-study\Untitled 15.png" width="80%"></p>
<p>直接使用链接地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;https://www.runoob.com&gt;</span><br></pre></td></tr></table></figure>

<p>显示结果如下：<br><img src="..\markdown-study\Untitled 16.png" width="80%"></p>
<h2 id="高级链接"><a href="#高级链接" class="headerlink" title="高级链接"></a><strong>高级链接</strong></h2><p>我们可以通过变量来设置一个链接，变量赋值在文档末尾进行：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">这个链接用 1 作为网址变量 [<span class="string">Google</span>][<span class="symbol">1</span>]</span><br><span class="line">这个链接用 runoob 作为网址变量 [<span class="string">Runoob</span>][<span class="symbol">runoob</span>]</span><br><span class="line">然后在文档的结尾为变量赋值（网址）</span><br><span class="line"></span><br><span class="line">  [1]: http://www.google.com/</span><br><span class="line">  [runoob]: http://www.runoob.com/</span><br></pre></td></tr></table></figure>

<p><a href="https://www.baidu.com/">百度</a></p>
<p>这个链接用 1 作为网址变量 <a href="http://www.google.com/">Google</a><br>这个链接用 runoob 作为网址变量 <a href="http://www.runoob.com/">Runoob</a><br>然后在文档的结尾为变量赋值（网址）</p>
<h1 id="Markdown-图片"><a href="#Markdown-图片" class="headerlink" title="Markdown 图片"></a>Markdown 图片</h1><p>Markdown 图片语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![alt 属性文本](图片地址)</span><br><span class="line"></span><br><span class="line">![alt 属性文本](图片地址 &quot;可选标题&quot;)</span><br></pre></td></tr></table></figure>

<ul>
<li>开头一个感叹号 !</li>
<li>接着一个方括号，里面放上图片的替代文字</li>
<li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ‘title’ 属性的文字。</li>
</ul>
<p>使用实例：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">RUNOOB 图标</span>](<span class="link">http://static.runoob.com/images/runoob-logo.png</span>)</span><br><span class="line"></span><br><span class="line">![<span class="string">RUNOOB 图标</span>](<span class="link">http://static.runoob.com/images/runoob-logo.png &quot;RUNOOB&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>显示结果如下：</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/A042DF30-C232-46F3-8436-7D6C35351BBD.jpg" alt="https://www.runoob.com/wp-content/uploads/2019/03/A042DF30-C232-46F3-8436-7D6C35351BBD.jpg"></p>
<p>当然，你也可以像网址那样对图片网址使用变量:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这个链接用 1 作为网址变量 [RUNOOB][1].</span><br><span class="line">然后在文档的结尾为变量赋值（网址）</span><br><span class="line"></span><br><span class="line">[1]: http://static.runoob.com/images/runoob-logo.png</span><br></pre></td></tr></table></figure>

<p>显示结果如下：</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/75AA6EBF-CC57-44A6-A585-5EE3DD94E42A.jpg" alt="https://www.runoob.com/wp-content/uploads/2019/03/75AA6EBF-CC57-44A6-A585-5EE3DD94E42A.jpg"></p>
<p>Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 <img> 标签。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;[http://static.runoob.com/images/runoob-logo.png](http://static.runoob.com/images/runoob-logo.png)&quot;</span> <span class="attr">width</span>=<span class="string">&quot;50%&quot;</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>显示结果如下：<br><img src="..\markdown-study\Untitled 17.png" width="80%"></p>
<h1 id="Markdown-表格"><a href="#Markdown-表格" class="headerlink" title="Markdown 表格"></a>Markdown 表格</h1><p>Markdown 制作表格使用 <code>|</code> 来分隔不同的单元格，使用 <code>-</code> 来分隔表头和其他行。</p>
<p>语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|  表头   | 表头  |</span><br><span class="line">|  ----  | ----  |</span><br><span class="line">| 单元格  | 单元格 |</span><br><span class="line">| 单元格  | 单元格 |</span><br></pre></td></tr></table></figure>

<p>以上代码显示结果如下：<br><img src="..\markdown-study\Untitled 18.png" width="80%"></p>
<h1 id="Markdown-高级技巧"><a href="#Markdown-高级技巧" class="headerlink" title="Markdown 高级技巧"></a>Markdown 高级技巧</h1><h3 id="支持的-HTML-元素"><a href="#支持的-HTML-元素" class="headerlink" title="支持的 HTML 元素"></a><strong>支持的 HTML 元素</strong></h3><p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。</p>
<p>目前支持的 HTML 元素有：<code>&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;</code>等 ，如：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">使用 <span class="language-xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Ctrl<span class="language-xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span>+<span class="language-xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Alt<span class="language-xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span>+<span class="language-xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Del<span class="language-xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span> 重启电脑</span><br></pre></td></tr></table></figure>

<p>输出结果为：<br><img src="..\markdown-study\Untitled 19.png" width="80%"></p>
<h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a><strong>转义</strong></h3><p>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**文本加粗**</span><br><span class="line">\*\* 正常显示星号 \*\*</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/CA0E0162-0C48-41CD-B57A-CB32A4287C02.jpg" alt="https://www.runoob.com/wp-content/uploads/2019/03/CA0E0162-0C48-41CD-B57A-CB32A4287C02.jpg"></p>
<p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">\   反斜线</span><br><span class="line">`   反引号</span><br><span class="line"><span class="bullet">*</span>   星号</span><br><span class="line"><span class="emphasis">_   下划线</span></span><br><span class="line"><span class="emphasis">&#123;&#125;  花括号</span></span><br><span class="line"><span class="emphasis">[]  方括号</span></span><br><span class="line"><span class="emphasis">()  小括号</span></span><br><span class="line"><span class="emphasis">#   井字号</span></span><br><span class="line"><span class="emphasis">+   加号</span></span><br><span class="line"><span class="emphasis">-   减号</span></span><br><span class="line"><span class="emphasis">.   英文句点</span></span><br><span class="line"><span class="emphasis">!   感叹号</span></span><br></pre></td></tr></table></figure>

<h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a><strong>公式</strong></h3><p><a href="https://www.zybuluo.com/codeep/note/163962#%E4%B8%80%E5%85%AC%E5%BC%8F%E4%BD%BF%E7%94%A8%E5%8F%82%E8%80%83">Cmd Markdown 公式指导手册 - 作业部落 Cmd Markdown 编辑阅读器 (zybuluo.com)</a></p>
<p><a href="https://math.meta.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference">MathJax basic tutorial and quick reference - Mathematics Meta Stack Exchange</a></p>
<p>当你需要在编辑器中插入数学公式时，可以使用两个美元符 <code>$$</code> 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\mathbf&#123;V&#125;_1 \times \mathbf&#123;V&#125;_2 =  \begin&#123;vmatrix&#125; \mathbf&#123;i&#125; &amp; \mathbf&#123;j&#125; &amp; \mathbf&#123;k&#125; \\ \frac&#123;\partial X&#125;&#123;\partial u&#125; &amp;  \frac&#123;\partial Y&#125;&#123;\partial u&#125; &amp; 0 \\ \frac&#123;\partial X&#125;&#123;\partial v&#125; &amp;  \frac&#123;\partial Y&#125;&#123;\partial v&#125; &amp; 0 \\ \end&#123;vmatrix&#125; </span><br><span class="line">&#123;&#125;&#123;\style&#123;visibility:hidden&#125;&#123;(x+1)(x+1)&#125;&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>

<p>输出结果为：<br><img src="..\markdown-study\Untitled 20.png" width="80%"></p>
<h1 id="typora-画流程图、时序图-顺序图-、甘特图"><a href="#typora-画流程图、时序图-顺序图-、甘特图" class="headerlink" title="typora 画流程图、时序图(顺序图)、甘特图"></a>typora 画流程图、时序图(顺序图)、甘特图</h1><p>代码语言选择<code>mermaid</code><br><strong>1、横向流程图源码格式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[方形] --&gt;B(圆角)</span><br><span class="line">B --&gt; C&#123;条件a&#125;</span><br><span class="line">C --&gt;|a=1| D[结果1]</span><br><span class="line">C --&gt;|a=2| E[结果2]</span><br><span class="line">F[这是一张横向流程图]</span><br><span class="line">%%[]:方形;():圆角;&#123;&#125;:条件;||:公式;--&gt;:执行线条</span><br></pre></td></tr></table></figure>

<p><strong>2、竖向流程图源码格式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A[方形] --&gt; B(圆角)</span><br><span class="line">    B --&gt; C&#123;条件a&#125;</span><br><span class="line">    C --&gt; |a=1| D[结果1]</span><br><span class="line">    C --&gt; |a=2| E[结果2]</span><br><span class="line">    F[竖向流程图]</span><br></pre></td></tr></table></figure>


<p><strong>3、标准流程图源码格式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">st=&gt;start: 开始框</span><br><span class="line">op=&gt;operation: 处理框</span><br><span class="line">cond=&gt;condition: 判断框(是或否?)</span><br><span class="line">sub1=&gt;subroutine: 子流程</span><br><span class="line">io=&gt;inputoutput: 输入输出框</span><br><span class="line">e=&gt;end: 结束框</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;io-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br></pre></td></tr></table></figure>


<p><strong>4、标准流程图源码格式（横向）：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">st=&gt;start: 开始框</span><br><span class="line">op=&gt;operation: 处理框</span><br><span class="line">cond=&gt;condition: 判断框(是或否?)</span><br><span class="line">sub1=&gt;subroutine: 子流程</span><br><span class="line">io=&gt;inputoutput: 输入输出框</span><br><span class="line">e=&gt;end: 结束框</span><br><span class="line">st(right)-&gt;op(right)-&gt;cond</span><br><span class="line">cond(yes)-&gt;io(bottom)-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br></pre></td></tr></table></figure>


<p><strong>5、UML时序图源码样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对象A-&gt;对象B: 对象B你好吗?（请求）</span><br><span class="line">Note right of 对象B: 对象B的描述</span><br><span class="line">Note left of 对象A: 对象A的描述(提示)</span><br><span class="line">对象B--&gt;对象A: 我很好(响应)</span><br><span class="line">对象A-&gt;对象B: 你真的好吗？</span><br></pre></td></tr></table></figure>


<p><strong>6、UML时序图源码复杂样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Title: 标题：复杂使用</span><br><span class="line">对象A-&gt;对象B: 对象B你好吗?（请求）</span><br><span class="line">Note right of 对象B: 对象B的描述</span><br><span class="line">Note left of 对象A: 对象A的描述(提示)</span><br><span class="line">对象B--&gt;对象A: 我很好(响应)</span><br><span class="line">对象B-&gt;小三: 你好吗</span><br><span class="line">小三--&gt;&gt;对象A: 对象B找我了</span><br><span class="line">对象A-&gt;对象B: 你真的好吗？</span><br><span class="line">Note over 小三,对象B: 我们是朋友</span><br><span class="line">participant C</span><br><span class="line">Note right of C: 没人陪我玩</span><br></pre></td></tr></table></figure>


<p><strong>7、UML标准时序图样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头</span><br><span class="line">  sequenceDiagram</span><br><span class="line">    participant 张三</span><br><span class="line">    participant 李四</span><br><span class="line">    张三-&gt;王五: 王五你好吗？</span><br><span class="line">    loop 健康检查</span><br><span class="line">        王五-&gt;王五: 与疾病战斗</span><br><span class="line">    end</span><br><span class="line">    Note right of 王五: 合理 食物 &lt;br/&gt;看医生...</span><br><span class="line">    李四--&gt;&gt;张三: 很好!</span><br><span class="line">    王五-&gt;李四: 你怎么样?</span><br><span class="line">    李四--&gt;王五: 很好!</span><br></pre></td></tr></table></figure>


<p><strong>8、甘特图样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%% 语法示例</span><br><span class="line">        gantt</span><br><span class="line">        dateFormat  YYYY-MM-DD</span><br><span class="line">        title 软件开发甘特图</span><br><span class="line">        section 设计</span><br><span class="line">        需求                      :done,    des1, 2014-01-06,2014-01-08</span><br><span class="line">        原型                      :active,  des2, 2014-01-09, 3d</span><br><span class="line">        UI设计                     :         des3, after des2, 5d</span><br><span class="line">        未来任务                     :         des4, after des3, 5d</span><br><span class="line">        section 开发</span><br><span class="line">        学习准备理解需求                      :crit, done, 2014-01-06,24h</span><br><span class="line">        设计框架                             :crit, done, after des2, 2d</span><br><span class="line">        开发                                 :crit, active, 3d</span><br><span class="line">        未来任务                              :crit, 5d</span><br><span class="line">        耍                                   :2d</span><br><span class="line">        section 测试</span><br><span class="line">        功能测试                              :active, a1, after des3, 3d</span><br><span class="line">        压力测试                               :after a1  , 20h</span><br><span class="line">        测试报告                               : 48h</span><br></pre></td></tr></table></figure>

<h1 id="Markdown编辑数学公式"><a href="#Markdown编辑数学公式" class="headerlink" title="Markdown编辑数学公式"></a>Markdown编辑数学公式</h1><p>具体请详见[Mathjax](<a href="https://www.jianshu.com/p/e74eb43960a1">Markdown数学公式语法 - 简书 (jianshu.com)</a>)内容</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>计算机工具</category>
        <category>Markdown/Typora</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>写作排版</tag>
      </tags>
  </entry>
  <entry>
    <title>9张照片</title>
    <url>/undefined/%E7%94%9F%E6%B4%BB/9%E5%BC%A0%E7%85%A7%E7%89%87/</url>
    <content><![CDATA[<h1 id="背影"><a href="#背影" class="headerlink" title="背影"></a><p style="text-align:center;">背影</p></h1><div style="width:80%;margin:auto;"><img src="/undefined/%E7%94%9F%E6%B4%BB/9%E5%BC%A0%E7%85%A7%E7%89%87/IMG_0027.jpg" class="" title="背影"></div>
<div style="text-align:center;font-size:10px;color:gray;line-height:1em;">摄于2021年8月5日17:22，燕尾州公园，中华人民共和国浙江省</div>
<br>

<h1 id="远观万佛塔"><a href="#远观万佛塔" class="headerlink" title="远观万佛塔"></a><p style="text-align:center;">远观万佛塔</p></h1><div style="width:80%;margin:auto;"><img src="/undefined/%E7%94%9F%E6%B4%BB/9%E5%BC%A0%E7%85%A7%E7%89%87/IMG_0030.jpg" class="" title="远观万佛塔"></div>
<div style="text-align:center;font-size:10px;color:gray;line-height:1em;">摄于2021年8月5日17:32，彩虹桥，中华人民共和国浙江省</div>
<br>

<h1 id="孤寂的红绿灯"><a href="#孤寂的红绿灯" class="headerlink" title="孤寂的红绿灯"></a><p style="text-align:center;">孤寂的红绿灯</p></h1><div style="width:80%;margin:auto;"><img src="/undefined/%E7%94%9F%E6%B4%BB/9%E5%BC%A0%E7%85%A7%E7%89%87/IMG_0054.jpg" class="" title="孤寂的红绿灯"></div>
<div style="text-align:center;font-size:10px;color:gray;line-height:1em;">摄于2021年8月6日18:13，艾青公园，华人民共和国浙江省</div>
<br>
<span id="more"></span>

<h1 id="光影"><a href="#光影" class="headerlink" title="光影"></a><p style="text-align:center;">光影</p></h1><div style="width:80%;margin:auto;"><img src="/undefined/%E7%94%9F%E6%B4%BB/9%E5%BC%A0%E7%85%A7%E7%89%87/IMG_0135.jpg" class="" title="光影"></div>
<div style="text-align:center;font-size:10px;color:gray;line-height:1em;">摄于2021年8月10日20:14，彩虹桥，中华人民共和国浙江省</div>
<br>

<h1 id="我的高中母校"><a href="#我的高中母校" class="headerlink" title="我的高中母校"></a><p style="text-align:center;">我的高中母校</p></h1><div style="width:80%;margin:auto;"><img src="/undefined/%E7%94%9F%E6%B4%BB/9%E5%BC%A0%E7%85%A7%E7%89%87/IMG_0181.jpg" class="" title="我的高中母校"></div>
<div style="text-align:center;font-size:10px;color:gray;line-height:1em;">摄于2021年8月21日22:16，浙江金华第一中学，中华人民共和国浙江省</div>
<br>

<h1 id="颐和园"><a href="#颐和园" class="headerlink" title="颐和园"></a><p style="text-align:center;">颐和园</p></h1><div style="width:80%;margin:auto;"><img src="/undefined/%E7%94%9F%E6%B4%BB/9%E5%BC%A0%E7%85%A7%E7%89%87/IMG_0285.jpg" class="" title="颐和园"></div>
<div style="text-align:center;font-size:10px;color:gray;line-height:1em;">摄于2021年9月21日10:13，颐和园，中华人民共和国北京市</div>
<br>

<h1 id="故宫"><a href="#故宫" class="headerlink" title="故宫"></a><p style="text-align:center;">故宫</p></h1><div style="width:80%;margin:auto;"><img src="/undefined/%E7%94%9F%E6%B4%BB/9%E5%BC%A0%E7%85%A7%E7%89%87/IMG_1631.jpg" class="" title="故宫"></div>
<div style="text-align:center;font-size:10px;color:gray;line-height:1em;">摄于2022年1月14日11:35，故宫，中华人民共和国北京市</div>
<br>

<h1 id="寻探幽静"><a href="#寻探幽静" class="headerlink" title="寻探幽静"></a><p style="text-align:center;">寻探幽静</p></h1><div style="width:80%;margin:auto;"><img src="/undefined/%E7%94%9F%E6%B4%BB/9%E5%BC%A0%E7%85%A7%E7%89%87/IMG_1830.jpg" class="" title="寻探幽静"></div>
<div style="text-align:center;font-size:10px;color:gray;line-height:1em;">摄于2022年3月12日12:18，花田小镇，中华人民共和国浙江省</div>
<br>

<h1 id="我想变成天上的云"><a href="#我想变成天上的云" class="headerlink" title="我想变成天上的云"></a><p style="text-align:center;">我想变成天上的云</p></h1><div style="width:80%;margin:auto;"><img src="/undefined/%E7%94%9F%E6%B4%BB/9%E5%BC%A0%E7%85%A7%E7%89%87/IMG_1842.jpg" class="" title="我想变成天上的云"></div>
<div style="text-align:center;font-size:10px;color:gray;line-height:1em;">摄于2022年4月5日17:27，家中，中华人民共和国浙江省</div>]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构笔记</title>
    <url>/undefined/%E5%AD%A6%E4%B9%A0/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><blockquote>
<p>以下是我的数据结构笔记</p>
</blockquote>
<span id="more"></span>
<h1 id="第1章-绪论"><a href="#第1章-绪论" class="headerlink" title="第1章 绪论"></a>第1章 绪论</h1><h2 id="1-1-数据结构的研究内容"><a href="#1-1-数据结构的研究内容" class="headerlink" title="1.1 数据结构的研究内容"></a>1.1 数据结构的研究内容</h2><p>步骤：具体问题抽象出数据模型，然后设计解决数学模型的算法，编写程序，测试、调试直到解决问题。</p>
<p>实质是分析问题，从中提取操作的对象，并找出这些操作对象，并找出操作对象的关系，然后用数学语言加以描述。</p>
<p>操作对象、操作算法，关系，数据结构</p>
<h2 id="1-2-基本概念和术语"><a href="#1-2-基本概念和术语" class="headerlink" title="1.2 基本概念和术语"></a>1.2 基本概念和术语</h2><h3 id="1-2-1-数据、数据元素、数据项和数据对象"><a href="#1-2-1-数据、数据元素、数据项和数据对象" class="headerlink" title="1.2.1 数据、数据元素、数据项和数据对象"></a>1.2.1 数据、数据元素、数据项和数据对象</h3><p><strong>数据：</strong>是能输入计算机且能被计算机处理的各种符号的集合。</p>
<p>包括信息的载体、对客观事物符号化的表示、能够被计算机识别、存储和加工</p>
<p>包括数值型数据和非数值型数据，包括文字、图形图像等。</p>
<p><strong>数据元素</strong>：数据的基本单位。元素，记录，结点或者顶点。</p>
<p><strong>数据项</strong>：组成数据元素不可分割的最小单位。</p>
<p>数据&gt;数据元素&gt;数据项</p>
<p><strong>数据对象</strong>：性质相同的数据元素的集合。数据的一个子集。</p>
<h3 id="1-2-2-数据结构"><a href="#1-2-2-数据结构" class="headerlink" title="1.2.2 数据结构"></a>1.2.2 数据结构</h3><p><strong>数据结构</strong>：</p>
<p>数据元素不是孤立存在的，它们之间存在着某种关系，数据元素相互之间的关系称为结构(Structure )</p>
<p>是指相互之间存在一种或多种特定关系的数据元素集合或者说，数据结构是带结构的数据元素的集合</p>
<p>数据结构包括以下三方面内容：</p>
<p>1．数据元素之间的逻辑关系，也称为逻辑结构。</p>
<p>2．数据元素及其关系在计算机内存中的表示(又称为映像），称为数据的物理结构或数据的存储结构。</p>
<p>3．数据的运算和实现，即对数据元素可以施加的操作以及这些操作在相应的存储结构上的实现。</p>
<p>逻辑结构、物理结构、关系。</p>
<ul>
<li><p>存储结构是逻辑关系的映象与元素本身的映象。</p>
</li>
<li><p>逻辑结构是数据结构的抽象，存储结构是数据结构的实现</p>
</li>
</ul>
<p><strong>1.逻辑结构</strong></p>
<p>(1)线性结构：一个开始一个终端节点。数据元素之间存在一对一的关系。线性表、栈、队列、串、数组、广义表。</p>
<p>线性表</p>
<p>(2)非线性结构：一个结点可能有多个直接前趋和直接后继。</p>
<p>例如：树、图</p>
<p>树结构、图结构、集合结构</p>
<p><strong>2.存储结构</strong></p>
<p>(1)顺序存储结构</p>
<p>相对位置。</p>
<p>用一组连续的存储单元依次存储数据元素，数据元素之间的逻辑关系由元素的存储位置来表示。</p>
<p>C语言中用数组来实现顺序存储结构</p>
<p>(2)链式存储结构</p>
<p>无需占用一整块存储空间。</p>
<p>用一组任意的存储单元存储数据元素，数据元素之间的逻辑关系用指针来表示。C语言中用指针来实现链式存储结构。</p>
<p>(3)索引存储结构</p>
<p>在存储结点信息的同时，还建立附加的索引表。</p>
<p>索引表中的每一项称为一个索引项。</p>
<p>索引项的一般形式是:(关键字，地址)</p>
<p>关键字是能唯一标识一个结点的那些数据项。</p>
<p>若每个结点在索引表中都有一个索引项，则该索引表称之为稠密索引(Dense Index)。若一组结点在索引表中只对应一个索引项，则该索引表称之为稀疏索引(Sparse Index)。</p>
<p>(4)散列存储结构</p>
<img src="数据结构.assets/image-20220409155323780.png" alt="image-20220409154538578" style="zoom:100%;" />

<h3 id="1-2-3-数据类型和抽象数据类型"><a href="#1-2-3-数据类型和抽象数据类型" class="headerlink" title="1.2.3 数据类型和抽象数据类型"></a>1.2.3 数据类型和抽象数据类型</h3><p>首先明确数据类型。</p>
<p>C语言中基本数据类型、构造数据类型、指针、空类型、typedef等等</p>
<p>概念：值的集合和操作总称。</p>
<p><strong>抽象数据类型</strong>：ADT，用户定义的、表示应用问题的数学模型，以及定义在这个模型上一组操作的总称，具体包括三部分：数据对象、关系集合和基本操作集合。</p>
<p>D S P</p>
<p>参数表：赋值参数以及引用参数(可提供输入值和返回操作结果)</p>
<h2 id="1-3-抽象数据类型的表示与实现"><a href="#1-3-抽象数据类型的表示与实现" class="headerlink" title="1.3 抽象数据类型的表示与实现"></a>1.3 抽象数据类型的表示与实现</h2><img src="数据结构.assets/image-20220409155209627.png" alt="image-20220409154538578" style="zoom:100%;" />

<img src="数据结构.assets/image-20220409155237025.png" alt="image-20220409154538578" style="zoom:100%;" />



<p>抽象数据类型可以通过固有的数据类型(如整型、实型、字付型寺)<br>来表示和实现。</p>
<p>即利用处理器中已存在的数据类型来说明新的结构，用已经头现的探作来组合新的操作。</p>
<h2 id="1-4-算法和算法分析"><a href="#1-4-算法和算法分析" class="headerlink" title="1.4 算法和算法分析"></a>1.4 算法和算法分析</h2><h3 id="1-4-1算法的定义及特性"><a href="#1-4-1算法的定义及特性" class="headerlink" title="1.4.1算法的定义及特性"></a>1.4.1算法的定义及特性</h3><p>算法：为了解决某类问题而规定的一个有限长的操作序列，一个有穷的指令集。</p>
<p>五个性质</p>
<p>描述：自然语言&amp;流程图&amp;伪代码</p>
<h3 id="1-4-2-评价算法优劣的基本标准"><a href="#1-4-2-评价算法优劣的基本标准" class="headerlink" title="1.4.2 评价算法优劣的基本标准"></a>1.4.2 评价算法优劣的基本标准</h3><p>四个设计要求</p>
<h3 id="1-4-3-算法的时间复杂度"><a href="#1-4-3-算法的时间复杂度" class="headerlink" title="1.4.3 算法的时间复杂度"></a>1.4.3 算法的时间复杂度</h3><p>从空间效率和时间效率来考虑。</p>
<p>语句频度？</p>
<p>事前分析与事后分析</p>
<p>时间复杂度：O(n)</p>
<img src="数据结构.assets/image-20220409160624214.png" alt="image-20220409154538578" style="zoom:100%;" />

<img src="数据结构.assets/image-20220409160624214.png" alt="image-20220409160934980" style="zoom:100%;" />

<h1 id="第2章-线性表"><a href="#第2章-线性表" class="headerlink" title="第2章 线性表"></a>第2章 线性表</h1><p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20220612104006388.png" alt="image-20220612104006388"></p>
<h2 id="2-1-线性表的定义和特点"><a href="#2-1-线性表的定义和特点" class="headerlink" title="2.1 线性表的定义和特点"></a>2.1 线性表的定义和特点</h2><p>基本特点：除第一个元素无直接前驱，最后一个元素无直接后继外，其他每个数据元素都有一个前驱和后继。</p>
<p>例子：(A,B,C,D,…,Z)：同一线性表的元素必定具有相同的的特征，即属于同一数据对象。有<strong>线性关系</strong>。</p>
<p><strong>线性表</strong>：==n个数据特性相同的元素构成的有限序列==。</p>
<blockquote>
<p>($a_1$,$a_2$,…,$a_{i-1}$,$a_i$,$a_{i+1}$,…$a_n$)中，$a_1$是线性起点(起始结点)，数字是下标(元素序号， 表示元素在表中的位置)，$a_{i-1}$和$a_{i+1}$分别是直接前趋和直接后继，$a_n$是线性终点(终端结点)，n是表长，所有元素是数据元素。</p>
</blockquote>
<p><strong>对于非空线性表或者线性结构，其特点是：</strong></p>
<ol>
<li>存在唯一的一个被称作“<strong>第一个</strong>”的数据元素；</li>
<li>存在唯一的一个被称作“<strong>最后一个</strong>”的数据元素；</li>
<li>除第一个以外，结构中的每个数据元素均只有一个<strong>前驱</strong>；</li>
<li>除最后一个以，外结构中每个数据元素只有一个<strong>后继</strong>。</li>
</ol>
<ul>
<li>数据元素的个数n定义为表的长度。</li>
<li>n=0时为空表。</li>
<li>将非空的线性表(n&gt;0)记作：(a1,a2,…an)</li>
<li>数据元素ai(1&lt;=i&lt;=n)只是一个抽象的符号，其具体含义在不同情况下不同。</li>
<li>同一线性表中的元素必定具有相同特性，数据元素间的关系是线性关系。线性表是典型的线性结构。</li>
</ul>
<p>例子：英文表、学生情况登记表，12星座</p>
<h2 id="2-2-案例引入"><a href="#2-2-案例引入" class="headerlink" title="2.2 案例引入"></a>2.2 案例引入</h2><p>案例2.1：一元多项式的运算</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 20</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span><span class="comment">//定义存放多项式的数组类型</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">double</span> coef;<span class="comment">//系数</span></span><br><span class="line">	<span class="type">int</span> exp;<span class="comment">//指数</span></span><br><span class="line">&#125;polyarray[MAX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">	polyarray* data;</span><br><span class="line">	<span class="type">int</span> length;</span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建线性表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">create</span><span class="params">(SqList&amp; L, polyarray a, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//初始化</span></span><br><span class="line">	L.data = <span class="keyword">new</span> polyarray[<span class="number">20</span>];</span><br><span class="line">	L.length = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//分别等于结构体数组中的系数和指数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		L.data[i]-&gt;coef = a[i].coef;</span><br><span class="line">		L.data[i]-&gt;exp = a[i].exp;</span><br><span class="line">		L.length++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示创建的线性表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(SqList&amp; L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//打印系数</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;系数：&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; L.data[i]-&gt;coef &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//打印指数</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;指数：&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt; L.data[i]-&gt;exp &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//打印元素个数</span></span><br><span class="line">	cout &lt;&lt;<span class="string">&quot;元素个数为：&quot;</span>&lt;&lt; L.length &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个多项式相加</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(SqList&amp; result_L, SqList&amp; L1, SqList&amp; L2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//初始化结果线性表</span></span><br><span class="line">	result_L.data = <span class="keyword">new</span> polyarray[<span class="number">20</span>];</span><br><span class="line">	result_L.length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num1 = L1.length;</span><br><span class="line">	<span class="type">int</span> num2 = L2.length;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	1.比较两个线性表的长度（元素个数）</span></span><br><span class="line"><span class="comment">	2.下标先以长度小的开始遍历 对应的指数相加</span></span><br><span class="line"><span class="comment">	3.然后以长度小的长度值作为下标起点，将长度大的后面的元素赋给新的线性表</span></span><br><span class="line"><span class="comment">	4.新的线性表的长度等于长度大的线性表的长度</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (num1 &gt; num2)</span><br><span class="line">	&#123;</span><br><span class="line">		result_L.length = num1;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num2; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			result_L.data[i]-&gt;coef = L1.data[i]-&gt;coef + L2.data[i]-&gt;coef;</span><br><span class="line">			result_L.data[i]-&gt;exp = L1.data[i]-&gt;exp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = num2; j &lt; num1; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			result_L.data[j]-&gt;coef = L1.data[j]-&gt;coef;</span><br><span class="line">			result_L.data[j]-&gt;exp = L1.data[j]-&gt;exp;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (num1 &lt; num2)</span><br><span class="line">	&#123;</span><br><span class="line">		result_L.length = num2;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num1; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			result_L.data[i]-&gt;coef = L1.data[i]-&gt;coef + L2.data[i]-&gt;coef;</span><br><span class="line">			result_L.data[i]-&gt;exp = L1.data[i]-&gt;exp;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = num1; j &lt; num2; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			result_L.data[j]-&gt;coef = L2.data[j]-&gt;coef;</span><br><span class="line">			result_L.data[j]-&gt;exp = L2.data[j]-&gt;exp;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		result_L.length = num1;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num1; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			result_L.data[i]-&gt;coef = L1.data[i]-&gt;coef + L2.data[i]-&gt;coef;</span><br><span class="line">			result_L.data[i]-&gt;exp = L1.data[i]-&gt;exp;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;结果线性表的元素个数：&quot;</span> &lt;&lt; result_L.length &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//创建结构体数组</span></span><br><span class="line">	polyarray a = &#123; &#123;<span class="number">10</span>,<span class="number">0</span>&#125;,&#123;<span class="number">5</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-4</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">3</span>&#125;,&#123;<span class="number">2</span>,<span class="number">4</span>&#125;&#125;;</span><br><span class="line">	<span class="comment">//创建线性表</span></span><br><span class="line">	SqList L1;</span><br><span class="line">	<span class="built_in">create</span>(L1, a, <span class="number">5</span>);</span><br><span class="line">	<span class="comment">//打印结果</span></span><br><span class="line">	<span class="built_in">show</span>(L1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	polyarray b = &#123; &#123;<span class="number">-3</span>,<span class="number">0</span>&#125;,&#123;<span class="number">8</span>,<span class="number">1</span>&#125;,&#123;<span class="number">4</span>,<span class="number">2</span>&#125;,&#123;<span class="number">0</span>,<span class="number">3</span>&#125;, &#123;<span class="number">-5</span>,<span class="number">4</span>&#125;,&#123;<span class="number">7</span>,<span class="number">5</span>&#125;,&#123;<span class="number">-2</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line">	SqList L2;</span><br><span class="line">	<span class="built_in">create</span>(L2, b, <span class="number">7</span>);</span><br><span class="line">	<span class="built_in">show</span>(L2);</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="built_in">string</span>(<span class="number">50</span>,<span class="string">&#x27;-&#x27;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	SqList result_L;</span><br><span class="line">	<span class="built_in">add</span>(result_L, L1, L2);</span><br><span class="line">	<span class="built_in">show</span>(result_L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放空间</span></span><br><span class="line">	<span class="keyword">delete</span> result_L.data;</span><br><span class="line">	<span class="keyword">delete</span> L1.data;</span><br><span class="line">	<span class="keyword">delete</span> L2.data;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//按任意键继续</span></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.2 稀疏多项式的运算</strong></p>
<p><strong>2.3 图书信息管理系统</strong></p>
<p>具体请见代码example2.2和2.3</p>
<h2 id="2-3-线性表类型定义"><a href="#2-3-线性表类型定义" class="headerlink" title="2.3 线性表类型定义"></a>2.3 线性表类型定义</h2><p>线性表示相当灵活的数据结构，其长度可以根据需要适当的增长或者缩短，即对线性表的数据元素不仅可以进行访问，而且可以进行擦汗如和删除等操作。</p>
<p>一、下列给出线性表的抽象数据类型定义：</p>
<p>ADT 线性表 （list）<br>Data 线性表的数据对象集合为{a1,a2,a3,a4…,an}，每个元素的类型均为DataType。其中，除了第一各元素a1以为每个元素有且只有一个直接前驱元素，除了最后一个元素an以外，每个元素有且只有一个直接后继元素。数据元素之间的关系是一对的关系。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADT List&#123;</span><br><span class="line">   数据对象：D=&#123;ai | ai属于Elemset,(i=<span class="number">1</span>,<span class="number">2</span>,...,n,n&gt;=<span class="number">0</span>)&#125;</span><br><span class="line">   数据关系：R=&#123;&lt;ai<span class="number">-1</span> ai&gt; | ai<span class="number">-1</span> ai 属于D，(i=<span class="number">2</span>,<span class="number">3</span>,...,n)&#125;</span><br><span class="line">   基本操作：</span><br><span class="line">InitList（*L）：         <span class="comment">//初始化操作，生成一个空的线性表L。</span></span><br><span class="line">ListEmpty（L）：         <span class="comment">//判断是否为空表，如果是就返回ture，如果不是就返回lfalse。</span></span><br><span class="line">ClearList（*L）：        <span class="comment">//将线性表清空。</span></span><br><span class="line">GetElem（L,i,*e）：      <span class="comment">//将线性表L中的第i个节未知元素值返回给e。</span></span><br><span class="line">LocateElem（L,e）：      <span class="comment">//在线性表中查找与给定值e相等的元素，如果查找成功，返回元素在表中的序号表示成功；否则返回0表示失败。</span></span><br><span class="line">ListInsert（*L，i，e）： <span class="comment">//在线性表L中第i个位置插入新的元素e。</span></span><br><span class="line">ListDelete（*L，i，*e）：<span class="comment">//删除线性表L中第i个位置元素，并返回其值给e。</span></span><br><span class="line">Listlength（L）：        <span class="comment">//返回线性表L的元素个数。</span></span><br><span class="line">TraverseList (L) :      <span class="comment">//遍历线性表，在遍历过程中对L的每个节点只访问一次。</span></span><br><span class="line">NextElme (L,cur_e,&amp;next_e): <span class="comment">//若cur_e是线性表的数据元素，而且不是最后一个，则用next_e返回其后继，否则操作失败，next_e无定义。</span></span><br><span class="line">PriorElme (L,cur_e,&amp;pre_e): <span class="comment">//若cur_e是线性表的数据元素，而且不是第一个，则用pre_e返回其后继，否则操作失败，pre_e无定义。</span></span><br><span class="line"></span><br><span class="line">&#125;ADT List</span><br></pre></td></tr></table></figure>

<h2 id="2-4-线性表的顺序表示和实现"><a href="#2-4-线性表的顺序表示和实现" class="headerlink" title="2.4 线性表的顺序表示和实现"></a>2.4 线性表的顺序表示和实现</h2><h3 id="2-4-1-线性表的顺序存储表示"><a href="#2-4-1-线性表的顺序存储表示" class="headerlink" title="2.4.1 线性表的顺序存储表示"></a>2.4.1 线性表的顺序存储表示</h3><p>顺序表示：用一组地址连续的存储单元依次存储线性表的数据结构。也称为线性表的顺序存储结构或顺序映像。</p>
<p>顺序表:存储这种结构的线性表。用一组地址连续的存储单元依次存储线性表的数据元素，是一种随机存取的存储结构。</p>
<p>特点：逻辑上相邻，物理次序也相邻。</p>
<p>线性表顺序存储的结构是一种随机存取的结构。</p>
<p>地址连续才是，地址不连续不是线性存储结构。</p>
<blockquote>
<p>如果每个元素占用8存储单元，ai位置是2000单元。则$a_{i+1}$的存储位置是2008单元。</p>
</blockquote>
<p>一般来说，线性表的第i个数据元素ai的存储位置为：</p>
<p>$LOC(a_i) = LOC(a_1)+(i-1)*l$</p>
<p>其中LOC(a0)表示的是第一个数据元素的存储位置，通常称为线性表的起始位置或者基地址。代表的时每个数据元素需要占用l个存储单元。</p>
<p>a1的存储位置，也称为基地址或者首地址。</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20220705115700779.png" alt="image-20220705115700779"></p>
<p>顺序表(元素):地址连续、依次存放、随机存取、类型相同-&gt;数组元素，用一维数组表示顺序表。数组长度不可变，线性表长可变。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INIT_SIZE 100 <span class="comment">//线性表存储空间的初始分配两</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType elem[LIST_INIT_SIZE];</span><br><span class="line">    <span class="type">int</span> length;<span class="comment">//当前长度</span></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>

<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20220705120635287.png" alt="image-20220705120635287"></p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20220705120704955.png" alt="image-20220705120704955"></p>
<h4 id="类C语言补充"><a href="#类C语言补充" class="headerlink" title="类C语言补充"></a>类C语言补充</h4><p>顺序表类型定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INIT_SIZE 100 <span class="comment">//线性表存储空间的初始分配两</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="type">int</span> length;<span class="comment">//当前长度</span></span><br><span class="line">&#125;SqList;<span class="comment">//顺序表类型</span></span><br></pre></td></tr></table></figure>

<p>数组静态分配定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;SqList;<span class="comment">//顺序表类型</span></span><br></pre></td></tr></table></figure>

<p>数组动态分配定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType *data;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;SqList;<span class="comment">//顺序表类型</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SqList L;</span><br><span class="line">L.data=(ElemType*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElemType)*MaxSize);</span><br></pre></td></tr></table></figure>

<p>malloc(m)函数：开辟m字节长度的地址空间，并返回这段空间的首地址。</p>
<p>sizeof(x)运算：计算变量x的长度。</p>
<p>free(p)函数：释放指针p所指变量的存储空间，即彻底删除一个变量。</p>
<p>需要头文件：&lt;stdlib.h&gt;</p>
<p><strong>C++动态存储分配</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">new 类型名T(初值列表)</span><br><span class="line">    功能：申请用于存放T类型对象的内存空间，并依初值列表赋以初值。</span><br><span class="line">    成功：T类型的指针，指向新分配的内存。</span><br><span class="line">    失败：<span class="number">0</span>(<span class="literal">NULL</span>)</span><br><span class="line">    </span><br><span class="line">delete 指针P</span><br><span class="line">功能：</span><br><span class="line">    释放指针P所指向的内存。P必须是new操作的返回值。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int *p1=new int;</span><br><span class="line">int *p1=new int(10);</span><br></pre></td></tr></table></figure>

<p><strong>C++中的参数传递</strong></p>
<ul>
<li>函数调用时传送给形参表的实参必须与形参三个一致：类型、个数、顺序。</li>
<li>参数传递有两种方式<ul>
<li>传值方式(参数为整型、实型、字符型等)</li>
<li>传地址<ul>
<li>参数为指针变量</li>
<li>参数为引用类型</li>
<li>参数为数组名</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>传值方式</strong></p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20220705143628095.png" alt="image-20220705143628095"></p>
<p><strong>传地址方式 - 指针变量作参数</strong></p>
<p>形参变化影响实参</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20220705143712169.png" alt="image-20220705143712169"></p>
<p><strong>传地址方式 - 数组名作参数</strong></p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20220705143828947.png" alt="image-20220705143828947"></p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20220705143901875.png" alt="image-20220705143901875"></p>
<p><strong>传地址方式 - 引用类型作参数</strong></p>
<p>什么是引用？它用来给一个对象提供一个替代的名字。</p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20220705144006345.png" alt="image-20220705144006345"></p>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20220705150920950.png" alt="image-20220705150920950"></p>
<p>(1）传递引用给函数与传递指针的效果是一样的，形参变化实参也发生变化。</p>
<p>(2）引用类型作形参，在内存中并没有产生实参的副本，它直接对实参操作;而一般变量作参数，形参与实参就占用不同的存储单元，所以形参变量的值是实参变量的副本。因此，当参数传递的数据量较大时，用引用比用一般变量传递参数的时间和空间效率都好。</p>
<p>(3指针参数虽然也能达到与使用引用的效果，但在被调函数中需要重复使用“*指针变量名”的形式进行运算，这很容易产生错误且程序的阅读性较差;另一方面，在主调函数的调用点处，必须用变量的地址作为实参。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>专业基础</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>C_Primer_Plus课后练习题集合</title>
    <url>/undefined/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/c-primer-plus%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0%E9%A2%98%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<p>C Primer Plus的复盘学习。<br>以下是书本课后编程练习的源代码。<br>编译链接环境：Visual Studio 2019 / Visual Studio Code / Dev C++</p>
<span id="more"></span>
<h1 id="chapter1"><a href="#chapter1" class="headerlink" title="chapter1"></a>chapter1</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    int b;</span><br><span class="line">    scanf(&quot;请输入一个数字，将其转换成英寸:%d&quot;, &amp;a);</span><br><span class="line">    b = 2.54 * a;</span><br><span class="line">    printf(&quot;%d&quot;, b);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="chapter2"><a href="#chapter2" class="headerlink" title="chapter2"></a>chapter2</h1><ol>
<li>2.12.1<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">void p1_1(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Jimmy Chen\n&quot;);</span><br><span class="line">    printf(&quot;Jimmy\nChen\n&quot;);</span><br><span class="line">    printf(&quot;Jimmy&quot;);</span><br><span class="line">    printf(&quot; Chen\n&quot;);</span><br><span class="line"></span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    p1_1();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
结果：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Jimmy Chen</span><br><span class="line">Jimmy</span><br><span class="line">Chen</span><br><span class="line">Jimmy Chen</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<ol start="2">
<li>2.12.2<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">void p1_2(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Name:nono\n&quot;);</span><br><span class="line">    printf(&quot;Addr:Zhejiang province, China\n&quot;);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    p1_2();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
结果：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Name:nono</span><br><span class="line">Addr:Zhejiang province, China</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<ol start="3">
<li>2.12.3<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">void p1_3(void)</span><br><span class="line">&#123;</span><br><span class="line">    int years_old = 0;</span><br><span class="line">    int live_days = 0;</span><br><span class="line">    printf(&quot;请输入您的年龄:&quot;);</span><br><span class="line">    scanf_s(&quot;%d&quot;, &amp;years_old);</span><br><span class="line">    getchar(); // 删除输入缓冲区中的回车键</span><br><span class="line">    live_days = years_old * 356;</span><br><span class="line"></span><br><span class="line">    printf(&quot;转换为天数是:%d\n&quot;, live_days);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    p1_3();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请输入您的年龄：20</span><br><span class="line">转换为天数是:7120</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<ol start="4">
<li>2.12.4<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">void jolly(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;For he&#x27;s a jolly good fellow!\n&quot;);</span><br><span class="line">    printf(&quot;For he&#x27;s a jolly good fellow!\n&quot;);</span><br><span class="line">    printf(&quot;For he&#x27;s a jolly good fellow!\n&quot;);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void deny(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Which nobody can deny!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void p1_4(void)</span><br><span class="line">&#123;</span><br><span class="line">    jolly();</span><br><span class="line">    deny();</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    p1_4();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For he&#x27;s a jolly good fellow!</span><br><span class="line">For he&#x27;s a jolly good fellow!</span><br><span class="line">For he&#x27;s a jolly good fellow!</span><br><span class="line">Which nobody can deny!</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<ol start="5">
<li>2.12.5<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">void br(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Brazil, Russia&quot;);</span><br><span class="line"></span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ic(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;India, China&quot;);</span><br><span class="line"></span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void p1_5(void)</span><br><span class="line">&#123;</span><br><span class="line">    br();</span><br><span class="line">    printf(&quot;, &quot;);</span><br><span class="line">    ic();</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    ic();</span><br><span class="line">    printf(&quot;,\n&quot;);</span><br><span class="line">    br();</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    p1_5();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Brazil, Russia, India, China</span><br><span class="line">India, China,</span><br><span class="line">Brazil, Russia</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<ol start="6">
<li>2.12.6<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">void p1_6(void)</span><br><span class="line">&#123;</span><br><span class="line">    int toes = 10;</span><br><span class="line">    int double_toes = toes * 2;</span><br><span class="line">    int square_toes = toes * toes;</span><br><span class="line"></span><br><span class="line">    printf(&quot;the value of toes is : %d\n&quot;, toes);</span><br><span class="line">    printf(&quot;the value of double toes is : %d\n&quot;, double_toes);</span><br><span class="line">    printf(&quot;the value of square toes is : %d\n&quot;, square_toes);</span><br><span class="line"></span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    p1_6();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">the value of toes is : 10</span><br><span class="line">the value of double toes is : 20</span><br><span class="line">the value of square toes is : 100</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<ol start="7">
<li>2.12.7<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">void smile(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Smile!&quot;);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void p1_7(void)</span><br><span class="line">&#123;</span><br><span class="line">    smile(); smile(); smile(); printf(&quot;\n&quot;);</span><br><span class="line">    smile(); smile(); printf(&quot;\n&quot;);</span><br><span class="line">    smile(); printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    p1_7();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Smile!Smile!Smile!</span><br><span class="line">Smile!Smile!</span><br><span class="line">Smile!</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<ol start="8">
<li>2.12.8<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">void two(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;two\n&quot;);</span><br><span class="line"></span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void p1_8(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;starting now:\n&quot;);</span><br><span class="line">    printf(&quot;one\n&quot;);</span><br><span class="line">    two();</span><br><span class="line">    printf(&quot;three\n&quot;);</span><br><span class="line">    printf(&quot;done!\n&quot;);</span><br><span class="line"></span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    p1_8();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">starting now:</span><br><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br><span class="line">done!</span><br></pre></td></tr></table></figure>
<h1 id="chapter3"><a href="#chapter3" class="headerlink" title="chapter3"></a>chapter3</h1></li>
<li>3.11.2<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void p2_(void)</span><br><span class="line">&#123;</span><br><span class="line">    int ch = 0;</span><br><span class="line">    printf(&quot;please input the value of ascii:&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;ch);</span><br><span class="line"> </span><br><span class="line">    getchar(); // 删除输入缓冲区中的回车键</span><br><span class="line"> </span><br><span class="line">    printf(&quot;the value of ascii : %d\n&quot;, ch);</span><br><span class="line">    printf(&quot;the character : %c\n&quot;, (char)ch);</span><br><span class="line"> </span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	p2_();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
结果：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">please input the value of ascii:66</span><br><span class="line">the value of ascii : 66</span><br><span class="line">the character : B</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<ol start="2">
<li>3.11.3<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void p3_(void)</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;\a&quot;);</span><br><span class="line">    printf(&quot;Startled by the sudden sound, sally shouted,\n\&quot;By the Great Pumpkin, what was that!\&quot;&quot;);</span><br><span class="line"> </span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	p3_();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
结果：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">please input the value of ascii:66</span><br><span class="line">the value of ascii : 66</span><br><span class="line">the character : B</span><br></pre></td></tr></table></figure></li>
<li>3.11.4<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">void p2_4(void)</span><br><span class="line">&#123;</span><br><span class="line">    float input = 0.0;</span><br><span class="line">    printf(&quot;Enter a floating-point value:&quot;);</span><br><span class="line">    scanf(&quot;%f&quot;, &amp;input);</span><br><span class="line"> </span><br><span class="line">    getchar();</span><br><span class="line"> </span><br><span class="line">    printf(&quot;fixed-point notation:%f\n&quot;, input);</span><br><span class="line">    printf(&quot;exponential notation:%e\n&quot;, input);</span><br><span class="line">    printf(&quot;p notation:%a\n&quot;, input);</span><br><span class="line"> </span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    p2_4();</span><br><span class="line">    getchar();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
结果：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Enter a floating-point value:62.5</span><br><span class="line">fixed-point notation:62.500000</span><br><span class="line">exponential notation:6.250000e+001</span><br><span class="line">p notation:0x1.f40000p+5</span><br></pre></td></tr></table></figure></li>
<li>3.11.5<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">void p2_4(void)</span><br><span class="line">&#123;</span><br><span class="line">    float input = 0.0;</span><br><span class="line">    printf(&quot;Enter a floating-point value:&quot;);</span><br><span class="line">    scanf(&quot;%f&quot;, &amp;input);</span><br><span class="line"> </span><br><span class="line">    getchar();</span><br><span class="line"> </span><br><span class="line">    printf(&quot;fixed-point notation:%f\n&quot;, input);</span><br><span class="line">    printf(&quot;exponential notation:%e\n&quot;, input);</span><br><span class="line">    printf(&quot;p notation:%a\n&quot;, input);</span><br><span class="line"> </span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    p2_4();</span><br><span class="line">    getchar();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
结果：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Enter a floating-point value:62.5</span><br><span class="line">fixed-point notation:62.500000</span><br><span class="line">exponential notation:6.250000e+001</span><br><span class="line">p notation:0x1.f40000p+5</span><br></pre></td></tr></table></figure></li>
<li>3.11.6<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define QUALITY_OF_WATER_MOLECULE (3.0e-23)</span><br><span class="line">#define NUM_OF_WATER_MOLECULE_PER_QUART (950/QUALITY_OF_WATER_MOLECULE)</span><br><span class="line"> </span><br><span class="line">void p2_6(void)</span><br><span class="line">&#123;</span><br><span class="line">    double num_of_quart = 0;</span><br><span class="line">    printf(&quot;How much quart of water:&quot;);</span><br><span class="line">    scanf(&quot;%lf&quot;, &amp;num_of_quart);</span><br><span class="line">    getchar();</span><br><span class="line"> </span><br><span class="line">    double num_of_water_molecule = num_of_quart * NUM_OF_WATER_MOLECULE_PER_QUART;</span><br><span class="line">    printf(&quot;there are %0.2f quart water and %le water molecule&quot;, num_of_quart, num_of_water_molecule);</span><br><span class="line"> </span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    p2_6();</span><br><span class="line">    getchar();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
结果：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">How much quart of water:5</span><br><span class="line">there are 5.00 quart water and 1.583333e+026 water molecule</span><br></pre></td></tr></table></figure></li>
<li>3.11.7<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define CM_PER_INCH (2.54)</span><br><span class="line"> </span><br><span class="line">void p2_7(void)</span><br><span class="line">&#123;</span><br><span class="line">    float height_in_inch = 0;</span><br><span class="line">    float height_in_cm = 0;</span><br><span class="line">    printf(&quot;What&#x27;s your height in inch:&quot;);</span><br><span class="line">    scanf_s(&quot;%f&quot;, &amp;height_in_inch);</span><br><span class="line">    getchar();</span><br><span class="line"> </span><br><span class="line">    height_in_cm = height_in_inch * CM_PER_INCH;</span><br><span class="line">    printf(&quot;Your height is %f in cm\n&quot;, height_in_cm);</span><br><span class="line"> </span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    p2_7();</span><br><span class="line">    getchar();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
结果：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">What&#x27;s your height in inch:70</span><br><span class="line">Your height is 177.800003 in cm</span><br></pre></td></tr></table></figure></li>
<li>3.11.8<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define CUPS_PER_PINT (2)</span><br><span class="line">#define OUNCES_PER_CUP (8)</span><br><span class="line">#define BIG_SPOONS_PER_OUNCE (2)</span><br><span class="line">#define TEA_SPIINS_PER_BIG_SPOON (3)</span><br><span class="line"> </span><br><span class="line">void p2_8(void)</span><br><span class="line">&#123;</span><br><span class="line">    float cups = 0;</span><br><span class="line">    float pints = 0;</span><br><span class="line">    float ounces = 0;</span><br><span class="line">    float big_spoons = 0;</span><br><span class="line">    float tea_spoons = 0;</span><br><span class="line"> </span><br><span class="line">    printf(&quot;How many cups of tea do you want:&quot;);</span><br><span class="line">    scanf(&quot;%f&quot;, &amp;cups);</span><br><span class="line">    getchar();</span><br><span class="line">    pints = cups / CUPS_PER_PINT;</span><br><span class="line">    ounces = cups * OUNCES_PER_CUP;</span><br><span class="line">    big_spoons = ounces * BIG_SPOONS_PER_OUNCE;</span><br><span class="line">    tea_spoons = big_spoons * TEA_SPIINS_PER_BIG_SPOON;</span><br><span class="line"> </span><br><span class="line">    printf(&quot;pints:%f, cups:%f, ounces:%f, big_spoons:%f, tea_spoons:%f\n&quot;, pints, cups, ounces, big_spoons, tea_spoons);</span><br><span class="line">    return;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    p2_8();</span><br><span class="line">    getchar();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
结果：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">How many cups of tea do you want:1</span><br><span class="line">pints:0.500000, cups:1.000000, ounces:8.000000, big_spoons:16.000000, tea_spoons:48.000000</span><br></pre></td></tr></table></figure>
<h1 id="chapter-4"><a href="#chapter-4" class="headerlink" title="chapter 4"></a>chapter 4</h1></li>
<li>4.8.1<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;float.h&gt;</span><br><span class="line"> </span><br><span class="line">/************************************************************************/</span><br><span class="line">/* practice 1                                                                     */</span><br><span class="line">/************************************************************************/</span><br><span class="line">void p4_1(void)</span><br><span class="line">&#123;</span><br><span class="line">    char first_name[40];</span><br><span class="line">    char last_name[40];</span><br><span class="line">    printf(&quot;What&#x27;s your first name:&quot;);</span><br><span class="line">    scanf(&quot;%s&quot;, first_name);</span><br><span class="line"> </span><br><span class="line">    printf(&quot;What&#x27;s your last name:&quot;);</span><br><span class="line">    scanf(&quot;%s&quot;, last_name);</span><br><span class="line"> </span><br><span class="line">    getchar();</span><br><span class="line"> </span><br><span class="line">    printf(&quot;%*s,%*s\n&quot;, 10, first_name, 10, last_name);</span><br><span class="line"> </span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    p4_1();</span><br><span class="line"> </span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
结果：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">What&#x27;s your first name:nono</span><br><span class="line">What&#x27;s your last name:aristo</span><br><span class="line">      nono,    aristo</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<ol start="2">
<li>4.8.2<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;float.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">void p4_2(void)</span><br><span class="line">&#123;</span><br><span class="line">    char first_name[40];</span><br><span class="line">    char last_name[40];</span><br><span class="line">    int first_name_length = 0;</span><br><span class="line">    int last_name_lenght = 0;</span><br><span class="line">    printf(&quot;What&#x27;s your first name:&quot;);</span><br><span class="line">    scanf(&quot;%s&quot;, first_name);</span><br><span class="line"> </span><br><span class="line">    printf(&quot;What&#x27;s your last name:&quot;);</span><br><span class="line">    scanf(&quot;%s&quot;, last_name);</span><br><span class="line"> </span><br><span class="line">    getchar();</span><br><span class="line"> </span><br><span class="line">    first_name_length = strlen(first_name);</span><br><span class="line">    last_name_lenght = strlen(last_name);</span><br><span class="line"> </span><br><span class="line">    printf(&quot;a.\&quot;%s,%s\&quot;\n&quot;, first_name, last_name);</span><br><span class="line">    printf(&quot;b.\&quot;%20s,%20s\&quot;\n&quot;, first_name, last_name);</span><br><span class="line">    printf(&quot;c.\&quot;%-20s,%-20s\&quot;\n&quot;, first_name, last_name);</span><br><span class="line">    printf(&quot;d.%*s,%*s\n&quot;, first_name_length+3, first_name, last_name_lenght+3, last_name);</span><br><span class="line"> </span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    p4_2();</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
结果：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">What&#x27;s your first name:nono</span><br><span class="line">What&#x27;s your last name:ken</span><br><span class="line">a.&quot;nono,ken&quot;</span><br><span class="line">b.&quot;                nono,                 ken&quot;</span><br><span class="line">c.&quot;nono                ,ken                 &quot;</span><br><span class="line">d.   nono,   ken</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<ol start="3">
<li>4.8.3<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">void p4_3(void)</span><br><span class="line">&#123;</span><br><span class="line">    double input = 0.0;</span><br><span class="line">    printf(&quot;please input the float number:&quot;);</span><br><span class="line">    scanf(&quot;%lf&quot;, &amp;input);</span><br><span class="line">    getchar();</span><br><span class="line"> </span><br><span class="line">    printf(&quot;%lf\n&quot;, input);</span><br><span class="line">    printf(&quot;%e\n&quot;, input);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    p4_3();</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">please input the float number:10.5</span><br><span class="line">10.500000</span><br><span class="line">1.050000e+001</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<ol start="4">
<li>4.8.4<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#define CM_PER_INCH (2.54)</span><br><span class="line">void p4_4(void)</span><br><span class="line">&#123;</span><br><span class="line">    float height_inch = 0;</span><br><span class="line">    float height_cm = 0;</span><br><span class="line">    printf(&quot;What&#x27;s your height:&quot;);</span><br><span class="line">    scanf(&quot;%f&quot;, &amp;height_inch);</span><br><span class="line">    getchar();</span><br><span class="line"> </span><br><span class="line">    printf(&quot;Dabney, you are %f feet tall\n&quot;, height_inch);</span><br><span class="line">    height_cm = height_inch * CM_PER_INCH;</span><br><span class="line">    printf(&quot;Dabney, you are %f cm tall\n&quot;, height_cm);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    p4_4();</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">What&#x27;s your height:70</span><br><span class="line">Dabney, you are 70.000000 feet tall</span><br><span class="line">Dabney, you are 177.800003 cm tall</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<ol start="5">
<li>4.8.5<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">void br(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Brazil, Russia&quot;);</span><br><span class="line"></span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ic(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;India, China&quot;);</span><br><span class="line"></span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void p1_5(void)</span><br><span class="line">&#123;</span><br><span class="line">    br();</span><br><span class="line">    printf(&quot;, &quot;);</span><br><span class="line">    ic();</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    ic();</span><br><span class="line">    printf(&quot;,\n&quot;);</span><br><span class="line">    br();</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    p1_5();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Brazil, Russia, India, China</span><br><span class="line">India, China,</span><br><span class="line">Brazil, Russia</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<ol start="6">
<li>4.8.6<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">void p4_6(void)</span><br><span class="line">&#123;</span><br><span class="line">    char first_name[40] = &#123; 0 &#125;;</span><br><span class="line">    char last_name[40] = &#123; 0 &#125;;</span><br><span class="line">    int first_name_length = 0;</span><br><span class="line">    int last_name_length = 0;</span><br><span class="line"> </span><br><span class="line">    printf(&quot;What&#x27;s your first name:&quot;);</span><br><span class="line">    scanf(&quot;%s&quot;, first_name);</span><br><span class="line">    getchar();</span><br><span class="line"> </span><br><span class="line">    printf(&quot;What&#x27;s your last name:&quot;);</span><br><span class="line">    scanf(&quot;%s&quot;, last_name);</span><br><span class="line">    getchar();</span><br><span class="line"> </span><br><span class="line">    first_name_length = strlen(first_name);</span><br><span class="line">    last_name_length = strlen(last_name);</span><br><span class="line"> </span><br><span class="line">    printf(&quot;%s %s\n&quot;, first_name, last_name);</span><br><span class="line">    printf(&quot;%*d %*d\n&quot;, first_name_length, first_name_length, last_name_length, last_name_length);</span><br><span class="line"> </span><br><span class="line">    printf(&quot;%s %s\n&quot;, first_name, last_name);</span><br><span class="line">    printf(&quot;%-*d %-*d\n&quot;, first_name_length, first_name_length, last_name_length, last_name_length);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    p4_6();</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">What&#x27;s your first name:ken</span><br><span class="line">What&#x27;s your last name:froid</span><br><span class="line">ken froid</span><br><span class="line">  3     5</span><br><span class="line">ken froid</span><br><span class="line">3   5</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<ol start="7">
<li>4.12.7<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#define FLT_DIG 1.0/3.0</span><br><span class="line">#define DBL_DIG 1.0/3.0</span><br><span class="line">void p4_7(void)</span><br><span class="line">&#123;</span><br><span class="line">    double d_value = 1.0 / 3.0;</span><br><span class="line">    float f_value = 1.0 / 3.0;</span><br><span class="line"> </span><br><span class="line">    printf(&quot;the value of FLT_DIG:%d, the value of DBL_DIG:%d\n&quot;, FLT_DIG, DBL_DIG);</span><br><span class="line">    printf(&quot;the value of double:%.6lf, the value of float:%.6lf\n&quot;, d_value, f_value);</span><br><span class="line">    printf(&quot;the value of double:%.12lf, the value of float:%.12lf\n&quot;, d_value, f_value);</span><br><span class="line">    printf(&quot;the value of double:%.18lf, the value of float:%.18lf\n&quot;, d_value, f_value);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    p4_7();</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">the value of FLT_DIG:1431655765, the value of DBL_DIG:1431655765</span><br><span class="line">the value of double:0.333333, the value of float:0.333333</span><br><span class="line">the value of double:0.333333333333, the value of float:0.333333343267</span><br><span class="line">the value of double:0.333333333333333310, the value of float:0.333333343267440800</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<ol start="8">
<li>4.12.8<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#define KM_PER_MILE (1.609)</span><br><span class="line">#define PINT_PER_GALLON (3.785)</span><br><span class="line">void p4_8(void)</span><br><span class="line">&#123;</span><br><span class="line">    float driven_distance = 0.0;</span><br><span class="line">    float gas_consumption = 0.0;</span><br><span class="line">    float pint_per_hundred_km = 0.0;</span><br><span class="line">    float mile_per_gallon = 0.0;</span><br><span class="line">    printf(&quot;How much distance have you traveled in kilometer:&quot;);</span><br><span class="line">    scanf(&quot;%f&quot;, &amp;driven_distance);</span><br><span class="line">    getchar();</span><br><span class="line"> </span><br><span class="line">    printf(&quot;How much gas have you used in pint:&quot;);</span><br><span class="line">    scanf(&quot;%f&quot;, &amp;gas_consumption);</span><br><span class="line">    getchar();</span><br><span class="line"> </span><br><span class="line">    pint_per_hundred_km = gas_consumption / driven_distance * 100;</span><br><span class="line">    mile_per_gallon = (driven_distance / KM_PER_MILE) / (gas_consumption / PINT_PER_GALLON);</span><br><span class="line"> </span><br><span class="line">    printf(&quot;Fuel consumptions:%f pint/100km or %f mile/gallon\n&quot;, pint_per_hundred_km, mile_per_gallon);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    p4_8();</span><br><span class="line"> </span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">How much distance have you traveled in kilometer:1000</span><br><span class="line">How much gas have you used in pint:10</span><br><span class="line">Fuel consumptions:1.000000 pint/100km or 235.239273 mile/gallon</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="chapter-5"><a href="#chapter-5" class="headerlink" title="chapter 5"></a>chapter 5</h1><ol>
<li>5.11.1<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#define SECONDS_PER_MINUTE (60)</span><br><span class="line">void p5_1(void)</span><br><span class="line">&#123;</span><br><span class="line">    float hours = 0;</span><br><span class="line">    int minutes = 0;</span><br><span class="line">    int seconds = 0;</span><br><span class="line">    printf(&quot;please input the number of minutes(&lt;= 0 to quit):&quot;);</span><br><span class="line">    scanf_s(&quot;%d&quot;, &amp;minutes);</span><br><span class="line"> </span><br><span class="line">    while (minutes &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        getchar();</span><br><span class="line">        hours = (float)minutes / SECONDS_PER_MINUTE;</span><br><span class="line">        seconds = minutes * SECONDS_PER_MINUTE;</span><br><span class="line">        printf(&quot;%d minute = %f hours or %d seconds\n&quot;, minutes, hours, seconds);</span><br><span class="line">        printf(&quot;please input the number of minutes(&lt;= 0 to quit):&quot;);</span><br><span class="line">        scanf_s(&quot;%d&quot;, &amp;minutes);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    p5_1();</span><br><span class="line">    getchar();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br></pre></td></tr></table></figure>
结果：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">please input the number of minutes(&lt;= 0 to quit):60</span><br><span class="line">60 minute = 1.000000 hours or 3600 seconds</span><br><span class="line">please input the number of minutes(&lt;= 0 to quit):</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<ol start="2">
<li>5.11.2<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">void p5_2(void)</span><br><span class="line">&#123;</span><br><span class="line">    int input_num = 0;</span><br><span class="line">    printf(&quot;please enter an integer:&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;input_num);</span><br><span class="line">    getchar();</span><br><span class="line"> </span><br><span class="line">    printf(&quot;the ten integers after %d are:&quot;, input_num);</span><br><span class="line">    for (int i = 0; i &lt;= 10; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d &quot;, (input_num + i));</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"> </span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    p5_2();</span><br><span class="line">    getchar();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
结果：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">please enter an integer:5</span><br><span class="line">the ten integers after 5 are:5 6 7 8 9 10 11 12 13 14 15</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<ol start="3">
<li>5.11.3<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">const int DAY_PER_WEEK = 7;</span><br><span class="line">void p5_3(void)</span><br><span class="line">&#123;</span><br><span class="line">    int days = 0;</span><br><span class="line">    int weeks = 0;</span><br><span class="line">    int remain_day = 0;</span><br><span class="line"> </span><br><span class="line">    printf(&quot;please input the number of day:&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;days);</span><br><span class="line">    getchar();</span><br><span class="line"> </span><br><span class="line">    weeks = days / DAY_PER_WEEK;</span><br><span class="line">    remain_day = days % DAY_PER_WEEK;</span><br><span class="line">    printf(&quot;%d days are %d weeks, %d days\n&quot;, days, weeks, remain_day);</span><br><span class="line"> </span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    p5_3();</span><br><span class="line">    getchar();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">please input the number of day:30</span><br><span class="line">30 days are 4 weeks, 2 days</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<ol start="4">
<li>5.11.4<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">const float CM_PER_INCH = 2.54f;</span><br><span class="line">const float CM_PER_FEET = 30.38f;</span><br><span class="line">void p5_4(void)</span><br><span class="line">&#123;</span><br><span class="line">    float height_cm = 0;</span><br><span class="line">    int height_feet = 0;</span><br><span class="line">    float height_inch = 0.0;</span><br><span class="line"> </span><br><span class="line">    printf(&quot;Enter a height in centimeters: &quot;);</span><br><span class="line">    scanf(&quot;%f&quot;, &amp;height_cm);</span><br><span class="line"> </span><br><span class="line">    while (height_cm &gt; 0) &#123;</span><br><span class="line">        getchar();</span><br><span class="line">        height_feet = (int)(height_cm / CM_PER_FEET);</span><br><span class="line">        height_inch = (height_cm - CM_PER_FEET * height_feet) / CM_PER_INCH;</span><br><span class="line">        printf(&quot;%.1f cm = %d feet, %.1f inches\n&quot;, height_cm, height_feet, height_inch);</span><br><span class="line"> </span><br><span class="line">        printf(&quot;Enter a height in centimeters(&lt;=0 to quit): &quot;);</span><br><span class="line">        scanf(&quot;%f&quot;, &amp;height_cm);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    p5_4();</span><br><span class="line">    getchar();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Enter a height in centimeters: 30</span><br><span class="line">30.0 cm = 0 feet, 11.8 inches</span><br><span class="line">Enter a height in centimeters(&lt;=0 to quit):</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<ol start="5">
<li>4.8.5<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">void br(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Brazil, Russia&quot;);</span><br><span class="line"></span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ic(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;India, China&quot;);</span><br><span class="line"></span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void p1_5(void)</span><br><span class="line">&#123;</span><br><span class="line">    br();</span><br><span class="line">    printf(&quot;, &quot;);</span><br><span class="line">    ic();</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    ic();</span><br><span class="line">    printf(&quot;,\n&quot;);</span><br><span class="line">    br();</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    p1_5();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Brazil, Russia, India, China</span><br><span class="line">India, China,</span><br><span class="line">Brazil, Russia</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<ol start="6">
<li>4.8.6<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">void p4_6(void)</span><br><span class="line">&#123;</span><br><span class="line">    char first_name[40] = &#123; 0 &#125;;</span><br><span class="line">    char last_name[40] = &#123; 0 &#125;;</span><br><span class="line">    int first_name_length = 0;</span><br><span class="line">    int last_name_length = 0;</span><br><span class="line"> </span><br><span class="line">    printf(&quot;What&#x27;s your first name:&quot;);</span><br><span class="line">    scanf(&quot;%s&quot;, first_name);</span><br><span class="line">    getchar();</span><br><span class="line"> </span><br><span class="line">    printf(&quot;What&#x27;s your last name:&quot;);</span><br><span class="line">    scanf(&quot;%s&quot;, last_name);</span><br><span class="line">    getchar();</span><br><span class="line"> </span><br><span class="line">    first_name_length = strlen(first_name);</span><br><span class="line">    last_name_length = strlen(last_name);</span><br><span class="line"> </span><br><span class="line">    printf(&quot;%s %s\n&quot;, first_name, last_name);</span><br><span class="line">    printf(&quot;%*d %*d\n&quot;, first_name_length, first_name_length, last_name_length, last_name_length);</span><br><span class="line"> </span><br><span class="line">    printf(&quot;%s %s\n&quot;, first_name, last_name);</span><br><span class="line">    printf(&quot;%-*d %-*d\n&quot;, first_name_length, first_name_length, last_name_length, last_name_length);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    p4_6();</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">What&#x27;s your first name:ken</span><br><span class="line">What&#x27;s your last name:froid</span><br><span class="line">ken froid</span><br><span class="line">  3     5</span><br><span class="line">ken froid</span><br><span class="line">3   5</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<ol start="7">
<li>4.12.7<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#define FLT_DIG 1.0/3.0</span><br><span class="line">#define DBL_DIG 1.0/3.0</span><br><span class="line">void p4_7(void)</span><br><span class="line">&#123;</span><br><span class="line">    double d_value = 1.0 / 3.0;</span><br><span class="line">    float f_value = 1.0 / 3.0;</span><br><span class="line"> </span><br><span class="line">    printf(&quot;the value of FLT_DIG:%d, the value of DBL_DIG:%d\n&quot;, FLT_DIG, DBL_DIG);</span><br><span class="line">    printf(&quot;the value of double:%.6lf, the value of float:%.6lf\n&quot;, d_value, f_value);</span><br><span class="line">    printf(&quot;the value of double:%.12lf, the value of float:%.12lf\n&quot;, d_value, f_value);</span><br><span class="line">    printf(&quot;the value of double:%.18lf, the value of float:%.18lf\n&quot;, d_value, f_value);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    p4_7();</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">the value of FLT_DIG:1431655765, the value of DBL_DIG:1431655765</span><br><span class="line">the value of double:0.333333, the value of float:0.333333</span><br><span class="line">the value of double:0.333333333333, the value of float:0.333333343267</span><br><span class="line">the value of double:0.333333333333333310, the value of float:0.333333343267440800</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<ol start="8">
<li>4.12.8<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#define KM_PER_MILE (1.609)</span><br><span class="line">#define PINT_PER_GALLON (3.785)</span><br><span class="line">void p4_8(void)</span><br><span class="line">&#123;</span><br><span class="line">    float driven_distance = 0.0;</span><br><span class="line">    float gas_consumption = 0.0;</span><br><span class="line">    float pint_per_hundred_km = 0.0;</span><br><span class="line">    float mile_per_gallon = 0.0;</span><br><span class="line">    printf(&quot;How much distance have you traveled in kilometer:&quot;);</span><br><span class="line">    scanf(&quot;%f&quot;, &amp;driven_distance);</span><br><span class="line">    getchar();</span><br><span class="line"> </span><br><span class="line">    printf(&quot;How much gas have you used in pint:&quot;);</span><br><span class="line">    scanf(&quot;%f&quot;, &amp;gas_consumption);</span><br><span class="line">    getchar();</span><br><span class="line"> </span><br><span class="line">    pint_per_hundred_km = gas_consumption / driven_distance * 100;</span><br><span class="line">    mile_per_gallon = (driven_distance / KM_PER_MILE) / (gas_consumption / PINT_PER_GALLON);</span><br><span class="line"> </span><br><span class="line">    printf(&quot;Fuel consumptions:%f pint/100km or %f mile/gallon\n&quot;, pint_per_hundred_km, mile_per_gallon);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    p4_8();</span><br><span class="line"> </span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">How much distance have you traveled in kilometer:1000</span><br><span class="line">How much gas have you used in pint:10</span><br><span class="line">Fuel consumptions:1.000000 pint/100km or 235.239273 mile/gallon</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
        <category>计算机语言</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo学习记录</title>
    <url>/undefined/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B7%A5%E5%85%B7/Hexo/hexo%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p><img src="/../img/TaylorSwift01.jpg" alt="Title"></p>
<blockquote>
<p>老婆镇楼</p>
</blockquote>
<h1 id="Hexo-amp-amp-Next的基本操作"><a href="#Hexo-amp-amp-Next的基本操作" class="headerlink" title="Hexo&amp;&amp;Next的基本操作"></a>Hexo&amp;&amp;Next的基本操作</h1><span id="more"></span>
<h2 id="几个资源网站"><a href="#几个资源网站" class="headerlink" title="几个资源网站"></a>几个资源网站</h2><p>在学习一个全新的东西之前，最好的学习方式其实是看<b>官方文档<b>。并且最好要熟悉源代码。以下是会用到的一些官方学习文档：<br>1.<a href="https://hexo.io/zh-cn/">hexo官网</a><br>2.<a href="https://www.izhaoo.com/2020/05/05/hexo-theme-zhaoo-doc/#%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85">主题配置详情</a></p>
<h2 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h2><blockquote>
<p>可参考的视频教程<br><a href="https://www.bilibili.com/video/BV1cW411A7Jx?p=9">手把手教你搭建属于自己的hexo+github博客</a></p>
</blockquote>
<h3 id="（一）使用Hexo-Pages搭建个人博客"><a href="#（一）使用Hexo-Pages搭建个人博客" class="headerlink" title="（一）使用Hexo+Pages搭建个人博客"></a>（一）使用Hexo+Pages搭建个人博客</h3><p>本篇主要介绍使用Hexo+Pages搭建个人博客的流程。使用 Hexo 博客框架搭建，解析markdown文章，生成静态页面，将页面托管到 github / coding 服务器上。github / coding 都有pages 服务，提供免费的静态网页托管和演示服务。</p>
<p>搭建步骤：</p>
<ol>
<li>安装git，nodejs</li>
<li>安装hexo</li>
<li>本地搭建站点（线下访问）</li>
<li>部署到github/coding（线上访问）</li>
<li>站点配置</li>
</ol>
<h4 id="1-安装hexo"><a href="#1-安装hexo" class="headerlink" title="1. 安装hexo"></a>1. 安装hexo</h4><p>1.安装Git。安装完毕后，在任意文件夹下鼠标右击即可打开<code>Git Bash</code>，输入命令，进行Git操作。<br><code>$ git version  # 查看Git版本，验证是否安装成功</code><br>2.安装Node.js。Hexo是基于nodejs的博客框架，而且nodejs还集成了npm包管理工具。<br><code>$ node -v    # 查看nodejs版本，验证是否安装成功</code><br>3.安装hexo：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm install hexo --save   # 安装hexo</span><br><span class="line">$ npm install hexo-cli -g   # 安装hexo命令行模式</span><br><span class="line">$ hexo -v  # 查看hexo版本，验证是否安装成功</span><br></pre></td></tr></table></figure>
<h4 id="2-建站"><a href="#2-建站" class="headerlink" title="2. 建站"></a>2. 建站</h4><p>1.新建一个blog文件夹，打开blog文件夹，<code>Git Bash</code>。<br>2.hexo初始化：<code>hexo init</code><br>3.安装依赖包：<code>npm install</code><br>4.初始化完成，在blog下就会生成以下文件目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── .deploy      # 执行hexo deploy命令部署到GitHub上的内容目录</span><br><span class="line">├── public       # 执行hexo generate命令，输出的静态网页内容目录</span><br><span class="line">├── node_modules # 依赖模块</span><br><span class="line">├── scaffolds    # layout模板文件目录，其中的md文件可以添加编辑</span><br><span class="line">├── source       # 用户源文件：页面，文章markdown文件。文章源码目录，该目录下的markdown和html文件均会被hexo处理。该页面对应repo的根目录，404文件、favicon.ico文件，CNAME文件等都应该放这里，该目录下可新建页面目录。</span><br><span class="line">|   └── _posts   # 创建的文章</span><br><span class="line">└── themes       # 主题</span><br><span class="line">├── .gitignore   # git忽略文件信息</span><br><span class="line">├── _config.yml  # 站点配置文件，大多数的设置都在这里</span><br><span class="line">├── package.json # 已安装插件映射表，下次只需npm install即直接安装表插件，指明hexo的版本等信息，类似于一般软件中的关于按钮</span><br></pre></td></tr></table></figure>
<p>NexT主题的目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── .github            #git信息</span><br><span class="line">├── languages          #多语言</span><br><span class="line">|   ├── default.yml    #默认语言</span><br><span class="line">|   └── zh-Hans.yml      #简体中文</span><br><span class="line">|   └── zh-tw.yml      #繁体中文</span><br><span class="line">├── layout             #布局，根目录下的*.ejs文件是对主页，分页，存档等的控制</span><br><span class="line">|   ├── _custom        #可以自己修改的模板，覆盖原有模板</span><br><span class="line">|   |   ├── _header.swig    #头部样式</span><br><span class="line">|   |   ├── _sidebar.swig   #侧边栏样式</span><br><span class="line">|   ├── _macro        #可以自己修改的模板，覆盖原有模板</span><br><span class="line">|   |   ├── post.swig    #文章模板</span><br><span class="line">|   |   ├── reward.swig    #打赏模板</span><br><span class="line">|   |   ├── sidebar.swig   #侧边栏模板</span><br><span class="line">|   ├── _partial       #局部的布局</span><br><span class="line">|   |   ├── head       #头部模板</span><br><span class="line">|   |   ├── search     #搜索模板</span><br><span class="line">|   |   ├── share      #分享模板</span><br><span class="line">|   ├── _script        #局部的布局</span><br><span class="line">|   ├── _third-party   #第三方模板</span><br><span class="line">|   ├── _layout.swig   #主页面模板</span><br><span class="line">|   ├── index.swig     #主页面模板</span><br><span class="line">|   ├── page           #页面模板</span><br><span class="line">|   └── tag.swig       #tag模板</span><br><span class="line">├── scripts            #script源码</span><br><span class="line">|   ├── tags           #tags的script源码</span><br><span class="line">|   ├── marge.js       #页面模板</span><br><span class="line">├── source             #源码</span><br><span class="line">|   ├── css            #css源码</span><br><span class="line">|   |   ├── _common    #*.styl基础css</span><br><span class="line">|   |   ├── _custom    #*.styl局部css</span><br><span class="line">|   |   └── _mixins    #mixins的css</span><br><span class="line">|   ├── fonts          #字体</span><br><span class="line">|   ├── images         #图片</span><br><span class="line">|   ├── uploads        #添加的文件</span><br><span class="line">|   └── js             #javascript源代码</span><br><span class="line">├── _config.yml        #主题配置文件</span><br><span class="line">└── README.md          #用GitHub的都知道</span><br></pre></td></tr></table></figure>
<p>5.hexo本地生成静态页面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo clean     # 清理本地静态文件；</span><br><span class="line">$ hexo generate  # 生成静态页面，即public文件夹；</span><br><span class="line">$ hexo deploy    # 部署页面</span><br><span class="line">$ hexo server    # 启用hexo本地服务器；</span><br><span class="line"># 注：Hexo 3.0 把服务器独立成了个别模块，您必须先安装 hexo-server 才能使用。</span><br><span class="line"># hexo-server安装命令：npm install hexo-server --save</span><br></pre></td></tr></table></figure>
<p>在cmd控制台命令中，跳转到你当前的文件目录下，输入<code>hexo s</code>，cmd会给出你的本地host网站，然后打开浏览器在地址栏输入<a href="http://localhost:****(你设置的端口，默认为4000)即可本地访问静态博客页面。">http://localhost:****(你设置的端口，默认为4000)即可本地访问静态博客页面。</a></p>
<h4 id="3-配置github-coding-pages"><a href="#3-配置github-coding-pages" class="headerlink" title="3. 配置github/coding pages"></a>3. 配置github/coding pages</h4><p>github和coding可以双线配置，也可以选择其中一个配置。推荐双线配置，coding用于国内访问速度较快，github用于境外访问。</p>
<p>1.登录github，New repository：<code>yourname.github.io</code>。其中<code>yourname</code>是你的github用户名，github强制后缀为<code>github.io</code>才能启用github pages服务。</p>
<p>2.登录coding，新建仓库：<code>yourname.coding.me</code>，打开静态pages服务。其中<code>yourname</code>是你的coding用户名，coding不强制后缀为<code>coding.me</code>。</p>
<p>3.Git Bash配置git用户信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name &quot;YourName&quot;</span><br><span class="line">$ git config --global user.email &quot;YourEmail&quot;</span><br></pre></td></tr></table></figure>
<p>4.配置网络传输协议<br>在管理Git项目时，一般使用ssh或https作为安全传输协议，任选其一即可。<br>(1) SSH协议<br>①SSH秘钥：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;  # 生成rsa秘钥</span><br><span class="line">$ cd ~/.ssh         # 进入虚拟目录ssh文件中</span><br><span class="line">$ cat id_rsa.pub    # 显示id_rsa.pub文件内容</span><br></pre></td></tr></table></figure>
<p>②复制秘钥至github/coding-&gt;用户setting-&gt;SSH keys，New SSH Key；</p>
<p>③验证是否添加成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ssh -T git@github.com  # 验证github是否添加成功</span><br><span class="line">$ ssh -T git@coding.net  # 验证coding是否添加成功</span><br></pre></td></tr></table></figure>
<p>④编辑站点配置文件<code>_config.yml</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">	type: git</span><br><span class="line">	repo: </span><br><span class="line">		github: git@github.com:yourname/yourname.github.io.git </span><br><span class="line">		coding: git@git.coding.net:yourname/yourname.coding.me.git </span><br><span class="line">	branch: master</span><br></pre></td></tr></table></figure>
<p>(2) HTTPS协议</p>
<p>①直接编辑站点配置文件<code>_config.yml</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">	type: git</span><br><span class="line">	repo: </span><br><span class="line">		github: https://github.com/liziczh/liziczh.github.io.git</span><br><span class="line">    	coding: https://git.coding.net/liziczh/liziczh.coding.me.git</span><br><span class="line">	branch: master</span><br></pre></td></tr></table></figure>
<p>②验证github/coding用户名和密码。</p>
<h4 id="4-部署到github-coding"><a href="#4-部署到github-coding" class="headerlink" title="4. 部署到github/coding"></a>4. 部署到github/coding</h4><p>1.安装Git部署插件：<br><code>$ npm install hexo-deployer-git --save</code><br>2.部署：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo clean     # 清理本地静态文件；</span><br><span class="line">$ hexo generate  # 生成静态页面，即public文件夹；</span><br><span class="line">$ hexo deploy    # 部署到github/coding；</span><br></pre></td></tr></table></figure>
<p>3.部署完毕，站点文件目录如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── .deploy_git  # （新增）hexo deploy 生成的git部署文件</span><br><span class="line">├── public       # （新增）hexo generate 生成的静态文件</span><br><span class="line">├── db.json      # （新增）hexo generate 生成的数据</span><br><span class="line">├── node_modules # 依赖模块</span><br><span class="line">├── scaffolds    # layout模板文件目录，其中的md文件可以添加编辑</span><br><span class="line">├── source       # 用户源文件：页面，文章markdown文件。文章源码目录，该目录下的markdown和html文件均会被hexo处理。该页面对应repo的根目录，404文件、favicon.ico文件，CNAME文件等都应该放这里，该目录下可新建页面目录。</span><br><span class="line">|   └── _posts   # 文章</span><br><span class="line">└── themes       # 主题</span><br><span class="line">├── .gitignore   # git时需忽略文件</span><br><span class="line">├── _config.yml  # 站点配置文件</span><br><span class="line">├── package.json # 已安装插件映射表，下次只需npm install即直接安装表插件，指明hexo的版本等信息，类似于一般软件中的关于按钮</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>站点搭建完毕，打开浏览器在地址栏输入以下链接可随时访问自己的博客了。<br>github pages：<a href="http://yourname.github.io/">http://yourname.github.io</a><br>coding pages：<a href="http://yourname.coding.me/">http://yourname.coding.me</a></p>
<h4 id="5-站点配置"><a href="#5-站点配置" class="headerlink" title="5. 站点配置"></a>5. 站点配置</h4><p>区分配置文件：</p>
<table>
    <tr> 
        <td>配置文件</td> 
        <td>路径</td> 
    </tr> 
    <tr> 
        <td>路径站点配置文件</td> 
        <td>X:/blog/_config.yml</td> 
    </tr> 
    <tr> 
        <td>主题配置文件</td> 
        <td>X:/blog/themes/你的主题/_config.yml</td> 
    </tr> 
</table>

<p>打开站点配置文件<code>blog/_config.yml</code>，自行发挥，配置完毕，重新部署 <code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code>；</p>
<blockquote>
<p>注意：yaml语言使用缩进表示层级关系。<br>注意：键值对中的冒号（:）后面有一个半角空格。</p>
</blockquote>
<p><strong>网站</strong><br><code>title</code>: #网站标题<br><code>subtitle</code>: #网站副标题<br><code>description</code>: #网站描述<br><code>keywords</code>: #关键字<br><code>author</code>: #你的名字,文档作者<br><code>language</code>: #网站的语言<br><code>timezone</code>: #时区，中国：Asia/Shanghai<br>其中，description主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。author参数用于主题显示文章的作者。</p>
<p><strong>网址</strong><br>url: <a href="https://yoursite.com/">https://yoursite.com</a>  #你的网址url<br>root: /   #网站根目录<br>permalink: :year/:month/:day/:title.html #<a href="https://hexo.io/zh-cn/docs/permalinks">文章永久链接</a><br>permalink_defaults:<br><strong>主题</strong><br>theme: landscape  # 主题文件的名称<br><strong>部署</strong><br>deploy:<br>  type: git<br>  repo:<br>    github: <a href="mailto:&#x67;&#x69;&#116;&#x40;&#x67;&#105;&#x74;&#104;&#x75;&#x62;&#x2e;&#99;&#x6f;&#109;">&#x67;&#x69;&#116;&#x40;&#x67;&#105;&#x74;&#104;&#x75;&#x62;&#x2e;&#99;&#x6f;&#109;</a>:yourname/yourname.github.io.git<br>    coding: <a href="mailto:&#103;&#105;&#x74;&#x40;&#x67;&#x69;&#x74;&#x2e;&#99;&#111;&#100;&#x69;&#110;&#x67;&#46;&#x6e;&#101;&#x74;">&#103;&#105;&#x74;&#x40;&#x67;&#x69;&#x74;&#x2e;&#99;&#111;&#100;&#x69;&#110;&#x67;&#46;&#x6e;&#101;&#x74;</a>:yourname/yourname.coding.me.git<br>  branch: master</p>
<blockquote>
<p>详细配置请参考<a href="https://hexo.io/zh-cn/docs/configuration.html">hexo配置</a>，此处不再赘述。</p>
</blockquote>
<h4 id="6-主题变更"><a href="#6-主题变更" class="headerlink" title="6. 主题变更"></a>6. 主题变更</h4><p>1.hexo默认主题为landscape，可以到Themes|Hexo选择自己喜欢的主题，复制主题在github仓库的url。<br>2.在themes文件夹下，打开GitBash，克隆主题至themes文件夹中。<br><code>$ git clone https://github.com/theme-next/hexo-theme-next.git</code><br>克隆之后，记住删除<code>themes\</code>你的主题名中的<code>.git</code>，<code>.github</code>，<code>.gitignore</code>等Git仓库文件。<br>3.更改站点配置文件<code>_config.yml</code>：<br><code>theme: 主题文件名</code><br>4.编辑结束，重新部署：<br><code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code><br>部署完毕之后，进入以下链接刷新就可以看到你的新主题了。</p>
<h4 id="7-写作"><a href="#7-写作" class="headerlink" title="7. 写作"></a>7. 写作</h4><p>1.新建：在blog文件夹下，打开Git Bash或者cmd，新建文章：<br><code>$ hexo new post &quot;title&quot;</code><br>2.编辑：在<code>source/_post</code>下可以编辑你新建的文章。<br>3.编辑完毕，重新部署：<code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code></p>
<h4 id="8-Front-matter"><a href="#8-Front-matter" class="headerlink" title="8. Front-matter"></a>8. Front-matter</h4><p>Front-matter 是文档最上方以 <code>---</code> 分隔的区域，用于指定文档一些的参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章标题</span><br><span class="line">date: yyyy-MM-dd hh:mm:ss</span><br><span class="line">tags: </span><br><span class="line">categories: </span><br><span class="line">comments: true</span><br><span class="line">---</span><br><span class="line"># 注意：键值对中的冒号（:）后面有一个半角空格。</span><br></pre></td></tr></table></figure>
<table>
    <tr> 
        <td>参数</td> 
        <td>值</td> 
        <td>描述</td> 
    </tr>
    <tr>
        <td>layout</td> 
        <td>post、page、draft、false</td> 
        <td>文章【默认值】、页面、草稿、不处理</td> 
    </tr>
         <td>title</td> 
         <td>文本</td> 
         <td>标题</td> 
    <tr>
        <td>date</td> 
        <td>yyyy-MM-dd hh:mm:ss</td> 
        <td>文件建立日期</td> 
    </tr>
        <td>update</td> 
        <td>yyyy-MM-dd hh:mm:ss</td> 
        <td>文件更新日期</td>  
    <tr>
    </tr>
    <tr>
    </tr>
    <tr>
    </tr>
    <tr>
    </tr>
    <tr>
    </tr>
    <tr>
    </tr>
    <tr>
    </tr>
    <tr>
    </tr>
    <tr>
    </tr>



       
        
        
<pre><code>    &lt;td&gt;comments&lt;/td&gt; 
    &lt;td&gt;tags&lt;/td&gt; 
    &lt;td&gt;categories&lt;/td&gt; 
    &lt;td&gt;permalink&lt;/td&gt; 
&lt;/tr&gt; 
&lt;tr&gt; 
   
    
    
    
    &lt;td&gt;true、false&lt;/td&gt; 
    &lt;td&gt;&lt;/td&gt; 
    &lt;td&gt;&lt;/td&gt; 
    &lt;td&gt;url&lt;/td&gt; 
&lt;/tr&gt; 
&lt;tr&gt; 
    &lt;td&gt;X:/blog/themes/你的主题/_config.yml&lt;/td&gt; 
    

    
    &lt;td&gt;开启文章评论功能，默认true&lt;/td&gt; 
    &lt;td&gt;标签（只适用于post）&lt;/td&gt; 
    &lt;td&gt;分类（只适用于post）&lt;/td&gt; 
    &lt;td&gt;永久链接&lt;/td&gt;
&lt;/tr&gt; 
</code></pre>
</table>

<blockquote>
<p>不要处理我的文章：将文章Front-Matter中的layout: false</p>
</blockquote>
<hr>
<h2 id="NexT主题文章管理"><a href="#NexT主题文章管理" class="headerlink" title="NexT主题文章管理"></a>NexT主题文章管理</h2><h3 id="配置文件的区分"><a href="#配置文件的区分" class="headerlink" title="配置文件的区分"></a>配置文件的区分</h3><h3 id="文档的Front-matter"><a href="#文档的Front-matter" class="headerlink" title="文档的Front-matter"></a>文档的Front-matter</h3><p>Front-matter 是文档最上方以<code>---</code>分隔的区域，用于指定文档一些的参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章标题</span><br><span class="line">date: yyyy-MM-dd hh:mm:ss</span><br><span class="line">tags: </span><br><span class="line">categories: </span><br><span class="line">comments: true</span><br><span class="line">---</span><br><span class="line"># 注意：键值对中的冒号（:）后面有一个半角空格。</span><br></pre></td></tr></table></figure>
<table>
    <tr> 
        <td>参数</td> 
        <td>值</td> 
        <td>描述</td> 
    </tr> 
    <tr> 
        <td>layout</td> 
        <td>post page draft false</td> 
        <td>文章【默认值】页面 草稿 不处理</td> 
    </tr> 
    <tr> 
        <td>title</td> 
        <td>文本</td> 
        <td>标题</td> 
    </tr> 
</table>

<h3 id="给Next主题添加背景图片"><a href="#给Next主题添加背景图片" class="headerlink" title="给Next主题添加背景图片"></a>给Next主题添加背景图片</h3><p>打开<code>themes\next\source\css\main.styl</code>文件，插入如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@media screen and (min-width:1200px) &#123;</span><br><span class="line">    body &#123;</span><br><span class="line">    background-image:url(/images/background.jpg);</span><br><span class="line">    background-repeat: no-repeat;</span><br><span class="line">    background-attachment:fixed;</span><br><span class="line">    background-position:50% 50%; </span><br><span class="line">    &#125;</span><br><span class="line">    #footer a &#123;</span><br><span class="line">        color:#eee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;!--图片放置到前一级目录的images文件夹下--&gt;</span><br></pre></td></tr></table></figure>

<h3 id="给Next主题添加Gitter聊天功能"><a href="#给Next主题添加Gitter聊天功能" class="headerlink" title="给Next主题添加Gitter聊天功能"></a>给Next主题添加Gitter聊天功能</h3><p><strong>Gitter 的介绍和功能特色</strong></p>
<ul>
<li>免费无限制：用户可以自由免费地创建、搜素、加入社区、聊天室。支持单独私人聊天、markdown 编辑、媒体文件发送等功能。</li>
<li>简单便捷：支持 Github 项目库关联创建社区，一键即可加入聊天讨论，仅在一个浏览器页面中即可查看和订阅多个聊天室。</li>
<li>对外开放：所有社区支持对外分享并可被搜索到，一个链接即可访问参与聊天讨论，用户头像显示其 GitHub 账号的相关信息。<br>Gitter 注册:[<a href="https://gitter.im]">https://gitter.im]</a></li>
</ul>
<p>1.在<code>themes\next\layout\_third-party\quicklink.njk</code>文件里添加如下的集成代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--使用 Gitter 实现一个 IM 即时通讯聊天室功能--&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  ((window.gitter = &#123;&#125;).chat = &#123;&#125;).options = &#123;</span><br><span class="line">    room: &#x27;enjoytoshare/community&#x27;</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;https://sidecar.gitter.im/dist/sidecar.v1.js&quot; async defer&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>


<hr>
<h1 id="那些年遇到的bug"><a href="#那些年遇到的bug" class="headerlink" title="那些年遇到的bug"></a>那些年遇到的bug</h1><ol>
<li>无法插入图片。<code>20220405解决</code><blockquote>
<p>试了很多方法，包括外链插入、本地插入，还是没有办法加载图片。后来搜索到了一个教程，是要修改<code>node_nodules</code>里的<code>hexo-asset-image\index.js</code>的参数。很奇特，把大佬的配置复制粘贴到我的<code>index.js</code>里，依然不生效。但是如果把我源文件注释掉，再复制粘贴，即可顺利加载图片。</p>
</blockquote>
</li>
</ol>
<hr>
<h1 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h1><p><code>20220405</code>：</p>
<ol>
<li><a href="http://xring.info/2018/hexo-pic-size.html">实现修改图片大小</a></li>
<li><a href="https://blog.csdn.net/dpdpdppp/article/details/102387532">实现hexo(Next主题)修改文字大小</a></li>
<li><a href="https://blog.csdn.net/qq_39720594/article/details/105401774">播放音乐(细节有待优化)</a></li>
<li>增加打赏、搜索、友链和评论功能。</li>
</ol>
<ul>
<li>博客初步维护完毕(20220405 23:35)。</li>
</ul>
<p><code>20220414</code></p>
<ol>
<li>增加“夜间模式”。</li>
<li>增加“语言切换功能”。</li>
<li>删除“播放音乐”功能。</li>
<li>更换主题样式与站点图标。</li>
<li>更换子栏目内容。</li>
</ol>
<p><code>20220423</code></p>
<ol>
<li>增加博客背景</li>
<li>增加Gitter在线交流功能</li>
</ol>
<p><code>20220511</code></p>
<ol>
<li>更换博客主题[Next-&gt;zhaoo]<br>参考网站：<a href="https://www.izhaoo.com/2020/05/05/hexo-theme-zhaoo-doc/#%E5%85%A8%E5%B1%80%E5%AD%97%E4%BD%93">https://www.izhaoo.com/2020/05/05/hexo-theme-zhaoo-doc/#%E5%85%A8%E5%B1%80%E5%AD%97%E4%BD%93</a></li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
        <category>计算机工具</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>写作排版</tag>
      </tags>
  </entry>
  <entry>
    <title>建站成功！</title>
    <url>/undefined/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B7%A5%E5%85%B7/Hexo/%E5%BB%BA%E7%AB%99%E6%88%90%E5%8A%9F%EF%BC%81/</url>
    <content><![CDATA[<h1 id="WELCOME-TO-MY-BLOG-欢迎来到我的个人博客💐🌃💻"><a href="#WELCOME-TO-MY-BLOG-欢迎来到我的个人博客💐🌃💻" class="headerlink" title="WELCOME TO MY BLOG | 欢迎来到我的个人博客💐🌃💻"></a>WELCOME TO MY BLOG | 欢迎来到我的个人博客💐🌃💻</h1><blockquote>
<p>以下公开的网络资源助力本人搭建博客。<br>①<a href="https://www.bilibili.com/video/BV1cW411A7Jx?p=9">手把手教你搭建属于自己的hexo+github博客</a><br>②<a href="https://blog.csdn.net/qq_48759664/article/details/119480266">Hexo部署出现错误err-Error-Spawn-failed解决方式</a><br>③<a href="https://git-scm.com/">git官方</a><br>④<a href="https://github.com/">github社区</a><br>⑤<a href="https://hexo.io/">hexo框架</a><br>⑥<a href="https://www.cnblogs.com/liziczh/default.html?page=2">关于next主题的配置</a><br>⑦<a href="http://theme-next.iissnan.com/tag-plugins.html">next官方中文文档</a><br>⑧<a href="https://tding.top/tags/NexT/">一些大佬的博客</a></p>
</blockquote>
<span id="more"></span>
<h1 id="这是我第一篇博文！"><a href="#这是我第一篇博文！" class="headerlink" title="这是我第一篇博文！"></a>这是我第一篇博文！</h1><h2 id="搭建过程中碰到的一些小问题"><a href="#搭建过程中碰到的一些小问题" class="headerlink" title="搭建过程中碰到的一些小问题"></a>搭建过程中碰到的一些小问题</h2><p>第一个问题是git没有初始化、环境变量配置被覆盖，第二个问题是部署出现错误err-Error-Spawn-failed。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#搭建过程中需要的一些代码</span><br><span class="line">①init git //初始本地git</span><br><span class="line">②git config --global core.autocrlf false //当设置成false时,line endings</span><br><span class="line">将不做转换操作。文本文件保持原来的样子。</span><br><span class="line">tips:hexo s -p 端口号 //预览主题页面</span><br><span class="line">③hexo clean &amp;&amp; hexo g &amp;&amp; hexo d //这行代码是首次部署博客时假设存在了err-Error-Spawn-failed的解决方式。能够打开页面后每次更新页面请看④</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>学习</category>
        <category>计算机工具</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>写作排版</tag>
      </tags>
  </entry>
</search>
