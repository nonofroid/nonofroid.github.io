<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="baidu-site-verification" content="c8b01d587c498d89eacc77987a5fe722">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-bounce.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"nonofroid.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.11.0","exturl":false,"sidebar":{"position":"left","width":300,"display":"always","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="计算机网络笔记第一章 计算机网络和因特网 提纲：  什么是Internet？ 什么是协议？ 网络边缘 接入网、物理媒体 Internet结构和ISP 分组延时、丢失和吞吐量 协议层次及服务模型 历史">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络笔记">
<meta property="og:url" content="https://nonofroid.github.io/undefined/%E5%AD%A6%E4%B9%A0/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="不见来时路的树洞">
<meta property="og:description" content="计算机网络笔记第一章 计算机网络和因特网 提纲：  什么是Internet？ 什么是协议？ 网络边缘 接入网、物理媒体 Internet结构和ISP 分组延时、丢失和吞吐量 协议层次及服务模型 历史">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="g:/科技数码/img/image-20220511151825032.png">
<meta property="og:image" content="g:/科技数码/img/image-20220515115821402.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/ced5ff7ff3454a6c9c18d4109ed229ea.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWFUgSG9uZ2R1bw==,size_20,color_FFFFFF,t_70,g_se,x_16">
<meta property="og:image" content="https://img-blog.csdnimg.cn/47ed1ebc1d4c4043a2ed1a596c8654ec.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWFUgSG9uZ2R1bw==,size_20,color_FFFFFF,t_70,g_se,x_16">
<meta property="og:image" content="https://img-blog.csdnimg.cn/362905f341684d918f5d1b607b7ee7ea.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWFUgSG9uZ2R1bw==,size_20,color_FFFFFF,t_70,g_se,x_16">
<meta property="og:image" content="https://img-blog.csdnimg.cn/1b6e2a247c3e4227b2a54eee4667ecb5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWFUgSG9uZ2R1bw==,size_20,color_FFFFFF,t_70,g_se,x_16">
<meta property="og:image" content="https://nonofroid.github.io/undefined/%E5%AD%A6%E4%B9%A0/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/计算机网络.assets/image-20220529133707931.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210709084904597.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/97ab2d33fa04456989bca20d68587771.png">
<meta property="og:image" content="f:/计算机网络/计算机网络.assets/image-20220531182849694.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210709111423816.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="f:/计算机网络/计算机网络.assets/image-20220601132924928.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/70810659bd9e4ffd831dc14464e997a9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAWXNtaW5nODg=,size_20,color_FFFFFF,t_70,g_se,x_16">
<meta property="og:image" content="https://img-blog.csdnimg.cn/28f0146f4568480abf9afe951dbfddc9.png">
<meta property="og:image" content="f:/计算机网络/计算机网络.assets/image-20220603233418699.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/08f780f945204228b2d30d141de06e38.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAWXNtaW5nODg=,size_20,color_FFFFFF,t_70,g_se,x_16">
<meta property="og:image" content="https://img-blog.csdnimg.cn/e0fdcf851081478f8d21d383829528d1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAWXNtaW5nODg=,size_20,color_FFFFFF,t_70,g_se,x_16">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210710111611842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="f:/计算机网络/计算机网络.assets/image-20220604195238630.png">
<meta property="og:image" content="f:/计算机网络/计算机网络.assets/image-20220604215509064.png">
<meta property="og:image" content="f:/计算机网络/计算机网络.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70#pic_center.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210712122222479.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="f:/计算机网络/计算机网络.assets/image-20220604222857726.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210712134235520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210712134420726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210712215031502.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210713101428834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://nonofroid.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220607163941673.png">
<meta property="og:image" content="https://nonofroid.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220607163947253.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210713102233828.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://nonofroid.github.io/undefined/%E5%AD%A6%E4%B9%A0/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/计算机网络.assets/image-20220607165259006.png">
<meta property="og:image" content="https://nonofroid.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220607173512065.png">
<meta property="og:image" content="https://nonofroid.github.io/undefined/%E5%AD%A6%E4%B9%A0/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/计算机网络.assets/image-20220607190223736.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210713163434541.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210713193645192.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2021071319410425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210713194500646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://nonofroid.github.io/undefined/%E5%AD%A6%E4%B9%A0/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/计算机网络.assets/image-20220608162107067.png">
<meta property="og:image" content="https://nonofroid.github.io/undefined/%E5%AD%A6%E4%B9%A0/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/计算机网络.assets/image-20220608162112784.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210714092804173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210714102410172.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210714101520897.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210714142523376.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://nonofroid.github.io/undefined/%E5%AD%A6%E4%B9%A0/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/计算机网络.assets/image-20220610134310892.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210714144853925.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210714145612876.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://th.bing.com/th/id/R.491a38d2eb9163bae67197bd99305c87?rik=SIk7s9SrvqrrRg&riu=http://upload-images.jianshu.io/upload_images/11034989-0030c15174f2d4b2.png&ehk=EImYWzVHhCy1YEC01edbm++XVDFJ2XhElQVFVOoHlZs=&risl=&pid=ImgRaw&r=0">
<meta property="og:image" content="https://nonofroid.github.io/undefined/%E5%AD%A6%E4%B9%A0/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/计算机网络.assets/image-20220611154012154.png">
<meta property="og:image" content="https://nonofroid.github.io/undefined/%E5%AD%A6%E4%B9%A0/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/计算机网络.assets/image-20220611161336560.png">
<meta property="og:image" content="https://nonofroid.github.io/undefined/%E5%AD%A6%E4%B9%A0/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/计算机网络.assets/image-20220611200048263.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210717230301386.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210717230408252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190402224549142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5MDEwMTAx,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190405200510524.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5MDEwMTAx,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181201104548931.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2EzMTkyMDQ4,size_16,color_FFFFFF,t_70">
<meta property="article:published_time" content="2022-05-11T06:52:11.000Z">
<meta property="article:modified_time" content="2022-07-06T09:46:57.150Z">
<meta property="article:author" content="nono">
<meta property="article:tag" content="学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="g:/科技数码/img/image-20220511151825032.png">


<link rel="canonical" href="https://nonofroid.github.io/undefined/%E5%AD%A6%E4%B9%A0/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://nonofroid.github.io/undefined/%E5%AD%A6%E4%B9%A0/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/","path":"undefined/学习/专业基础/计算机网络/计算机网络笔记/","title":"计算机网络笔记"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>计算机网络笔记 | 不见来时路的树洞</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="不见来时路的树洞" type="application/atom+xml">
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">不见来时路的树洞</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">希望能把我的人生写成一本书。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-主页"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>主页</a></li><li class="menu-item menu-item-所有文章"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>所有文章</a></li><li class="menu-item menu-item-博客标签"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>博客标签</a></li><li class="menu-item menu-item-博客分类"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>博客分类</a></li><li class="menu-item menu-item-那只阴郁的猫"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>那只阴郁的猫</a></li><li class="menu-item menu-item-关于我"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于我</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
   
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0"><span class="nav-number">1.</span> <span class="nav-text">计算机网络笔记</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91"><span class="nav-number">2.</span> <span class="nav-text">第一章 计算机网络和因特网</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%A0%E7%89%B9%E7%BD%91"><span class="nav-number">2.1.</span> <span class="nav-text">1.1 什么是因特网</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-1-%E5%85%B7%E4%BD%93%E6%8F%8F%E8%BF%B0"><span class="nav-number">2.1.1.</span> <span class="nav-text">1.1.1 具体描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-2-%E6%9C%8D%E5%8A%A1%E6%8F%8F%E8%BF%B0"><span class="nav-number">2.1.2.</span> <span class="nav-text">1.1.2 服务描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-3-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8F%E8%AE%AE"><span class="nav-number">2.1.3.</span> <span class="nav-text">1.1.3 什么是协议</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E7%BD%91%E7%BB%9C%E8%BE%B9%E7%BC%98"><span class="nav-number">2.2.</span> <span class="nav-text">1.2 网络边缘</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-1-%E6%8E%A5%E5%85%A5%E7%BD%91"><span class="nav-number">2.2.1.</span> <span class="nav-text">1.2.1 接入网</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-2-%E7%89%A9%E7%90%86%E5%AA%92%E4%BD%93"><span class="nav-number">2.2.2.</span> <span class="nav-text">1.2.2 物理媒体</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-%E7%BD%91%E7%BB%9C%E6%A0%B8%E5%BF%83"><span class="nav-number">2.3.</span> <span class="nav-text">1.3 网络核心</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-1-%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2"><span class="nav-number">2.3.0.1.</span> <span class="nav-text">1.3.1 分组交换</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%AD%98%E5%82%A8%E8%BD%AC%E5%8F%91%E4%BC%A0%E8%BE%93"><span class="nav-number">2.3.0.1.1.</span> <span class="nav-text">1.存储转发传输</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%8E%92%E9%98%9F%E6%97%B6%E5%BB%B6%E5%92%8C%E5%88%86%E7%BB%84%E4%B8%A2%E5%A4%B1"><span class="nav-number">2.3.0.1.2.</span> <span class="nav-text">2.排队时延和分组丢失</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E8%BD%AC%E5%8F%91%E8%A1%A8%E5%92%8C%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE"><span class="nav-number">2.3.0.1.3.</span> <span class="nav-text">3.转发表和路由选择协议</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-2-%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2"><span class="nav-number">2.3.0.2.</span> <span class="nav-text">1.3.2 电路交换</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2%E4%B8%AD%E7%9A%84%E5%A4%8D%E7%94%A8"><span class="nav-number">2.3.0.2.1.</span> <span class="nav-text">1. 电路交换中的复用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2%E4%B8%8E%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2%E5%AF%B9%E6%AF%94"><span class="nav-number">2.3.0.2.2.</span> <span class="nav-text">2.分组交换与电路交换对比</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-3-%E7%BD%91%E7%BB%9C%E7%9A%84%E7%BD%91%E7%BB%9C"><span class="nav-number">2.3.0.3.</span> <span class="nav-text">1.3.3 网络的网络</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2%E4%B8%AD%E7%9A%84%E6%97%B6%E5%BB%B6%E3%80%81%E4%B8%A2%E5%8C%85%E5%92%8C%E5%90%9E%E5%90%90%E9%87%8F"><span class="nav-number">2.4.</span> <span class="nav-text">1.4 分组交换中的时延、丢包和吞吐量</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-4-1-%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2%E7%BD%91%E4%B8%AD%E7%9A%84%E6%97%B6%E5%BB%B6%E6%A6%82%E8%BF%B0"><span class="nav-number">2.4.0.0.1.</span> <span class="nav-text">1.4.1 分组交换网中的时延概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-4-2-%E6%8E%92%E9%98%9F%E6%97%B6%E5%BB%B6%E5%92%8C%E4%B8%A2%E5%8C%85"><span class="nav-number">2.4.0.0.2.</span> <span class="nav-text">1.4.2 排队时延和丢包</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-4-3-%E7%AB%AF%E5%88%B0%E7%AB%AF%E6%97%B6%E5%BB%B6"><span class="nav-number">2.4.0.0.3.</span> <span class="nav-text">1.4.3 端到端时延</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-4-4-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%90%9E%E5%90%90%E9%87%8F"><span class="nav-number">2.4.0.0.4.</span> <span class="nav-text">1.4.4 计算机网络中的吞吐量</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5-%E5%8D%8F%E8%AE%AE%E5%B1%82%E6%AC%A1%E5%8F%8A%E5%85%B6%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.5.</span> <span class="nav-text">1.5 协议层次及其服务模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-1-%E5%88%86%E5%B1%82%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">2.5.1.</span> <span class="nav-text">1.5.1 分层体系结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%8D%8F%E8%AE%AE%E5%88%86%E5%B1%82"><span class="nav-number">2.5.1.1.</span> <span class="nav-text">1.协议分层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-OSI%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.5.1.2.</span> <span class="nav-text">2.OSI模型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-2-%E5%B0%81%E8%A3%85"><span class="nav-number">2.5.2.</span> <span class="nav-text">1.5.2 封装</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-6-%E8%A2%AB%E6%94%BB%E5%87%BB%E7%9A%84%E7%BD%91%E7%BB%9C"><span class="nav-number">2.6.</span> <span class="nav-text">1.6 被攻击的网络</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-7-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91%E7%9A%84%E5%8E%86%E5%8F%B2"><span class="nav-number">2.7.</span> <span class="nav-text">1.7 计算机网络和因特网的历史</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-1-%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2%E7%9A%84%E5%8F%91%E5%B1%95-1961-1972"><span class="nav-number">2.7.1.</span> <span class="nav-text">1.7.1 分组交换的发展(1961-1972)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-2-%E4%B8%93%E7%94%A8%E7%BD%91%E7%BB%9C%E6%88%B7%E7%BD%91%E7%BB%9C%E4%BA%92%E8%81%94%EF%BC%9A1972-1980"><span class="nav-number">2.7.2.</span> <span class="nav-text">1.7.2 专用网络户网络互联：1972~1980</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-3-%E7%BD%91%E7%BB%9C%E7%9A%84%E6%BF%80%E5%A2%9E%EF%BC%9A1980-1990"><span class="nav-number">2.7.3.</span> <span class="nav-text">1.7.3 网络的激增：1980~1990</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-4-%E5%9B%A0%E7%89%B9%E7%BD%91%E7%88%86%E7%82%B8%EF%BC%9A20%E4%B8%96%E7%BA%AA90%E5%B9%B4%E4%BB%A3"><span class="nav-number">2.7.4.</span> <span class="nav-text">1.7.4 因特网爆炸：20世纪90年代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-5-%E6%9C%80%E6%96%B0%E5%8F%91%E5%B1%95"><span class="nav-number">2.7.5.</span> <span class="nav-text">1.7.5 最新发展</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%BA%94%E7%94%A8%E5%B1%82"><span class="nav-number">3.</span> <span class="nav-text">第二章 应用层</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86"><span class="nav-number">3.1.</span> <span class="nav-text">2.1 应用层协议原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1-%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">3.1.1.</span> <span class="nav-text">2.1.1 网络应用程序体系结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-2-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="nav-number">3.1.2.</span> <span class="nav-text">2.1.2 进程通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-3-%E5%8F%AF%E4%BE%9B%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%BD%BF%E7%94%A8%E7%9A%84%E8%BF%90%E8%BE%93%E6%9C%8D%E5%8A%A1"><span class="nav-number">3.1.3.</span> <span class="nav-text">2.1.3 可供应用程序使用的运输服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-4-%E5%9B%A0%E7%89%B9%E7%BD%91%E6%8F%90%E4%BE%9B%E7%9A%84%E8%BF%90%E8%BE%93%E6%9C%8D%E5%8A%A1"><span class="nav-number">3.1.4.</span> <span class="nav-text">2.1.4 因特网提供的运输服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-5-%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="nav-number">3.1.5.</span> <span class="nav-text">2.1.5 应用层协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-6-%E6%9C%AC%E4%B9%A6%E6%B6%89%E5%8F%8A%E7%9A%84%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8"><span class="nav-number">3.1.6.</span> <span class="nav-text">2.1.6 本书涉及的网络应用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-Web%E5%92%8CHTTP"><span class="nav-number">3.2.</span> <span class="nav-text">2.2 Web和HTTP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-HTTP%E6%A6%82%E5%86%B5"><span class="nav-number">3.2.1.</span> <span class="nav-text">2.2.1 HTTP概况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2-%E9%9D%9E%E6%8C%81%E7%BB%AD%E6%80%A7%E8%BF%9E%E6%8E%A5%E5%92%8C%E6%8C%81%E7%BB%AD%E8%BF%9E%E6%8E%A5"><span class="nav-number">3.2.2.</span> <span class="nav-text">2.2.2 非持续性连接和持续连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-3-HTTP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F"><span class="nav-number">3.2.3.</span> <span class="nav-text">2.2.3 HTTP报文格式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E5%A4%B4%E9%83%A8"><span class="nav-number">3.2.3.0.1.</span> <span class="nav-text">请求头部</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-4-%E7%94%A8%E6%88%B7%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%BA%A4%E4%BA%92-cookie"><span class="nav-number">3.2.4.</span> <span class="nav-text">2.2.4 用户与服务器的交互:cookie</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-5-Web%E7%BC%93%E5%AD%98"><span class="nav-number">3.2.5.</span> <span class="nav-text">2.2.5 Web缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-6-%E6%9D%A1%E4%BB%B6GET%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.6.</span> <span class="nav-text">2.2.6 条件GET方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-%E5%9B%A0%E7%89%B9%E7%BD%91%E4%B8%AD%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6"><span class="nav-number">3.3.</span> <span class="nav-text">2.3 因特网中的电子邮件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-1-SMTP"><span class="nav-number">3.3.1.</span> <span class="nav-text">2.3.1 SMTP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-2-%E4%B8%8EHTTP%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-number">3.3.2.</span> <span class="nav-text">2.3.2 与HTTP的对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-3-%E9%82%AE%E4%BB%B6%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F"><span class="nav-number">3.3.3.</span> <span class="nav-text">2.3.3 邮件报文格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-4-%E9%82%AE%E4%BB%B6%E8%AE%BF%E9%97%AE%E5%8D%8F%E8%AE%AE"><span class="nav-number">3.3.4.</span> <span class="nav-text">2.3.4 邮件访问协议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-POP3%E5%8D%8F%E8%AE%AE"><span class="nav-number">3.3.4.1.</span> <span class="nav-text">1.POP3协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-IMAP"><span class="nav-number">3.3.4.2.</span> <span class="nav-text">2.IMAP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%9F%BA%E4%BA%8EWeb%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6"><span class="nav-number">3.3.4.3.</span> <span class="nav-text">3.基于Web的电子邮件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-DNS%EF%BC%9A%E5%9B%A0%E7%89%B9%E7%BD%91%E7%9A%84%E7%9B%AE%E5%BD%95%E6%9C%8D%E5%8A%A1"><span class="nav-number">3.4.</span> <span class="nav-text">2.4 DNS：因特网的目录服务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-1-DNS%E6%8F%90%E4%BE%9B%E7%9A%84%E6%9C%8D%E5%8A%A1"><span class="nav-number">3.4.1.</span> <span class="nav-text">2.4.1 DNS提供的服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-2-DNS%E5%B7%A5%E4%BD%9C%E6%9C%BA%E7%90%86%E6%A6%82%E8%BF%B0"><span class="nav-number">3.4.2.</span> <span class="nav-text">2.4.2 DNS工作机理概述</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-DNS%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%B3%95"><span class="nav-number">3.4.2.0.1.</span> <span class="nav-text">1.DNS查询方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-DNS%E7%BC%93%E5%AD%98"><span class="nav-number">3.4.2.0.2.</span> <span class="nav-text">2.DNS缓存</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-3-DNS%E8%AE%B0%E5%BD%95%E5%92%8C%E6%8A%A5%E6%96%87"><span class="nav-number">3.4.3.</span> <span class="nav-text">2.4.3 DNS记录和报文</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-DNS%E6%8A%A5%E6%96%87"><span class="nav-number">3.4.3.0.1.</span> <span class="nav-text">1.DNS报文</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%9C%A8DNS%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%8F%92%E5%85%A5%E8%AE%B0%E5%BD%95"><span class="nav-number">3.4.3.0.2.</span> <span class="nav-text">2.在DNS数据库中插入记录</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-P2P%E6%96%87%E4%BB%B6%E5%88%86%E5%8F%91"><span class="nav-number">3.5.</span> <span class="nav-text">2.5 P2P文件分发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-P2P%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%9A%84%E6%8B%93%E5%B1%95%E6%80%A7"><span class="nav-number">3.5.1.</span> <span class="nav-text">1.P2P体系结构的拓展性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%86%E4%B8%AD%E5%BC%8F%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="nav-number">3.5.1.1.</span> <span class="nav-text">集中式目录结构：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-BitTorrent"><span class="nav-number">3.5.2.</span> <span class="nav-text">2.BitTorrent</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-6-%E8%A7%86%E9%A2%91%E6%B5%81%E5%92%8C%E5%88%86%E5%8F%91%E5%86%85%E5%AE%B9%E7%BD%91"><span class="nav-number">3.6.</span> <span class="nav-text">2.6 视频流和分发内容网</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-1-%E5%9B%A0%E7%89%B9%E7%BD%91%E8%A7%86%E9%A2%91"><span class="nav-number">3.6.1.</span> <span class="nav-text">2.6.1 因特网视频</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-2-HTTP%E6%B5%81%E5%92%8CDASH"><span class="nav-number">3.6.2.</span> <span class="nav-text">2.6.2 HTTP流和DASH</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-3-%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91%E7%BD%91"><span class="nav-number">3.6.3.</span> <span class="nav-text">2.6.3 内容分发网</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-4-%E5%AD%A6%E4%B9%A0%E6%A1%88%E4%BE%8B%EF%BC%9ANetflix%E3%80%81YouTube%E5%92%8C%E2%80%9C%E7%9C%8B%E7%9C%8B%E2%80%9D"><span class="nav-number">3.6.4.</span> <span class="nav-text">2.6.4 学习案例：Netflix、YouTube和“看看”</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Netflix"><span class="nav-number">3.6.4.1.</span> <span class="nav-text">1.Netflix</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-YouTube"><span class="nav-number">3.6.4.2.</span> <span class="nav-text">2.YouTube</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E7%9C%8B%E7%9C%8B"><span class="nav-number">3.6.4.3.</span> <span class="nav-text">3.看看</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-7-%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B%EF%BC%9A%E7%94%9F%E6%88%90%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8"><span class="nav-number">3.7.</span> <span class="nav-text">2.7 套接字编程：生成网络应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-1-UDP%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B"><span class="nav-number">3.7.1.</span> <span class="nav-text">2.7.1 UDP套接字编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-2-TCP%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B"><span class="nav-number">3.7.2.</span> <span class="nav-text">2.7.2 TCP套接字编程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E8%BF%90%E8%BE%93%E5%B1%82"><span class="nav-number">4.</span> <span class="nav-text">第三章 运输层</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E6%A6%82%E8%BF%B0%E5%92%8C%E8%BF%90%E8%BE%93%E5%B1%82%E6%9C%8D%E5%8A%A1"><span class="nav-number">4.1.</span> <span class="nav-text">3.1 概述和运输层服务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-1-%E8%BF%90%E8%BE%93%E5%B1%82%E5%92%8C%E7%BD%91%E7%BB%9C%E5%B1%82%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">4.1.1.</span> <span class="nav-text">3.1.1 运输层和网络层的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-2-%E5%9B%A0%E7%89%B9%E7%BD%91%E8%BF%90%E8%BE%93%E5%B1%82%E6%A6%82%E8%BF%B0"><span class="nav-number">4.1.2.</span> <span class="nav-text">3.1.2 因特网运输层概述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B8%8E%E5%A4%9A%E8%B7%AF%E5%88%86%E8%A7%A3"><span class="nav-number">4.2.</span> <span class="nav-text">3.2 多路复用与多路分解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E6%97%A0%E8%BF%9E%E6%8E%A5%E8%BF%90%E8%BE%93%EF%BC%9AUDP"><span class="nav-number">4.3.</span> <span class="nav-text">3.3 无连接运输：UDP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1-UDP%E6%8A%A5%E6%96%87%E6%AE%B5%E7%BB%93%E6%9E%84"><span class="nav-number">4.3.1.</span> <span class="nav-text">3.3.1 UDP报文段结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-2-UDP%E6%A3%80%E9%AA%8C%E5%92%8C"><span class="nav-number">4.3.2.</span> <span class="nav-text">3.3.2 UDP检验和</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86"><span class="nav-number">4.4.</span> <span class="nav-text">3.4 可靠数据传输原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-1-%E6%9E%84%E9%80%A0%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE"><span class="nav-number">4.4.1.</span> <span class="nav-text">3.4.1 构造可靠数据传输协议</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8B%93%E5%B1%951%EF%BC%9A%E6%8A%A5%E6%96%87%E3%80%81%E6%8A%A5%E6%96%87%E6%AE%B5%E3%80%81%E5%88%86%E7%BB%84%E3%80%81%E5%8C%85%E3%80%81%E6%95%B0%E6%8D%AE%E6%8A%A5%E3%80%81%E5%B8%A7%E3%80%81%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8C%BA%E5%88%AB"><span class="nav-number">5.</span> <span class="nav-text">拓展1：报文、报文段、分组、包、数据报、帧、数据流的概念区别</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="nono"
      src="/images/photofile.jpg">
  <p class="site-author-name" itemprop="name">nono</p>
  <div class="site-description" itemprop="description">每一秒都在思考</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/nonofroid" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;nonofroid" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:Mr.gez666@gmail.com" title="E-Mail → mailto:Mr.gez666@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/yourname" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://plus.google.com/yourname" title="Google → https:&#x2F;&#x2F;plus.google.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fab fa-google fa-fw"></i>Google</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/" title="Twitter → https:&#x2F;&#x2F;twitter.com" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://instagram.com/" title="Instagram → https:&#x2F;&#x2F;instagram.com" rel="noopener" target="_blank"><i class="fab fa-instagram fa-fw"></i>Instagram</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.zhihu.com/" title="https:&#x2F;&#x2F;www.zhihu.com" rel="noopener" target="_blank">知乎</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.zhihu.com/" title="https:&#x2F;&#x2F;www.zhihu.com" rel="noopener" target="_blank">微博</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.leetcode.com/" title="https:&#x2F;&#x2F;www.leetcode.com" rel="noopener" target="_blank">Leetcode</a>
        </li>
    </ul>
  </div>
  <div class="">
    <a target="_blank" class="social-link" href="/atom.xml" style="color: burlywood;">
      <span class="icon">
        <i class="fa fa-rss"></i>
      </span>
      <span class="label">RSS</span>
    </a>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

      <!--网易云插件
      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=150 
        src="//music.163.com/outchain/player?type=0&id=7366832916&auto=1&height=430">
      </iframe>-->
    </div>

  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://nonofroid.github.io/undefined/%E5%AD%A6%E4%B9%A0/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/photofile.jpg">
      <meta itemprop="name" content="nono">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不见来时路的树洞">
      <meta itemprop="description" content="每一秒都在思考">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="计算机网络笔记 | 不见来时路的树洞">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计算机网络笔记
        </h1>

        <div class="post-meta-container">
          
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-11 14:52:11" itemprop="dateCreated datePublished" datetime="2022-05-11T14:52:11+08:00">2022-05-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-06 17:46:57" itemprop="dateModified" datetime="2022-07-06T17:46:57+08:00">2022-07-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">专业基础</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0/%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="热度" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">热度：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>45k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>41 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="计算机网络笔记"><a href="#计算机网络笔记" class="headerlink" title="计算机网络笔记"></a>计算机网络笔记</h1><h1 id="第一章-计算机网络和因特网"><a href="#第一章-计算机网络和因特网" class="headerlink" title="第一章 计算机网络和因特网"></a>第一章 计算机网络和因特网</h1><blockquote>
<p>提纲：</p>
<ul>
<li>什么是Internet？</li>
<li>什么是协议？</li>
<li>网络边缘</li>
<li>接入网、物理媒体</li>
<li>Internet结构和ISP</li>
<li>分组延时、丢失和吞吐量</li>
<li>协议层次及服务模型</li>
<li>历史</li>
</ul>
</blockquote>
<span id="more"></span>
<h2 id="1-1-什么是因特网"><a href="#1-1-什么是因特网" class="headerlink" title="1.1 什么是因特网"></a>1.1 什么是因特网</h2><p>其一：描述因特网的基本硬件和软件组件</p>
<p>其二：根据为分布式应用提供服务的联网基础来描述因特网</p>
<p><strong>网络</strong>：节点、边关系</p>
<p>节点：主机及其上运行的应用程序；路由器、交换机等网络交换设备。</p>
<p>边/通信链路：接入网链路(主机连接到互联网的链路)；主干链路：路由器间的链路。</p>
<p><strong>计算机网络</strong>：</p>
<p><strong>互联网</strong>：</p>
<h3 id="1-1-1-具体描述"><a href="#1-1-1-具体描述" class="headerlink" title="1.1.1 具体描述"></a>1.1.1 具体描述</h3><p><strong>主机/端系统</strong>：如智能手机、平板电脑、手提电脑等等因特网物品。</p>
<img src="G:\科技数码\img\image-20220511151825032.png" alt="image-20220511151825032" style="zoom:50%;" />

<p>端系统通过<strong>通信链路</strong>和<strong>分组交换机</strong>连接到一起。</p>
<p>链路的传输速率以比特/秒度量。</p>
<p><strong>分组</strong>：发送端系统将数据分段，并为每段加上首部字节。由此形成的信息包。</p>
<p><strong>分组交换机</strong>通过通信链路接收到达分组链路。</p>
<p>交换机：路由器(网络核心)、链路层交换机(接入网)等。</p>
<p><strong>路径</strong>：一个分组所经历的一系列通信链路和分组交换机称为通过该网络的路径。</p>
<p><strong>因特网服务提供商</strong>：ISP，端系统通过这个接入因特网。每个ISP自身就是一个由多台分组交换机和多段通信链路组成的网络。ISP为端系统提供了各种不同类型的网络接入。较底层的ISP通过国家的、国际的较高层ISP互联起来。运行着IP协议，遵从一定的命名和地址规则。每个ISP自身就是一个有多台分组交换机和多段通信链路组成的网路。</p>
<p><strong>因特网</strong>：将端系统彼此互联，为端系统提供接入的ISP也必须互联。</p>
<p><strong>协议</strong>：控制因特网中信息的接收和发送。TCP(Transmission Control Protocol，传输控制协议)和UDP(Internet Protocol，网际协议)是因特网中最为重要的两个协议。IP协议定义了在路由器和端系统之间发送和接收的分组格式。因特网主要协议统称为TCP/IP。</p>
<p><strong>因特网标准</strong>由因特网工程任务组(IETF)研发，IETF的标准文档叫请求评论(RFC)</p>
<h3 id="1-1-2-服务描述"><a href="#1-1-2-服务描述" class="headerlink" title="1.1.2 服务描述"></a>1.1.2 服务描述</h3><blockquote>
<p>为应用程序提供服务的基础设施。</p>
</blockquote>
<p><strong>分布式应用程序</strong>：这些应用程序涉及多个相互交换数据的端系统。</p>
<p>因特网应用程序不运行在网络核心的分组交换机中。</p>
<p><strong>套接字接口</strong>：规定了运行在一个端系统上的程序请求因特网基础设施向运行在另一个端系统上的特定目的地程序交付数据的方式。因特网套接字接口是一套发送程序必须遵循的规则集合，因此因特网能够将数据交付给目的地。</p>
<h3 id="1-1-3-什么是协议"><a href="#1-1-3-什么是协议" class="headerlink" title="1.1.3 什么是协议"></a>1.1.3 什么是协议</h3><p><strong>1.人类活动的类比</strong></p>
<img src="G:\科技数码\img\image-20220515115821402.png" alt="image-20220515115821402" style="zoom:50%;" />

<p><strong>2.网络协议</strong></p>
<p>协议：<strong>定义了在两个或多个通信实体之间交换的报文的格式和顺序，以及报文发送和/或接收一条报文或其他事件所采取的动作。</strong></p>
<p>因特网广泛使用协议。</p>
<h2 id="1-2-网络边缘"><a href="#1-2-网络边缘" class="headerlink" title="1.2 网络边缘"></a>1.2 网络边缘</h2><p>端系统：与因特网相连的计算机或者其他设备，位于因特网边缘。</p>
<p>端系统也称主机，可以容纳应用程序。</p>
<p>主机分为客户机和服务器，</p>
<p>客户通常是桌面PC、移动PC和智能机，服务器则是用于存储和发布Web页面、流视频和中继电子邮件等。</p>
<p><strong>数据中心</strong>：服务器的集合。</p>
<h3 id="1-2-1-接入网"><a href="#1-2-1-接入网" class="headerlink" title="1.2.1 接入网"></a>1.2.1 接入网</h3><p><strong>接入网：</strong>将端系统物理连接到其边缘路由器的网络。边缘路由器是端系统到任何其他远程端系统路径上的第一台路由器。</p>
<p><strong>边缘路由器：</strong>是端系统到任何其他远程端系统的路径上的第一台路由器。</p>
<ol>
<li>家庭接入：DSL、电缆、FTTH、拨号和卫星</li>
</ol>
<p>宽带住宅最流行的两种类型：数字用户线(DSL)和电缆。当使用DSL时，用户的本地电话公司也是它的ISP。每个用户的DSL调制解调器使用现有的电话线与位于电话公司的本地中心局(CO)中的数字用户线接入复用器(DSLAM)交换数据。家庭的DSL调制解调器时得到数字数据后将其转换为高频音，以通过电话线传输给本地中心局。来自许多家庭的模拟信号在DSLAM处被转换回数字形式。</p>
<p>家庭电话线使用不同的频率编码。</p>
<p>分配器把家庭的数据和电话信号分开，并将数据信号转发给DSL调制解调器。在电话公司的一侧，在本地中心局，DSLAM把数据和电话信号分隔开，并将数据送往因特网。数百甚至上千个家庭与同一个DSLAM相连。</p>
<p>DSL利用电话公司现有的有线电视基础设施；电缆因特网接入利用了有线电视公司现有的有线电视基础设施。需要特殊的电缆调制解调器。</p>
<p>住宅提供有线电视的公司获得了电缆因特网接入。H，</p>
<p><strong>光纤到户</strong>：FTTH。主动光纤和被动光纤。AON本质是交换因特网。</p>
<p>PON技术用于Verzion的FIOS服务中。</p>
<p>每个家庭具有一个光纤网络端接器ONT，由专门的光纤连接到邻近的分配器。该分配器把一些家庭集结到一根共享光纤中，该光纤再连接到本地电话和公司的中心局中的光纤线路端接器OLT。</p>
<p>FTTH有潜力提供每秒千兆比特范围的因特网接入速率。然而，大多数FTTH ISP提供多种不同速率选择，较高的速率自然花费更多。</p>
<ol start="2">
<li>企业和家庭接入：以太网和WiFi</li>
</ol>
<p>在公司和大学校园：局域网(LAN)将端系统连接到边缘路由器。</p>
<p>家庭将电缆调制解调器和廉价的无线局域网技术结合起来。</p>
<p>家庭网络组成如下：一台漫游的便携机和一台有线的PC；一个与无线PC和家中其他无线设备通信的基站；一个提供与因特网带宽接入的电缆调制解调器；一个互联了基站及带有电缆调制解调器的固定PC的路由器。</p>
<ol start="3">
<li>广域无线接入：3G和LTE</li>
</ol>
<p>移动设备应用了无线基础设施，通过蜂窝网提供商运营的基站来发送和接收分组。</p>
<h3 id="1-2-2-物理媒体"><a href="#1-2-2-物理媒体" class="headerlink" title="1.2.2 物理媒体"></a>1.2.2 物理媒体</h3><p>因特网中使用的传输媒体：HFC使用光缆和同轴电缆；DSL和以太网使用双绞铜线；移动接入网使用无线电频谱。</p>
<p><strong>物理媒体</strong>：导引型媒体和非导引型媒体。</p>
<p>导引型：电波沿着固体媒体前行(双绞铜线、光缆或同轴电缆)</p>
<p>非导引型：电波在空气或外层空间传播(无线局域网或数字卫星频道)</p>
<p><strong>1.双绞铜线</strong>：便宜，应用于电话网。两根绝缘的铜线组成，许多双绞线捆扎在一起形成一根电缆。无屏蔽双绞线常用在建筑物内中，即LAN中。所能达到的传输速率却决于线的粗细以及传输方和接收方的距离。</p>
<p><strong>2.同轴电缆</strong>：两个铜导体组成。同轴电缆能被用作导引型共享媒体。</p>
<p><strong>3.光纤</strong>：柔软、引导光脉冲的媒体。每个脉冲表示一个比特。成为长途导引型媒体，特别用于海底链路。</p>
<p><strong>4.陆地无线电信道</strong>：依赖传播环境和信号传输的距离。环境上考虑取决于路径损耗和遮挡衰落、多径衰落以及干扰。</p>
<p><strong>5.卫星无线电信道</strong>：地面站的含义:通信卫星连接地球上的微波发射/接收器。该卫星在一个频段上接收传输，使用下一个转发器再生信号。两类卫星：同步卫星和近地轨道。</p>
<h2 id="1-3-网络核心"><a href="#1-3-网络核心" class="headerlink" title="1.3 网络核心"></a>1.3 网络核心</h2><p>网络核心：互联因特网端系统的分组交换机和链路构成的网状网络。</p>
<h4 id="1-3-1-分组交换"><a href="#1-3-1-分组交换" class="headerlink" title="1.3.1 分组交换"></a>1.3.1 分组交换</h4><p><strong>报文</strong>：端系统彼此交换的东西关系。报文可以执行控制功能，也可以包含数据。</p>
<p><strong>分组</strong>：从源端系统向目的地端系统发送一个报文，源将长报文划分为较小的数据块。</p>
<p>在源和目的地之间，每个分组都通过通信链路和分组交换机传送。</p>
<p><strong>分组交换机</strong>：路由器和链路层交换机。</p>
<h5 id="1-存储转发传输"><a href="#1-存储转发传输" class="headerlink" title="1.存储转发传输"></a>1.存储转发传输</h5><p>指在交换机能够开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组。</p>
<p>通过由N条速率均为R的链路组成的路径，端到端时延是$d_{端到端}=NL/R$。</p>
<h5 id="2-排队时延和分组丢失"><a href="#2-排队时延和分组丢失" class="headerlink" title="2.排队时延和分组丢失"></a>2.排队时延和分组丢失</h5><p><strong>输出缓存</strong>：对于每条相连的链路，该分组交换机具有一个输出缓存。</p>
<p><strong>排队时延</strong>：分组要在排队的链路中等待。</p>
<p><strong>丢包</strong>：缓存已被其他等待传输的分组完全充满了。</p>
<h5 id="3-转发表和路由选择协议"><a href="#3-转发表和路由选择协议" class="headerlink" title="3.转发表和路由选择协议"></a>3.转发表和路由选择协议</h5><p>路由器从与它相连的一条通信链路得到分组，在因特网中，每个端系统具有一个称之为IP地址的地址。分组首部包含了IP地址。每台路由器具有一个<strong>转发表</strong>，用于将目的地址映射成为输出链路。因特网具有特殊的路由选择协议。</p>
<h4 id="1-3-2-电路交换"><a href="#1-3-2-电路交换" class="headerlink" title="1.3.2 电路交换"></a>1.3.2 电路交换</h4><p>通过网络链路和交换机移动数据有两种方法：电路交换和分组交换。</p>
<p>电路交换预留了端系统沿路径通信所需要的资源(缓存、链路传输速率)，分组交换不预留。</p>
<p>端到端连接：两台主机之间。</p>
<h5 id="1-电路交换中的复用"><a href="#1-电路交换中的复用" class="headerlink" title="1. 电路交换中的复用"></a>1. 电路交换中的复用</h5><p>链路中电路通过<strong>频分复用</strong>FDM或<strong>时分复用</strong>TDM 实现。</p>
<p><strong>带宽</strong>：频段的宽度。</p>
<p>对于FDM，链路的频谱由跨越链路创建的所有连接共享。</p>
<p>对于TDM，时间被划分为固定期间的帧，每个帧又被划分为固定数量的时隙。</p>
<h5 id="2-分组交换与电路交换对比"><a href="#2-分组交换与电路交换对比" class="headerlink" title="2.分组交换与电路交换对比"></a>2.分组交换与电路交换对比</h5><p>分组交换更有效。</p>
<h4 id="1-3-3-网络的网络"><a href="#1-3-3-网络的网络" class="headerlink" title="1.3.3 网络的网络"></a>1.3.3 网络的网络</h4><p>端系统经过一个接入ISP与因特网相连。</p>
<p>单一的全球传输的ISP互联接入所有ISP。我们假想的全球传输ISP是一个由路由器和通信链路构成的网络。</p>
<p>在任何区域，可能有一个区域ISP，区域中的接入ISP与之连接。每个区域ISP则与第一层ISP连接。</p>
<p>一个区域可能有多个竞争的区域ISP。ISP逐级交付费用。</p>
<p><strong>存在点 PoP</strong>：提供商网络中的一台或多台路由器群组</p>
<p><strong>多宿</strong>：可以与两个或更多提供商ISP连接</p>
<p><strong>对等</strong>：直接将他们网络连接在一起。</p>
<p><strong>因特网交换点IXP：</strong>IXP是一个汇合点，多个ISP能够在这里一起对等。</p>
<h2 id="1-4-分组交换中的时延、丢包和吞吐量"><a href="#1-4-分组交换中的时延、丢包和吞吐量" class="headerlink" title="1.4 分组交换中的时延、丢包和吞吐量"></a>1.4 分组交换中的时延、丢包和吞吐量</h2><h5 id="1-4-1-分组交换网中的时延概述"><a href="#1-4-1-分组交换网中的时延概述" class="headerlink" title="1.4.1 分组交换网中的时延概述"></a>1.4.1 分组交换网中的时延概述</h5><p>分组会在沿途的每个节点经受几种不同的时延：节点处理时延、排队时延、传输时延和传播时延。</p>
<p><strong>处理时延</strong>：检查分组首部和决定将该分组导向何处所需要的时间。</p>
<p><strong>排队时延</strong>：分组在链路上等待传输。</p>
<p><strong>传输时延</strong>：将所有分组的比特推向链路。路由器推出分组的时间。</p>
<p><strong>传播时延</strong>：链路起点到路由器B传播所需的时间是传播时延。d/s。</p>
<p>$d_{proc}$为处理时延；$d_{queue}$为排队时延；$d_{trans}$为传输时延；$d_{prop}$为传播时延；节点总时延：$d_{nodal}=d_{proc}+d_{queue}+d_{trans}+d_{prop}$。</p>
<h5 id="1-4-2-排队时延和丢包"><a href="#1-4-2-排队时延和丢包" class="headerlink" title="1.4.2 排队时延和丢包"></a>1.4.2 排队时延和丢包</h5><p><strong>排队时延</strong>对不同的分组可能是不同的。</p>
<p>排队时延速度：取决于流量到达该队列的速率，链路的传输速率和到达流量的性质，即流量是周期性到达还是以突发形式到达。</p>
<p>流量强度：比率La/R。La/R&lt;=1。</p>
<p>随着流量强度接近于1，平均排队时延迅速增加。该强度的少量增加将导致时延大比例增加。</p>
<p>如果到达的分组发现满队列，由于没有地方存储这个分组，路由器将丢弃该分组，分组会丢失</p>
<h5 id="1-4-3-端到端时延"><a href="#1-4-3-端到端时延" class="headerlink" title="1.4.3 端到端时延"></a>1.4.3 端到端时延</h5><p>含义：源到目的地时延。</p>
<ol>
<li>Traceroute</li>
</ol>
<p>一个短报文，包含路由器名字和地址。</p>
<ol start="2">
<li>端系统、应用程序和其他时延。</li>
</ol>
<h5 id="1-4-4-计算机网络中的吞吐量"><a href="#1-4-4-计算机网络中的吞吐量" class="headerlink" title="1.4.4 计算机网络中的吞吐量"></a>1.4.4 计算机网络中的吞吐量</h5><p><strong>瞬时吞吐量</strong>：主机B接收到该文件的速率。</p>
<p><strong>平均吞吐量</strong>：接收到的大小除以花费的时间。</p>
<p><strong>瓶颈链路传输的速率</strong>：限制吞吐的链路，取两段上速率最小的那段。</p>
<p>吞吐量取决于最小速率，也取决于吞吐量。</p>
<h2 id="1-5-协议层次及其服务模型"><a href="#1-5-协议层次及其服务模型" class="headerlink" title="1.5 协议层次及其服务模型"></a>1.5 协议层次及其服务模型</h2><h3 id="1-5-1-分层体系结构"><a href="#1-5-1-分层体系结构" class="headerlink" title="1.5.1 分层体系结构"></a>1.5.1 分层体系结构</h3><h4 id="1-协议分层"><a href="#1-协议分层" class="headerlink" title="1.协议分层"></a>1.协议分层</h4><p>网络设计者以<strong>分层</strong>的方式组织协议。某层向它的上一层提供的服务。</p>
<p>各层所有协议被称为协议栈，因特网的协议栈分为五种：物理层、链路层、网络层、运输层和应用层。</p>
<img src="https://img-blog.csdnimg.cn/ced5ff7ff3454a6c9c18d4109ed229ea.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWFUgSG9uZ2R1bw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="图片来源：https://image.baidu.com/search/detail?ct=503316480&z=0&ipn=d&word=5%E5%B1%82%E5%9B%A0%E7%89%B9%E7%BD%91%E5%8D%8F%E8%AE%AE%E6%A0%88&step_word=&hs=0&pn=13&spn=0&di=7077213605308923905&pi=0&rn=1&tn=baiduimagedetail&is=0%2C0&istype=0&ie=utf-8&oe=utf-8&in=&cl=2&lm=-1&st=undefined&cs=2245168335%2C1557936172&os=1782924538%2C2879332916&simid=3440522025%2C331546831&adpicid=0&lpn=0&ln=787&fr=&fmq=1650605817814_R&fm=&ic=undefined&s=undefined&hd=undefined&latest=undefined&copyright=undefined&se=&sme=&tab=0&width=undefined&height=undefined&face=undefined&ist=&jit=&cg=&bdtype=0&oriquery=&objurl=https%3A%2F%2Fgimg2.baidu.com%2Fimage_search%2Fsrc%3Dhttp%3A%2F%2Ffilescdn.proginn.com%2Ff222019c13f1bba14835bbf2b0dff60a%2Fd3fbef3cfc575c2aa9a60c87946a76f2.webp%26refer%3Dhttp%3A%2F%2Ffilescdn.proginn.com%26app%3D2002%26size%3Df9999%2C10000%26q%3Da80%26n%3D0%26g%3D0n%26fmt%3Dauto%3Fsec%3D1653197831%26t%3D6365f613229bbf8fc182509466a9b28b&fromurl=ippr_z2C%24qAzdH3FAzdH3F3tfi7tg_z%26e3Br652tgg_z%26e3Bv54AzdH3FrAzdH3F0mnkuk1mjw9k&gsm=e&rpstart=0&rpnum=0&islist=&querylist=&nojc=undefined&dyTabStr=MCw1LDEsNiw0LDMsNyw4LDIsOQ%3D%3D" style="zoom: 67%;" />

<p><strong>1.应用层</strong></p>
<p>是网络应用程序及它们的应用层协议存留的地方。</p>
<p>比如HTTP、SMTP和FRP协议。将端系统名字转换为网络地址是由DNS完成的。</p>
<p>应用层协议分布在多个<strong>端系统</strong>上，而一个端系统中的应用程序使用协议与另一个端系统中的应用程序交换信息分组。我们把这种位于应用层的信息分组称为 <strong>报文(message)</strong> 。</p>
<img src="https://img-blog.csdnimg.cn/47ed1ebc1d4c4043a2ed1a596c8654ec.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWFUgSG9uZ2R1bw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom:67%;" />

<p><strong>2.运输层</strong></p>
<p>因特网的 <strong>运输层</strong> 在应用程序端点之间传送 <strong>应用层报文</strong> 。而运输层的分组我们称之为 <strong>报文段(segment)</strong> 。</p>
<img src="https://img-blog.csdnimg.cn/362905f341684d918f5d1b607b7ee7ea.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWFUgSG9uZ2R1bw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom:67%;" />

<p><strong>3.网络层</strong></p>
<p>因特网的网络层负责将 <strong>数据报</strong> 的 <strong>网络层分组</strong> 从一台主机移动到另一台主机。<br>在一台源主机中的因特网 <strong>运输层协议（TCP或UDP）</strong> 向 <strong>网络层</strong> 递交运输层 <strong>报文段</strong> 和 <strong>目的地址</strong>。</p>
<img src="https://img-blog.csdnimg.cn/1b6e2a247c3e4227b2a54eee4667ecb5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWFUgSG9uZ2R1bw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom: 67%;" />

<p>因特网的网络层也包括决定<strong>路由的路由选择协议</strong>。他根据该路由将数据报从原传输到目的地。因特网具有许多路由选择协议。</p>
<p>简单地被称为IP层。</p>
<p><strong>4.链路层</strong></p>
<p>因特网的网络层通过源和目的地之间的一系列路由器路由数据报。为了将分组从一个节点（主机或路由器）移动到路径上的下一个节点，</p>
<p>网络层必须依靠该链路层的服务。特别是在每个节点，网络层将数据报下传给链路层，链路层沿着路径将数据报传递给下一个节点。在该下一个节点，链路层将数据报双传给网络层。</p>
<p>由链路层提供的服务取决于应用于该链路的 特定链路层协议。网络层会受到来自不同链路层协议的不同服务。<br>链路层的分组称为帧。</p>
<p><strong>5.物理层</strong></p>
<p>虽然链路层的任务是将整个 <strong>帧</strong> 从一个网络元素移动到临近的网络元素，而物理层的任务是将该 <strong>帧</strong> 中的一个个 <strong>比特</strong> 从一个节点移动到下一个节点。在这层中的协议仍然是链路相关的，并且进一步与该链路的 <strong>实际传输媒体</strong> 相关（比如双绞铜线或者光纤等）。</p>
<h4 id="2-OSI模型"><a href="#2-OSI模型" class="headerlink" title="2.OSI模型"></a>2.OSI模型</h4><p>20世纪70年代，ISO组织提出计算机网络围绕7层组织，称为<strong>开放系统互连模型</strong>。</p>
<p>分别是应用层、表示层、会话层、运输层、网络层、数据链路层和物理层。</p>
<h3 id="1-5-2-封装"><a href="#1-5-2-封装" class="headerlink" title="1.5.2 封装"></a>1.5.2 封装</h3><p>在发送主机端， 一个应用层 报文 (application-layer message) (图 1-24 中的 M) 被传送给运输层 。在最简单的情况下，运输层收取到报文并附上附加信息(所谓运输层首部信息，图 1-24 中的$H_1$),该首部将被接收端的运输层使用 。应用层报文和运输层首部信息一道构成了运输层报文段 (transport­ layer segment) 。运输层报文段因此封装了应用层报文。附加的信息也许包括了下列信息: 允许接收端运输层向上向适当的应用程序交付报文的信息；差错检测位信息，该信息让接收方能够判断报文中的比特是否在途中已被改变。运输层则向网络层传递该报文段，网 层增加了如源和目的端系统地址等网络层首部信息(图 1-24 中的$H_n$)生成了网络层数。该数据报 (network-layer datagram) 。 该数据报接下来被传递给链路层，链路层(自然而然地) 增加它自己的链路层首部信息并生成链路层帧 (link-layer frame) 。 所以我们看到，在每一层，一个分组具有两种类型的字段 : 首部字段和有效载荷字段 (payload field) 。有效载荷通常是来自上一层的分组 。</p>
<img src="计算机网络.assets\image-20220529133707931.png" alt="image-20220529133707931" style="zoom:50%;" />

<h2 id="1-6-被攻击的网络"><a href="#1-6-被攻击的网络" class="headerlink" title="1.6 被攻击的网络"></a>1.6 被攻击的网络</h2><p>网络安全：如何攻击网络，以及我们如何防御以免受他们的攻击。</p>
<p><strong>1.因特网有害程序嵌入计算机中</strong></p>
<p>恶意软件：感染设备，收集隐私信息。受害设备网络被称为<strong>僵尸网络</strong>。</p>
<p>多数恶意软件是自我复制。<strong>病毒</strong>是一种需要某种形式的用户交互来感染用户设备的恶意软件。蠕虫是一种无须任何明显用户交互就能进入设备的恶意软件。</p>
<p><strong>2.服务器和网络基础设施遭到攻击</strong></p>
<p>另一类宽泛类型的安全性威胁被称为**拒绝服务攻击(Denial-of-Service (DoS) attack)**。DoS攻击网络、主机或者其他基础设施部分。</p>
<p>DoS攻击分为弱点攻击、带宽洪泛或者连接洪泛。</p>
<p>弱点攻击：这涉及向 一 台目标主机上运行的易受攻击的应用程序或操作系统发送 制作精细的报文。如果适当顺序的多个分组发送给一个易受攻击的应用程序或操作系统，该服务器可能停止运行，或者更糟糕的是主机可能崩溃。</p>
<p>带宽洪泛：攻击者向目标主机发送大量的分组，分组数量之多使得目标的接入链路变得拥塞，使得合法的分组无法到达服务器 。</p>
<p>连接洪泛：攻击者在目标主机中创建大量的半开或全开 TCP 连接(将在第3章中讨论TCP连接) 。 该主机因这些伪造的连接而陷入困境，并停止接受合法的连接 。</p>
<p><strong>3.嗅探分组</strong></p>
<p>在无线传输设备的附近设置一台被动的接收机，会得到传输分组的副本。记录每个流经的分组副本的被动接受机被称为<strong>分组嗅探器</strong>。</p>
<p><strong>4.伪装成信任的人</strong></p>
<p>IP哄骗：一个用户能够冒充另一个用户的许多方式的一种。</p>
<p>解决这个问题的方式：端点鉴别：即一种使我们能够确信一个报文源自我们认为它应当来自的地方的机制。</p>
<h2 id="1-7-计算机网络和因特网的历史"><a href="#1-7-计算机网络和因特网的历史" class="headerlink" title="1.7 计算机网络和因特网的历史"></a>1.7 计算机网络和因特网的历史</h2><h3 id="1-7-1-分组交换的发展-1961-1972"><a href="#1-7-1-分组交换的发展-1961-1972" class="headerlink" title="1.7.1 分组交换的发展(1961-1972)"></a>1.7.1 分组交换的发展(1961-1972)</h3><p>开端：20世纪60年代早期。</p>
<p>全世界具有3个研究组首先发明了分组交换。</p>
<p>分组交换技术首次公开发表出自MIT一名研究生。Kleinrock使用排队论，完美地体现了使用分组交换方法处理突发性流量源的有效性。</p>
<p>1964年，兰德公司的Paul Baran已经开始研究分组交换的应用，以在军用网络上传输安全语音，同时在英国的NPL，Donald Davies和 Roger Scantlebury也在研究分组交换技术。</p>
<p>Robert公布了一个ARPAnet的总体计划，它是第一个分组交换计算机网络。</p>
<p>1969年的劳动节，第一台分组交换机在Kleinrock的监管下安装在美国加州大学洛杉矶分校。</p>
<p>1972年，ARPAnet已经成长到大约15个节点。NCP此时发展。1972年，Ray Tomlinson编写了第一个电子邮件程序。</p>
<h3 id="1-7-2-专用网络户网络互联：1972-1980"><a href="#1-7-2-专用网络户网络互联：1972-1980" class="headerlink" title="1.7.2 专用网络户网络互联：1972~1980"></a>1.7.2 专用网络户网络互联：1972~1980</h3><p>最初的 ARPAnet是一个单一的、封闭的网络。 为了与 ARPAnet 的一台主机通信， 一 台主机必须与另 一台 ARPAnet IMP 实际相连 。 20 世纪 70 年代早期和中期 ，除 ARPAnel 之 外的其他分组交换网络问世: ALOHAnet 是一个微波网络，它将夏威夷岛上 的大 学 [Abramson 1970] 以及 DARPA 的分组卫星[ RFC 829] 和分组无线电网 [Kahn 1987] 连 接到一起; Telenel是 BBN 的商用分组交换网，它基ARPAnet技术;由 Loui~Pouzin领衔 的Cyclades是法国的一个分组交换网 [Think2012];还有如Tymnet和GE信息服务网这样的分时网络，以及 20 世纪 60 年代后期和 70 年代初期的 类似网络[ Schwartz 1977 J; IBM 的 SNA (1996 - 1974) , 它与 ARPAnet 同时在运行 [Schwartz 1977]。</p>
<p>网络的数目开始增加.人们事后看到，研制将网络连接到 一 起的体系结构的时机已 经 成熟 。互联网络的先驱性工作(得到了美国国防部高级研究计划署 (DARPA) 的支持 )由 Vinton Cerf和 Robert Kahn [Cerf 1974] 完成，本质上就是创建一个网络的网络;术语网络互联 (intemetting) 就是用来描述该项工作的 。</p>
<p>这些体系结构的原则体现在TCP 中。然而，TCP 的早期版本与今天的 TCP 差异很大 ” TCP 的早期版本将通过端系统重传的可靠按序数据传递 (仍是今天的 TCP 的 一 部分) 与 转发功能(今天该功能由 IP 执行)相结合 。 TCP 的早期 实验以及认识到对诸 如分组语 音 这样的应用程序中不可靠的、非流控制的 、 端到端传递服务的重要性，导致 IP 从 TCP 中 分离出来，并研制了 UDP 协议 。 我们今天看到的 3 个重要的因特网协议 一 TCP、 UDP 和IP, 到 20 世纪 70 年代末在概念上已经完成 。</p>
<p>除了 DARPA 的因特网相关研究外，许多其他重要的网络活动也在进行中 。 在夏威夷Norman Abramson 正在研制 ALOHAnet, 这是一个基于分组的无线电网络，它使在夏威夷岛 上的多个远程站点互相通信。 ALOHA协议 [Abramson1970] 是第一个多路访问协议，允许地理上分布的用户共享单一的广播通信媒体( 一个无线 电频率 ) 。 Metcalfe 和 Boggs 基 千 Abramson 的多路访问协议，研制了用 于有线共享广播网络的以太网协议 [Metcalfe 1976 ] c 令人感兴趣的是， Metcalfe 和 Boggs 的以太网协议是由连接多台 PC 、打印机和共享磁盘在一起的需求所激励的[ Perkins 1994J。 在 PC 革命和网络爆炸的 25 年之前， Metcalfe 和 Boggs 就奠定了今天 PC LAN 的基础 。</p>
<h3 id="1-7-3-网络的激增：1980-1990"><a href="#1-7-3-网络的激增：1980-1990" class="headerlink" title="1.7.3 网络的激增：1980~1990"></a>1.7.3 网络的激增：1980~1990</h3><p>到了20世纪70年代末，大约200台主机与ARPAnet相连。 到了20世纪80年代末， 连到公共因特网的主机数量达到 100000 台，那时的公共因特网是网络的联盟，看起来非 常像今天的因特网 。 20世纪80年代是联网主机数量急剧增长的时期 。</p>
<p>这种增长是由几个显著成果即创建计算机网络将大学连接到一起引起的 。BITNET 为 位于美国东北部的几个大学之间提供了电子邮件和文件传输 。 建立了 CSNET (计算机科学 网)，以将还没有接人 ARPAnet 的大学研究人员连接在一起。 1986 年，建立了 NSFNET, 为 NSF 资助的超级计算中心提供接入 。 NSFNET 最初具有 56kbps 的主干速率，到了20世纪80年代末，它的主干运行速率是 l. 5Mbps, 并成为连接区域网络的基本主干 。</p>
<p>Minitel项目的发展。</p>
<h3 id="1-7-4-因特网爆炸：20世纪90年代"><a href="#1-7-4-因特网爆炸：20世纪90年代" class="headerlink" title="1.7.4 因特网爆炸：20世纪90年代"></a>1.7.4 因特网爆炸：20世纪90年代</h3><p>1991 年， NSFNET解除了对NSFNET用于商业目的的限制。NSFNET 自身于1995年退役，这时因特网主干流量则由商业因特网服务提 供商负责承载。</p>
<p>然而， 20 世纪 90 年代的主要事件是万维网 (World Wide Web) 应用程序的出现，它将因特网带入世界上数以百万计的家庭和商业中。 Web 作为一个平台，也引入和配置了数 百个新的应用程序，其中包括搜索(如谷歌和Bing) 、因特网商务( 如亚马逊和eBay) 以及社交网络(如脸书)，对这些应用程序我们今天巳经习以为常了 。</p>
<p>Web是由 Tim Bemers-Lee 于 1989 - 1991 年间在 CERN 发明的[ Berners-Lee 1989] ,最初的想法源于 20 世纪 40 年代 Vannevar Bush [ Bush 1945 ] 和 20 世纪 60 年代以来 Ted Nelson [ Xanadu 2012] 在超文本方面的早期工作 。 Bemers-Lee 和他的同事研制了 HTML、 HTTP、 Web 服务器和浏览器的初始版本，这是 Web 的 4 个关键部分 。 到了 1993 年年底前 后，大约有 200 台 Web 服务器在运行，而这些只是正在出现 的 Web 服务器的冰山 一 角 。 就在这个时候，几个研究人员研制了具有 GUI 接口的 Web 浏览器，其中的 Marc Andrees- sen 和 Jim Clark 一起创办了 Mosaic Communications 公司，该公司就是后来的 Netscape 通信 公司[ Cusmano 1998 ; Quittner 1998] 。 到了 1995 年，大学生们每天都在使用 Netscape 浏览器在 Web 上冲浪 。 大约在这段时间，大大小小的公司都开 始运行 Web 服务器，并在 Web 上处理商务 。 1996 年，微软公司开始开发浏览器，这导致了 Netscape 和微软之间的 浏览器之战，并以微软公司在几年后获胜而告终[ Cusumano 1998] 。</p>
<p>20 世纪 90 年代的后5年，随着主流公司和数以千计的初创公司创造了大量因特网产品和服务，因特网到了飞速增长和创新的时期。到了 2000 年末，因特网巳经支待数百流行的应用程序，包括以下4种备受欢迎的应用程序：<br>• 电子邮件，包括附件和 Web 可访问的电子邮件 。<br>• Web,包括Web浏览和因特网商务。<br>• 即时讯息 (i皿tanl messaging) , 具有联系人列表 。<br>• MP3的对等 (peer-to-peer) 文件共享，由Napster开创。</p>
<h3 id="1-7-5-最新发展"><a href="#1-7-5-最新发展" class="headerlink" title="1.7.5 最新发展"></a>1.7.5 最新发展</h3><p>计算机网络中的变革继续以急促的步伐前进。所有的前沿研究正在取得进展，包括部署更快的路由器和在接入网和网络主干中提供更高的传输速率 。 但下列进展值得特别关注:<br>• 自 2000 年开始，我们见证了家庭宽带因特网接入的积极部署一不仅有电缆调制 解调器和 DSL, 而且有光纤到户，这些在 1.2 节中讨论过 。这种高速因特网为丰 富的视频应用创造了条件，包括用户生成的视频的分发 (例如 YouTube) 、电影和<br>电视节目的按需流(例如 Netflix) 以及多人视频 会议(例如 Skype、 Facetime 和 Google Hangouts) 。<br>• 高速 (54Mbps 及更高)公共 WiFi 网络和经过 4G 蜂窝电话网的中速(几十 Mbps) 因特网接入越来越普及，不仅使在运动中保持持续连接成为可能，也产生了新型特定位置应用，如 Yelp、 Tinder、 Yik Yak 和 Waz。 2011 年，与因特网连接的无线 设备的数量超过了有线设备的数量 。 高速无线接入为手持计算机 (iPhone、安卓 手机 、 iPad 等)的迅速出现提供了舞台，这些手持计算机 具有对因特网持续不断 和无拘束接入的优点 。<br>• 诸如脸书 、 lnstagram、 推特 (Twitter) 和微信(在中国极为流行 )这样 的在 线 社交网络已经在因特网之上构建了巨大的人际网络 。 这些社交网络，许多广泛 用于发送消息以及照片分享 。 许多因特网用户今天主要“ 生活”在一个或多个 社交网络中 。 通过他们的 API, 在线社交网络为新的联网应用和分布式游戏创建了平台 。<br>• 如在 I. 3. 3 节中所讨论的，在线服务提供商如谷歌和微软 巳经广泛部署了自己的<br>专用网络。该专用网络不仅将它们分布在全球的数据中心连接在一起，而且通过 直接与较低层 ISP 对等连接，能够尽可能绕过因特网 。因此，谷歌几乎可以瞬间提供搜索结果和电子邮件访问，仿佛它们的数据中心运行在自己的计算机中 一样 。<br>• 许多因特网商务公司在“云”(如亚马逊的 EC2、谷歌的应用引擎 、微软的 Azw·e)中运行它们的应用 。 许多公司和大学也已经将它们的因特网应用(如电子邮件和 Web 托管)迁移到云中 。 云公司不仅可以为应用提供可扩展的计算和存储环境， 也可为应用提供对其高性能专用网络的隐含访问 。</p>
<p><strong>课后习题和问题</strong></p>
<p>复习题：</p>
<p>R1:没有区别。根据书本内容，“主机”和“终端系统”是交换使⽤的。终端系统包括PC、⼯作站、⽹络服务器、邮件服务器、PDA、连接⽹络的游戏控制台等等。⽹络服务器是终端系统。</p>
<p>R2:外交协议常⽤于描述⼀系列国家来往规则。这些构建完备和经过时间检验的规则可以使国家和⼈⺠⽣活和⼯作更简单。协议规则以⼈⺠准则为基础， 其中的⼀部分已经作为现在等级地位的声明。</p>
<p>R3:标准对于协议来说，可以让⼈们创建可以相互操作的⽹络系统和产品。</p>
<p>R4:（1）通过电话线的拨号调制解调器：家庭 （2）通过电话线的DSL（Digital Subscriber Line，数字⽤⼾线）：家庭或⼩办公室 （3）混合光纤同轴电缆：家庭 （4）100M交换以太⽹：企业 （5）⽆线⽹：家庭或企业 （6）3G和4G：⼴域⽆线⽹</p>
<p>R5:HFC带宽是由⽤⼾共享。下⾏通道中，所有的包都是由头端这⼀个单⼀源发出的。因此，下⾏通道中没有碰撞。</p>
<p>R6:光纤到⼾、3G和4G⽆线⽹</p>
<p>R7:10M、100M、1G、10G</p>
<p>R8:双绞线、光纤</p>
<p>R9:拨号调制解调器：最⾼56K，带宽专⽤</p>
<p>ADSL：下⾏最⾼24M，上⾏最⾼2.5M，带宽专⽤ HFC：下⾏最⾼42.8M，上⾏最⾼30.7M，带宽共享 FTTH：上⾏2-10M，下⾏10-20M，带宽不共享</p>
<h1 id="第二章-应用层"><a href="#第二章-应用层" class="headerlink" title="第二章 应用层"></a>第二章 应用层</h1><h2 id="2-1-应用层协议原理"><a href="#2-1-应用层协议原理" class="headerlink" title="2.1 应用层协议原理"></a>2.1 应用层协议原理</h2><p>网络应用程序：核心是写出能够运行在不同的端系统和通过网络彼此通信的程序。</p>
<p><strong>服务器</strong>：</p>
<ul>
<li>7<em>24 小时*<em>提供服务</em></em></li>
<li>可永久性访问的IP地址 / 域名</li>
<li>利用大量服务器实现可扩展性</li>
</ul>
<p><strong>客户机</strong>：</p>
<ul>
<li>与服务器通信，<strong>使用服务器提供的服务</strong></li>
<li>可以间歇性接入网络</li>
<li>可以使用动态 IP 地址</li>
<li>客户机之间没有任何协作、通信</li>
</ul>
<h3 id="2-1-1-网络应用程序体系结构"><a href="#2-1-1-网络应用程序体系结构" class="headerlink" title="2.1.1 网络应用程序体系结构"></a>2.1.1 网络应用程序体系结构</h3><p><strong>应用程序体系结构：</strong>由应用程序研发者设计，规定了如何在各种端系统上组织该应用程序。在选择应用程序体系结构时，有两种主流体系结构：客户-服务器体系结构或者对等P2P结构</p>
<p><strong>客户-服务器体系结构</strong>：一个总是打开的主机称为服务器，服务于称为客户的主机。当 Web 服务器接收到 来自某客户对某对象的请求时，它向该客户发送所请求的对象作为响 应 。 值得注意的是利用客户-服务器体系结构 ，客户相互之间不直接通信 ;例如.在 Web应用中两个浏览器并不直接通信 。 客户-服务器体系结构的另 一个特征是该服务器具有固 定的、周知的地址，该地址称为 IP 地址(我们将很快讨论它) 。 因为该服务器具有固定的 、 周知的地址，并且因为该服务器总 是打开的，客户总是能够通过向该服务器的 IP 地 址发送分组来与其联系 。 具有客户 - 服务器体系结构的非常著名的应用程序包括 Web、 FTP、 Telnet和电子邮件。 图2-2a中显示了这种客户-服务器体系结构。</p>
<p>数据中心是用来创建强大的虚拟服务器。一个数据中心有数十万台服务器。</p>
<p><strong>P2P体系结构</strong>：对位于数据中心的专用服务器有最小(没有)依赖。应用程序在间断连接的主机之间使用直接通信，主机成为对等方。该体系结构也被称为对等方到对等方。</p>
<p>比如文件共享、下载加速器、因特网电话和视频会议。</p>
<p>特性：自拓展性。</p>
<p>挑战：高度非集中结构、安全性、性能和可靠性挑战。</p>
<h3 id="2-1-2-进程通信"><a href="#2-1-2-进程通信" class="headerlink" title="2.1.2 进程通信"></a>2.1.2 进程通信</h3><p>通信实际上是进程。一个进程可认为是运行在端系统中的程序。在不同端系统上的进程通过跨越计算机网络交换报文而互相通信。发送方生成并向网络中发送，接收进程接受并通过回送报文进行响应。</p>
<p><strong>1.客户和服务器进程</strong></p>
<p>进程通过网络相互发送报文。对于两个进程，一个被标记为客户，另一个被标记为服务器。</p>
<p><strong>2.进程与计算机网络之间的接口</strong></p>
<p>进程通过被称为<strong>套接字</strong>的软件接口向网络发送和接收报文。</p>
<p>如该图所示，套接字是同一台主机内应用层与运输层之间的接口。也被称为**应用程序编程接口(API)**。</p>
<p>由于该套接字是建立网络应用程序的可编程接口，因此套接字也称为应用程序和网络之间的应用程序编程接口 (Application Programming Interface, API ) 应用程序开发者可以控制套接字在应用层端的一切，但是对该套接字的运输层端几乎没有控制权。应用程序开发者对千运输层的控制仅限于: ①选择运输层协议; ②也许能设定几 个运输层参数，如最大缓存和最大报文段长度等(将在第3章中涉及) 。一旦应用程序开发者选择了一个运输层协议(如果可供选择的话) ，则应用程序就建立在由该协议提供的运输层服务之上。</p>
<p><strong>3.进程寻址</strong></p>
<p>为了向特定目的地发送邮政邮件，目的地需要有一个地址。类似地，在一台主机上运行的进程为了向在另一台主机上运行的进程发送分组，接收进程需要有一个地址。为了标识该接收进程，需要定义两种信息 : ①主机的地址；②在目的主机中指定接收进程的标识符。</p>
<p>因特网中，主机由其<strong>IP地址</strong>标识。IP地址32比特，除了知道报文发送目的地的主机地址外，发送进程还必须指定运行在接收主机上的<br>接收进程(更具体地说，接收套接字) 。 因为一般而言一台主机能够运行许多网络应用， 这些信息是需要的 。 目的地端口号 (port number) 用于这个目的 。 已经给流行的应用分配了特定的端口号。 例如， Web服务器用端口号80来标识。 邮件服务器进程(使用SMTP 协议)用端口号 25 来标识 。 用于所有因特网标准协议的周知端口号的列表能够在<a target="_blank" rel="noopener" href="http://www.iana.org处找到/">http://www.iana.org处找到</a> 。 </p>
<h3 id="2-1-3-可供应用程序使用的运输服务"><a href="#2-1-3-可供应用程序使用的运输服务" class="headerlink" title="2.1.3 可供应用程序使用的运输服务"></a>2.1.3 可供应用程序使用的运输服务</h3><p>套接字是应用程序进程和运输层协议之间的接口。</p>
<p>运输层协议要为不同的应用程序提供不同的服务。大致分为：可靠数据传输、吞吐量、定时和安全性。</p>
<p><strong>1.可靠数据传输</strong></p>
<p>确保由应用程序一端发送的数据正确。</p>
<p><strong>2.吞吐量</strong></p>
<p>带宽敏感应用：具有吞吐量敏感的应用。</p>
<p>弹性应用：根据当时可用的带宽或多或少利用可供使用的吞吐量。</p>
<p><strong>3.定时</strong></p>
<p>运输层协议也能提供定时保证。如同具有吞吐量保证那样，定时保证能够以多种形式实现。一个保证的例子如: 发送方注入进套接字中的每个比特到达接收方的套接字不迟于100ms。 这种服务将对交互式实时应用程序有吸引力，如因特网电话、虚拟环境、电话会 议和多方游戏，所有这些服务为了有效性而要求数据交付有严格的时间限制。</p>
<p><strong>4.安全性</strong></p>
<p>运输协议能够为应用程序提供一种或多种安全性服务。</p>
<p>例如，在发送主机中，运输协议能够加密由发送进程传输的所有数据，在接收主机中，运输层协议能够将数据交付给接收进程之前解密这些数据 。这种服务将在发送和接收进程之间提供机密性，以防该数据以某种方式在这两个进程之间被观察到。 </p>
<h3 id="2-1-4-因特网提供的运输服务"><a href="#2-1-4-因特网提供的运输服务" class="headerlink" title="2.1.4 因特网提供的运输服务"></a>2.1.4 因特网提供的运输服务</h3><p>因特网为应用程序提供两个运输层协议：TCP和UDP。</p>
<p><strong>1.TCP服务</strong></p>
<p>TCP服务模型包括面向连接服务和可靠数据传输服务。当某个应用程序调用TCP作为其运输协议时,该应用程序就能获得来自 TCP的这两种服务。</p>
<p><strong>面向连接的服务</strong>:在应用层数据报文开始流动之前，TCP让客户和服务器互相交换运输层控制信息。这个所谓的握手过程提示客户和服务器，使它们为大量分组的到来做好准备。在握手阶段后，一个 TCP连接（TCP connection) 就在两个进程的套接字之间建立了。这条连接是全双工的,即连接双方的进程可以在此连接上同时进行报文收发。</p>
<p><strong>可靠的数据传送服务</strong>:通信进程能够依靠TCP，无差错、按适当顺序交付所有发送的数据。当应用程序的一端将字节流传进套接字时，它能够依靠TCP将相同的字节流交付给接收方的套接字，而没有字节的丢失和冗余。</p>
<p>TCP协议还具有<strong>拥塞控制</strong>机制和<strong>分组开销</strong>，这种服务不一定能为通信进程带来直接好处，但能为因特网带来整体好处。当发送方和接收方之间的网络出现拥塞时，<strong>TCP的拥塞控制机制会抑制发送进程</strong>（客户或服务器)。TCP拥塞控制也试图限制每个TCP连接,使它们达到公平共享网络带宽的目的。</p>
<p>3次握手 4次放手</p>
<p>特点：1.面向连接</p>
<p>2.每一条tcp连接只能点对点(一对一)</p>
<p>3.提供可靠交付的服务</p>
<p>4.提供全双工服务</p>
<p>5.面向字节流</p>
<p><strong>2.UDP服务</strong></p>
<p>UDP是一种轻量级运输协议。UDP是无连接的，因此在两个进程通信前没有握手过程。UDP协议提供一种不可靠数据传送服务，也就是说，<strong>当进程将一个报文发送进UDP套接字时,UDP协议并不保证该报文将到达接收进程。</strong>到达接收进程的报文也可能是乱序到达的。</p>
<p>UDP没有包括拥塞控制机制,所以UDP的发送端可以用它选定的任何速率向其下层(网络层）注入数据。</p>
<p>特点：1.无链接</p>
<p>2.尽最大努力</p>
<p>3.面向报文</p>
<p>4.无拥塞控制</p>
<p>5.支持一对一、一对多、多对一、多对多的交互通信</p>
<p>6.首部开销小，(只有4个字段 源端口、目的端口、长度、检验和)</p>
<p><strong>3.因特网运输协议所不提供的服务</strong></p>
<p>4个方面组织了运输协议服务:可靠数据传输、吞吐量、定时和安全性。TCP和UDP提供了这些服务中的哪些呢?我们已经注意到TCP提供了可靠的端到端数据传送。并且我们也知道TCP在应用层可以很容易地用SSL来加强以提供安全服务。但在我们对TCP 和UDP的简要描述中，明显地缺少了对吞吐量或定时保证的讨论，即这些服务目前的因特网运输协议并没有提供。这是否意味着诸如因特网电话这样的时间敏感应用不能运行在今天的因特网上呢?答案显然是否定的，因为在因特网上运行时间敏感的应用已经有多年了。这些应用工作得相当好，因为它们已经被设计成尽最大可能对付这种保证的缺乏。总之,今天的因特网通常能够为时间敏感应用提供满意的服务，但它不能提供任何定时或带宽保证。</p>
<h3 id="2-1-5-应用层协议"><a href="#2-1-5-应用层协议" class="headerlink" title="2.1.5 应用层协议"></a>2.1.5 应用层协议</h3><p>定义：运行在不同端系统上的应用程序进程如何相互传递报文。</p>
<p>交换的报文类型、各种报文类型的语法、字段的语义、确定一个进程何时以及发送报文。</p>
<p>有些协议是由RFC文档定义。</p>
<h3 id="2-1-6-本书涉及的网络应用"><a href="#2-1-6-本书涉及的网络应用" class="headerlink" title="2.1.6 本书涉及的网络应用"></a>2.1.6 本书涉及的网络应用</h3><p>5种重要的应用：Web、文件传输、电子邮件、目录服务、流式视频和P2P。</p>
<p>DNS：网络名字到网络地址的转换。</p>
<h2 id="2-2-Web和HTTP"><a href="#2-2-Web和HTTP" class="headerlink" title="2.2 Web和HTTP"></a>2.2 Web和HTTP</h2><h3 id="2-2-1-HTTP概况"><a href="#2-2-1-HTTP概况" class="headerlink" title="2.2.1 HTTP概况"></a>2.2.1 HTTP概况</h3><p>1.Web应用层协议：超文本传输协议(HTTP),是Web核心。</p>
<p>HTTP由两个程序实现：一个客户程序和服务器程序。客户和服务器通过交换HTTP报文进行绘画，</p>
<p>2.Web页面(文档)由对象组成</p>
<ul>
<li><p>一个对象是一个文件。可以是HTML文件、JPEG图像、Java <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=applet&spm=1001.2101.3001.7020">applet</a>、音频文件等。</p>
</li>
<li><p>多数网页由单个基本HTML文件和若干个所引用的对象构成。</p>
</li>
<li><p>每个对象被一个URL（统一资源定位符）寻址。(每个URL地址由两部分组成：**存放对象的服务器主机名和对象的路径名)**。</p>
</li>
</ul>
<p>URL形象的给出了任何一个对象、任何一个资源在互联网中的位置。例如</p>
<p><img src="https://img-blog.csdnimg.cn/20210709084904597.png" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/97ab2d33fa04456989bca20d68587771.png" alt="在这里插入图片描述"></p>
<p>注意：路径一般是虚拟路径，它不一定代表这台主机上面实际的本地路径。</p>
<p><strong>URL和域名的区别</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/310534288">网址中的www是什么意思? - 知乎 (zhihu.com)</a></p>
<p><strong>域名</strong><br>域名是由一串用“.”分隔的名字组成的Internet上某一台计算机或计算机组的名称。</p>
<p>作用：用来将主机名和域名转换为IP地址的工作。</p>
<p>域名，Domain Name，通常指一个网址的顶级域名。</p>
<p><strong>URL</strong></p>
<p>URL，website address，网页或网站的地址。URL以字符串的抽象形式来描述一个资源在万维网上的地址。统一资源定位符，是一种资源位置的抽象唯一识别方法。一个URL唯一标识一个Web资源，通过与之对应的URL即可获得该资源。可以用来定位网页,多媒体文件等</p>
<p><code>常用的URL格式如下：协议类型://主机or服务器地址[:端口号]/路径/文件名[参数=值]</code></p>
<p>URL中包含了网站的域名.<br>比如一个网址：<a target="_blank" rel="noopener" href="http://www.cnblogs.com/gopark/p/8430916.html%E3%80%82%E5%85%B6%E4%B8%ADcnblogs.com%E6%98%AF%E5%9F%9F%E5%90%8D%EF%BC%8Ccnblogs%E6%98%AF%E7%BD%91%E7%AB%99%E5%90%8D%E5%AD%97%EF%BC%8Ccom%E6%98%AF%E5%9F%9F%E5%90%8D%E5%90%8E%E7%BC%80%EF%BC%9Bwww.cnblogs.com%E4%BB%A3%E8%A1%A8%E4%B8%80%E4%B8%AA%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D%EF%BC%8C%E9%80%9A%E5%B8%B8www%E8%A2%AB%E7%94%A8%E6%9D%A5%E7%94%A8%E4%B8%BA%E9%A6%96%E9%A1%B5%E6%A0%87%E8%AF%86%EF%BC%9B">www.cnblogs.com/gopark/p/8430916.html。其中cnblogs.com是域名，cnblogs是网站名字，com是域名后缀；www.cnblogs.com代表一个二级域名，通常www被用来用为首页标识；</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/gopark/p/8430916.html%EF%BC%8C%E8%BF%99%E4%B8%AA%E5%88%99%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E7%BD%91%E7%AB%99%E9%A6%96%E9%A1%B5URL%E5%9C%B0%E5%9D%80%E3%80%82https://%EF%BC%8C%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E5%8D%8F%E8%AE%AE%EF%BC%8C%E6%98%AF%E7%BD%91%E7%AB%99%E5%9C%A8%E7%BD%91%E4%B8%8A%E4%BC%A0%E8%BE%93%E7%9A%84%E5%8D%8F%E8%AE%AE%E3%80%82">https://www.cnblogs.com/gopark/p/8430916.html，这个则是一个完整的网站首页URL地址。https://，这是一个协议，是网站在网上传输的协议。</a></p>
<p>Web服务器实现了HTTP的服务器端，它用于存储Web对象。它用于存储Web对象。每个对象由URL寻址。流行的服务器有Apache和微软互联网信息中心。</p>
<p><strong>访问阶段</strong></p>
<p>HTTP定义了Web客户向Web服务器请求Web页面，以及服务器向客户传送Web页面方式。</p>
<p>我们使用HTTP协议进行访问时主要有两个阶段<br>1.当用户请求一个 Web 页面(如点击一个超链接)时，浏览器向服务器发出对该页面中所包含对象的 HTTP请求报文。</p>
<p>2.服务器接收到请求并用包含这些对象的 HTTP 响应报文进行响应。</p>
<p>注意：不管是什么类型的主机，什么类型的客户端，只要遵从HTTP协议，就可以和遵从HTTP协议的服务器端通信。在下图列出两种。</p>
<p><img src="F:\计算机网络\计算机网络.assets\image-20220531182849694.png" alt="image-20220531182849694"></p>
<p><strong>特点</strong></p>
<p>1.HTTP使用TCP作为它的支撑运输协议。</p>
<p>（1）客户端初始化一个与HTTP服务器80端口的TCP连接，也就是创建套接字。<br>（2）HTTP服务器接收来自客户的TCP连接请求，建立连接。<br>（3）Browser和Web服务器交换HTTP消息（应用层协议消息），包括HTTP请求和响应消息。<br>（4）最后关闭TCP连接。</p>
<p>客户向它的套接字接口发送HTTP 请求报文并从它的套接字接口接收HTTP响应报文。</p>
<p>服务器从它的套接字接口接收HTTP请求报文和向它的套接字接口发送 HTTP 响应报文。一旦客户向它的套接字接口发送 一个请求报文，该报文就脱离了客户控制并进入 TCP 的控制 。</p>
<p>最大特点：HTTP协议不用担心数据丢失，也不关注TCP从网络的数据丢失和乱序故障中恢复的细节。</p>
<p>2、无状态协议<br>无状态协议，即不维护客户先前的状态信息。<br>例如访问某个网页访问到一半时网络断掉了，当从新连上网再去访问时就要重新开始。</p>
<p>做成无状态的原因：维护状态的协议非常复杂，具体为：<br>（1）必须维护过去历史。<br>（2）如果server/client崩溃，它们各自的状态视图可能不一致，因此必须保持协调一致。</p>
<h3 id="2-2-2-非持续性连接和持续连接"><a href="#2-2-2-非持续性连接和持续连接" class="headerlink" title="2.2.2 非持续性连接和持续连接"></a>2.2.2 非持续性连接和持续连接</h3><p>HTTP连接可以分为持久性连接和非持久性连接。</p>
<p><strong>非持续连接</strong>：每个请求/响应对经过一个单独的TCP连接发送。</p>
<p><strong>持续连接</strong>：每个请求/响应对经过相同的TCP连接发送</p>
<p><strong>响应时间模型</strong></p>
<p>为了区别持久性连接和非持久性连接的时间、效率等，需要定义一些响应时间模型。</p>
<p>1、定义往返时间RTT</p>
<p>1个小分组从客户机到服务器再到客户机所花费的时间我们可以称之为RTT。</p>
<p>2、响应时间分析<br>（1）1个RTT用于建立TCP连接<br>（2）1个RTT用于HTTP请求/响应消息的交互<br>（3）HTML文件传输的时间=2RTT+传输时间<br>通过下图更直观的显示了时间响应模型：</p>
<p><img src="https://img-blog.csdnimg.cn/20210709111423816.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><strong>1.采用非持续连接的HTTP</strong></p>
<p>我们看看在非待续连接情况下 ，从服务楛向客户传送一个Web页面的步骤。假设该页面含有一个 HTML 基本文件和 10 个 JPEG 图形、并且这 11 个对象位于同 一 台服务器上。进一步假设该 HTML文件的 URL 为: <a target="_blank" rel="noopener" href="http://www.someschool.edu/someDepartment/home.index%E3%80%82">http://www.someSchool.edu/someDepartment/home.index。</a><br>我们看看发生了什么情况 :</p>
<ol>
<li>HTTP客户进程在端口号80发起一个到服务器<a target="_blank" rel="noopener" href="http://www.someschool.edu的tcp连接,该端口号是/">www.someSchool.edu的TCP连接，该端口号是</a> HTTP 的默认端口。在客户和服务器上分别有一个套接字与该连接相关联 。</li>
<li>HTTP客户经它的套接字向该服务器发送一个HTTP 请求报文。请求报文中包含了路径名/someDepartment/home.index (后面我们会详细讨论HTTP报文)。</li>
<li>HTTP 服务器进程经它的套接字接收该请求报文，从其存储器 (RAM 或磁盘)中 检索出对象<a target="_blank" rel="noopener" href="http://www.someschool.edu/someDepartment/home.index%EF%BC%8C%E5%9C%A8%E4%B8%80%E4%B8%AAHTTP%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E4%B8%AD%E5%B0%81%E8%A3%85%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%B9%B6%E9%80%9A%E8%BF%87%E5%85%B6%E5%A5%97%E6%8E%A5%E5%AD%97%E5%90%91%E5%AE%A2%E6%88%B7%E5%8F%91%E9%80%81%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87">www.someSchool.edu/someDepartment/home.index，在一个HTTP响应报文中封装对象，并通过其套接字向客户发送响应报文</a> 。</li>
<li>HTTP服务器进程通知 TCP 断开该 TCP 连接 。 (但是直到TCP确认客户已经完整地收到响应报文为止，它才会实际中断连接。</li>
<li>HTTP 客户接收响应报文，TCP连接关闭。该报文指出封装的对象是一个HTML文件客户从响应报文中提取出该文件，检查该 HTML 文件，得到对10个JPEG 图形的引用 。</li>
<li> 对每个引用的 JPEG 图形对象重复前 4 个步骤。</li>
</ol>
<p>当浏览器收到 Web 页面后，向用户显示该页面 。 两个不同的浏览器也许会以不同的方式解释 ( 即向用户显示)该页面。HTTP 与客户如何解释一个Web页面毫无关系。HTTP规范([RFC 1945] 和[RFC 2616]) 仅定义了在HTTP客户程序与HTTP服务器程序之间的通信协议 。</p>
<p>每个TCP连接在服务器发送一个对象后关闭，该连接不为其他对象而持续下来。每个TCP连接只传输一个请求报文和响应报文。</p>
<p><strong>往返时间</strong></p>
<p>Round-Trip Time,RTT.该时间是指一个短分组从客户到服务器然后再返回客户所花费的时间。RTT包括分组传播时延、分组在中间路由器和交换机上的排队时延以及分组处理时延。</p>
<img src="F:\计算机网络\计算机网络.assets\image-20220601132924928.png" alt="image-20220601132924928" style="zoom: 33%;" />

<p>涉及三次握手过程。</p>
<p>即客户向服务器发送一个小TCP报文段，服务器用一个小 TCP 报文段做出确认和响应，最后，客户向服务器返回确认。三次握手中前两个部分所耗费的时间占用了一个 RTT。完成了三次握手的前两个部分后，客户结合三次握手的第三部分(确认)向该 TCP 连接发送一个 HTTP 请求报文。一旦该请求报文到达服务器，服务器就在该 TCP 连接上发送 HTML文件 。该 HTTP 请求/响应用去了另一个RTT。 因此，粗略地讲，总的响应时间就是两个 RTT 加上服务器传输 HTML 文件的时间。</p>
<p><strong>2.采用持续连接的HTTP</strong></p>
<p>非持续连接的缺点：</p>
<ol>
<li>必须为每个请求的对象建立和维护一个全新的连接。</li>
<li>每一个对象经受两倍RTT的交付时延。</li>
</ol>
<p>在持续连接的情况下：服务器发送响应后保持该TCP连接打开。在相同的客户与服务器之间，后续的请求和响应报文，能够通过相同的连接进行传送。例子：一个完整的Web页面可以用单个持续TCP连接进行传送。甚至位于同一台服务器的多个Web页面在从服务器发送给同一个客户时，可以在单个持续TCP连接上进行。对对象的这些请求可以一个接一个地发出，而不必等待对未决请求的回答。</p>
<p><strong>HTTP 1.0和HTTP 1.1的主要区别是什么?</strong></p>
<ol>
<li>长连接 : 在HTTP/1.0中，默认使用的是短连接，也就是说每次请求都要重新建立一次连接。HTTP是基于TCP/IP协议的,每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。因此最好能维持一个长连接，可以用个长连接来发多个请求。HTTP1.1起，默认使用长连接 ,默认开启Connection： keep-alive。 HTTP/1.1的持续连接有非流水线方式和流水线方式 。流水线方式是客户在收到HTTP的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。</li>
<li>带宽优化及网络连接的使用 : HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>
<li>Host域：在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。HTTP1.0是没有host域的，HTTP1.1才支持这个参数。</li>
<li>错误状态响应码 : 在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li>
<li>缓存处理 : 在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li>
</ol>
<p><strong>HTTP2.0的优化</strong></p>
<ol>
<li>新的二进制格式：HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</li>
<li>多路复用：在同一个TCP连接中，同一时刻可以发送多个请求和响应,下一次的请求不需要等待上一个响应来之后再发送。但响应的顺序是不变的，FIFO（先进先出）。2.0之前是同一个连接只能用一次， 如果开启了keep-alive，虽然可以用多次，但是同一时刻只能有一个HTTP请求。</li>
<li>HTTP2.0的多路复用主要是指：因为http2.0的传输是基于二进制帧的。每一个TCP连接中承载了多个双向流通的流，每一个流都有一个独一无二的标识和优先级，而流就是由二进制帧组成的。二进制帧的头部信息会标识自己属于哪一个流，所以这些帧是可以交错传输，然后在接收端通过帧头的信息组装成完整的数据。这样就解决了线头阻塞的问题，同时也提高了网络速度的利用率。</li>
<li>header压缩，HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用HPACK算法对header的数据进行压缩，避免了重复header的传输，又减小了需要传输数据的大小，基本原理是客户端和服务端分别缓存一份索引表，如果头部存在于索引表，则用对应的索引值；否则进行霍夫曼编码，并加入索引表。参考</li>
<li>服务器推送， 当我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源。服务器端推送的这些资源其实存在客户端的某处地方，客户端直接从本地加载这些资源就可以了，不用走网络，速度自然是快很多的。</li>
</ol>
<h3 id="2-2-3-HTTP报文格式"><a href="#2-2-3-HTTP报文格式" class="headerlink" title="2.2.3 HTTP报文格式"></a>2.2.3 HTTP报文格式</h3><p>HTTP报文是面向文本的，报文中的每一个字段都是一些ASCII码串，每个字段的长度是不确定的。HTTP报文传过来的都是一堆的0x ASCII码，例如” 41 63 63 65 70 74”这段十六进制ASCII码串对应的是“accept” 单词。</p>
<p>这些十六进制的数字经过浏览器或者专用工具比如wireshark或fiddler的翻译，可以得到HTTP的报文结构。</p>
<h5 id="请求头部"><a href="#请求头部" class="headerlink" title="请求头部"></a>请求头部</h5><p>请求头部为请求报文添加了一些附加信息，由“名/值”对组成，每行一对，名和值之间使用冒号分隔。请求头部通知服务器有关于客户端请求的信息。比较常见的有：</p>
<p><img src="https://img-blog.csdnimg.cn/70810659bd9e4ffd831dc14464e997a9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAWXNtaW5nODg=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>HTTP有两种报文：请求报文和响应报文。</p>
<p><strong>1.请求报文</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET http://jsuacm.cn/ HTTP/1.1</span><br><span class="line">Host: jsuacm.cn</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.25 Safari/537.36 Core/1.70.3877.400 QQBrowser/10.8.4506.400</span><br><span class="line">Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line"></span><br><span class="line">//”请求数据”(GET方式的请求一般不包含)</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/28f0146f4568480abf9afe951dbfddc9.png" alt="在这里插入图片描述"></p>
<p><strong>可见HTTP的请求报文由四部分组成：请求行(request line)、请求头部(header)、空行和请求数据(request data)</strong></p>
<p>第一行：请求行(方法字段、URL字段和HTTP版本字段，<strong>们用空格分隔</strong>。例如：GET <a target="_blank" rel="noopener" href="http://jsuacm.cn/template/jsu/css/modifypage-1.css">http://jsuacm.cn/template/jsu/css/modifypage-1.css</a> HTTP/1.1)</p>
<p>请求方法字段：HTTP协议的请求方法有GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT。GET和POST是最常用的请求方法。</p>
<p>请求头部的最后会有一个空行，表示请求头部结束，接下来为请求数据。</p>
<p>后继行：首部行</p>
<p>首部行：Host 指明对象所在的主机。</p>
<p>Connection：close首部行，告诉服务器是否使用持续连接，它要求服务器在发送完被请求的浏览器的类型。</p>
<p>Accept-language：首部行表示用户想得到该对象的法语版本(如果服务器中有这样的对象)；否则，服务器应当发送它的默认版本。</p>
<p>Accpet-language：首部行仅仅是HTTP中可用的众多内容协商首部之一。</p>
<p>首部行后有一个”实体体“。</p>
<p>使用Get方法时实体体为空，使用POST方法才使用该实体体。</p>
<p><strong>POST</strong></p>
<p>提交表单，搜索：POST方法。</p>
<p>和get一样很常见，对于上面提到的不适合使用GET方式的情况，可以考虑使用POST方式，因为使用POST方法可以允许客户端给服务器提供信息较多。POST方法将请求参数封装在HTTP请求数据中，以名称/值的形式出现，可以传输大量数据，这样POST方式对传送的数据大小没有限制，而且也不会显示在URL中。</p>
<p><strong>GET</strong></p>
<p>HTML表单经常使用GET方法。</p>
<p>最常见的一种请求方式，当客户端要从服务器中读取文档时，当点击网页上的链接或者通过在浏览器的地址栏输入网址来浏览网页的，使用的都是GET方式。GET方法要求服务器将URL定位的资源放在响应报文的数据部分，回送给客户端。使用GET方法时，请求参数和对应的值附加在URL后面，利用一个问号（“?”）代表URL的结尾与请求参数的开始，传递参数长度受限制。</p>
<p>GET方式的请求一般不包含”请求数据”部分，请求数据以地址的形式表现在请求行。显然，这种方式不适合传送私密数据。另外，由于不同的浏览器对地址的字符限制也有所不同，一般最多只能识别1024个字符，所以如果需要传送大量数据的时候，也不适合使用GET方式。<br><strong>HEAD</strong></p>
<p>HEAD方法类似GET方法。本质和get一样，只不过服务端接受到HEAD请求后只返回响应头，而不会发送响应内容。当我们只需要查看某个页面的状态的时候，使用HEAD是非常高效的，因为在传输的过程中省去了页面内容。</p>
<p><strong>PUT</strong></p>
<p>PUT 方法常与 Web 发行工具联合使用，它允许用户上传对象到指定的 Web 服务 器上指定的路径(目录)。PUT方法也被那些需要向 Web服务器上传对象的应用程序使 用 。和post类似，html表单不支持，发送资源与服务器，并存储在服务器指定位置，可用于替换资源，要求客户端事先知道该位置。</p>
<p><strong>DELETE</strong></p>
<p>DELETE 方法允许用 户或者应用程序删除Web服务器上的对象。请求服务器删除某资源。和put都具有破坏性，可能被防火墙拦截。如果是https协议，则无需担心。</p>
<p>CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。就是把服务器作为跳板，去访问其他网页然后把数据返回回来，连接成功后，就可以正常的get、post了。</p>
<p>OPTIONS：获取http服务器支持的http请求方法，允许客户端查看服务器的性能，比如ajax跨域时的预检等。</p>
<p>TRACE：回显服务器收到的请求，主要用于测试或诊断。一般禁用，防止被恶意攻击或盗取信息。</p>
<p><strong>2.HTTP响应报文</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Connection: close</span><br><span class="line">Date: Wed, 20 Oct 2021 06:46:15 GMT</span><br><span class="line">Server: nginx/1.18.0 (Ubuntu)</span><br><span class="line">Last-Modified Wed, 20 Oct 2021 06:11:15 GMT</span><br><span class="line">Content-Length: 737265</span><br><span class="line">Content-Type: text/html</span><br></pre></td></tr></table></figure>

<p>三部分：初始状态行、6个首部行、然后是实体体。</p>
<p>实体体：报文主要部分，包含了所请求的对象本身。状态行有3个字段：协议版本字段、状态码和相应状态信息。</p>
<blockquote>
<p> 首部行:</p>
</blockquote>
<p>Connection：close首部行告诉客户，发送完将关闭该TCP连接。</p>
<p>Date：首部行指示服务器产生并发送该响应报文的日期和时间。</p>
<p>Server：由什么服务器产生。类似请求报文中的User-Agent：首部行。</p>
<p>Last-Modified：首部行指示了对象创建或者最后修改的日期和时间。</p>
<p>Content-Length：首部行指示了实体体中的对象是HTML文本。</p>
<p>Content-Type：首部行指示了实体体中的对象是HTML文本。</p>
<p><img src="F:\计算机网络\计算机网络.assets\image-20220603233418699.png" alt="image-20220603233418699"></p>
<p><strong>状态行</strong></p>
<p>状态行由3部分组成，分别为：协议版本、状态码、状态码描述。其中协议版本与请求报文一致，状态码描述是对状态码的简单描述。</p>
<p>HTTP状态码</p>
<p><img src="https://img-blog.csdnimg.cn/08f780f945204228b2d30d141de06e38.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAWXNtaW5nODg=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><strong>响应头部</strong></p>
<p>常见响应头部及描述如下：</p>
<p><img src="https://img-blog.csdnimg.cn/e0fdcf851081478f8d21d383829528d1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAWXNtaW5nODg=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><strong>空行</strong></p>
<p>响应头部的最后会有一个空行，表示响应头部结束，接下来为响应数据。与请求报文一致。</p>
<p><strong>响应体</strong></p>
<p>用于存放需要返回给客户端的数据信息。fiddler抓出来的一段HTTP响应数据是一段HTML。</p>
<h3 id="2-2-4-用户与服务器的交互-cookie"><a href="#2-2-4-用户与服务器的交互-cookie" class="headerlink" title="2.2.4 用户与服务器的交互:cookie"></a>2.2.4 用户与服务器的交互:cookie</h3><p>HTTP服务器是无状态的（也就是不记录请求服务的客户机的信息），但是有时候Web站点希望可以识别用户，以实现诸如限制用户访问和识别用户身份的功能。为此，Web站点使用了cookie技术（注意：cookie不属于HTTP协议，他是补充HTTP某方面功能性不足的技术）。</p>
<p>cookie有四个组件：</p>
<ol>
<li>在HTTP响应报文中保留一个cookie首部行</li>
<li>在HTTP请求报文中保留一个cookie首部行</li>
<li>用户端系统中保留有一个cookie文件，并由用户的浏览器进行管理</li>
<li>位于Web站点的一个管理cookie的后端总数据库</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20210710111611842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>cookie可以标识用户，后继会话中，浏览器向服务器传递一个cookie首部，服务器标识用户。因此cookie可以在无状态的HTTP之上建立一个用户会话层。</p>
<p>cookies带来了很多方便和便利的地方。常见的有：<br>（1）身份认证：例如我们在登录某个网站时填写登录表单，只填写一次即可。<br>（2）用户会话状态恢复：将上次访问的会话状态记录下来，等下次再访问的时候可以恢复到上次的状态，而不需要重头开始。<br>（3）虚拟购物车：例如我们在逛淘宝时看到心仪的商品会加入到购物车中，等到下一次重新打开时购物车里的东西不会消失。<br>（4）推荐广告：广告公司通过网站获得信息，为他们的广告投放提供便利。</p>
<h3 id="2-2-5-Web缓存"><a href="#2-2-5-Web缓存" class="headerlink" title="2.2.5 Web缓存"></a>2.2.5 Web缓存</h3><p>也叫**代理器(proxy server)**：能够代表初始Web服务器来满足HTTP请求的网络实体。Web缓存器有自己的磁盘存储空间，并在存储空间中保存最近请求过的对象的副本。</p>
<img src="F:\计算机网络\计算机网络.assets\image-20220604195238630.png" alt="image-20220604195238630" style="zoom:67%;" />

<p>假设浏览器正在请求对象<a target="_blank" rel="noopener" href="http://www.someschool.edu/campus.gif%EF%BC%8C%E5%B0%86%E4%BC%9A%E5%8F%91%E7%94%9F%E4%B8%80%E4%B8%8B%E6%83%85%E5%86%B5%EF%BC%9A">http://www.someschool.edu/campus.gif，将会发生一下情况：</a></p>
<p>1)浏览器创建一个到Web缓存器的TCP连接，并向Web缓存器中的对象发送一个HTTP请求。</p>
<p>2)Web缓存器进行检查，看看本地是否存储了该对象副本。如果有， Web 缓存器就向客户浏览器用HTTP响应报文返回该对象 。</p>
<p>3)如果Web缓存器中没有该对象，它就打开一个与该对象的初始服务器(即 <a target="_blank" rel="noopener" href="http://www.someschool.edu/">www.someschool.edu</a>) 的TCP连接。Web缓存器则在这个缓存器到服务器的TCP连接上发送一个对该对象的HTTP 请求。在收到该请求后，初始服务器向该 Web 缓存器发送具有该 对象的 HTTP 响应 。</p>
<p>4)当 Web缓存器接收到该对象时，它在本地存储空间存储一份副本，并向客户的浏览器用 HTTP 响应报文发送该副本(通过现有的客户浏览器和 Web 缓存器之间的 TCP 连接) 。</p>
<p>值得注意的是 Web 缓存器既是服务器又是客户。当它接收浏览器的请求并发回响应时，它是一个服务器。当它向初始服务器发出请求并接收响应时，它是一个客户。</p>
<p>这里需要注意的是缓存器既是服务器又是客户机，简单来说：<br>（1）对客户端来说是服务器<br>（2）对原始服务器来说是客户端<br>大学、公司是使用缓存器的典型。</p>
<p>那么为什么需要Web缓存器呢？主要原因有以下三点：<br>（1）减少对客户机请求的响应时间<br>（2）减少内部网络与接入链路上的通信量<br>（3）能从整体上大大降低因特网的Web流量</p>
<p>通过内容分发网络(CDN)，Web缓存器正在因特网中发挥着越来越重要的作用。</p>
<h3 id="2-2-6-条件GET方法"><a href="#2-2-6-条件GET方法" class="headerlink" title="2.2.6 条件GET方法"></a>2.2.6 条件GET方法</h3><p>在使用Web缓存技术时要用一种新的方法，叫GET方法。<br>GET方法目的：证实缓存器中的对象是否为最新。<br>方法具体内容为：<br>（1）缓存器：在请求报文中包含对象最后修改时间。以判断从缓存器中得到的信息是否为最新。<br>（2）服务器：如果对象是最新的那么响应报文中不包含对象，否则需要包含最新对象。</p>
<h2 id="2-3-因特网中的电子邮件"><a href="#2-3-因特网中的电子邮件" class="headerlink" title="2.3 因特网中的电子邮件"></a>2.3 因特网中的电子邮件</h2><p>包括3部分：用户代理、邮件服务器和简单邮件传输协议(SMTP)。</p>
<p>清楚报文队列概念。</p>
<h3 id="2-3-1-SMTP"><a href="#2-3-1-SMTP" class="headerlink" title="2.3.1 SMTP"></a>2.3.1 SMTP</h3><p>SMTP是因特网电子邮件的核心。</p>
<p>SMTP协议是互联网上最古老的应用之一，是电子邮件所采用的协议，是电子邮件发送电子邮件时的协议。</p>
<p>用户代理：运行在客户端的软件。</p>
<p>作用：<br>（1）它允许用户阅读，回复，转发，保存，编辑邮件消息。<br>（2）发送/接收邮件消息到/从服务器。<br>（3）运行邮件协议。</p>
<p><strong>邮件服务器</strong>：也就是我们常说的邮箱存放的位置。</p>
<p>作用：<br>（1）用邮箱存放用户接收的邮件消息。事实上现在绝大部分邮件服务器也同时存放发送的邮件。<br>（2）在邮件服务器上有一个外出报文队列，在里面放的是用户将要发送的邮件。邮件服务器可能需要很多邮件要发送，这时需要排队。<br>（3）运行邮件信息。邮件服务器要通过运行邮件协议来进行邮件的发送。</p>
<p>SMTP特点：</p>
<p>（1）使用TCP协议<br>（2）服务器端口号为25<br>（3）直接传送：SMTP协议是一种直接传送的协议。即发送服务器与接收服务器直连，没有经过中转。<br>（4）采用命令/应答的交互方式。<br>命令：ASCII文本格式<br>应答：状态码及其短语<br>（5）邮件消息必须是7-bit ASCII：邮件消息必须是标准ASCII码，因为邮件协议比较古老，设计者在设计邮件协议时并没有考虑到其他国家即非英语的国家使用邮件时怎么办。</p>
<p>三个阶段：（1）握手<br>（2）传输邮件消息<br>（3）结束</p>
<p><img src="F:\计算机网络\计算机网络.assets\image-20220604215509064.png" alt="image-20220604215509064"></p>
<p>SMTP不向中间邮件服务器发送邮件</p>
<p>首先，客户 SMTP (运行在发送邮件服务器主 机上)在 25 号端口建立一个到服务器 SMTP (运行在接收邮件服务器主机上)的 TCP 连接。如果服务器没有开机，客户会 在稍后继续尝试连接。一旦连接建立，服务器和客户执行某些应用层的握手，就像人们在互相交流前先进行自我介绍一样。SMTP的客户和服务器在传输信息前先相互介绍。在 SMTP 握手的阶段， SMTP 客户指示发送方的邮件地址(产生报文的那个人) 和接收方的邮件地址。一旦该 SMTP 客户和服务器彼此介绍之后，客户发送该报文。SMTP 能依赖 TCP 提供的可靠数据传输无差错地将邮件投递到接收服务器。该客户如果有另外的报文要发送到该服务器，就在该相同的TCP连接上重复这种处理；否则，它指示 TCP关闭连接。</p>
<p>下面我们来看一下SMTP客户端和服务器的命令交互：</p>
<p><img src="F:\计算机网络\计算机网络.assets\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70#pic_center.png" alt="在这里插入图片描述"></p>
<p>蓝色：我们需要输入的命令<br>黑色：给出的应答<br>（1）当我们连接服务器时，服务器会给出一个220响应，表示连上了。<br>（2）之后客户端要握手，握手的命令是HELO，后面给出一个域。<br>（3）S给出250回应，表示握手成功，后面的短语也可以自己定义。<br>（4）接下来C给出MAIL FROM命令告诉服务器我要以这个电子邮件作为发送方来发送邮件。<br>（5）S继续给出250表示可以发送。<br>（6）然后C使用RCPT TO命令来给出我要将邮件发送到哪个地址。<br>（7）服务器端收到命令以后再次给出250回应表示可以.<br>（8）给出354的提示告诉客户端你现在可以写邮件了，邮件要以单独的句号作为结束，而且句号必须独占一行。<br>（9）接下来就是客户端写邮件，当写完以后送到服务器端。（10）服务器端再次给出250回应表示这个消息被接收了放到队列里准备被发送。<br>（11）C给出QUIT命令退出。<br>（12）S给出221回应表示连接结束。<br>注意：SMTP通过回车换行、句号、回车换行来判断消息的结束。</p>
<h3 id="2-3-2-与HTTP的对比"><a href="#2-3-2-与HTTP的对比" class="headerlink" title="2.3.2 与HTTP的对比"></a>2.3.2 与HTTP的对比</h3><p>（1）HTTP是拉协议，即用户把消息拉下来；SMTP是推协议，即用户把消息推出去。<br>（2）都有ASCII命令/应答交互，状态码。SMTP要求报文采用7比特ASCII码格式。HTTP不受限制。<br>（3）HTTP：每个对象封装在它各自的HTTP响应报文中发送；SMTP：一个邮件内各个对象置于同一个邮件消息的多目的发送。</p>
<h3 id="2-3-3-邮件报文格式"><a href="#2-3-3-邮件报文格式" class="headerlink" title="2.3.3 邮件报文格式"></a>2.3.3 邮件报文格式</h3><p>邮件消息格式是在RFC 822里面规定的。</p>
<p>每一个典型的邮件报文都包含首部行和报文体。</p>
<p>一个标准的邮件格式分为头部和信体两部分，头部由多个头部行构成。列出最常见的三个。<br>（1）To：发给谁<br>（2）From：谁发送的<br>（3）Subject：邮件的主题<br>在写邮件时这三个必不可少。<br>注意：这里的To、From是邮件内容组成部分，这些头部不同于SMTP命令。<br>头部后再加一个空行之后跟邮件的主体，也就是邮件的信体。</p>
<p>首部行和报文体用空格分割。</p>
<p><img src="https://img-blog.csdnimg.cn/20210712122222479.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from:</span><br><span class="line">to:</span><br><span class="line">subject:</span><br></pre></td></tr></table></figure>

<p>报文首部之后，紧接着一个空白行，然后是以ACSII格式表示的报文体。输入telnet serverName25。</p>
<h3 id="2-3-4-邮件访问协议"><a href="#2-3-4-邮件访问协议" class="headerlink" title="2.3.4 邮件访问协议"></a>2.3.4 邮件访问协议</h3><p><strong>1.访问类型:</strong></p>
<p>邮件访问协议的作用是从服务器中取出邮件。常用的邮件访问协议有三类。<br>（1）POP3第三版的邮局协议：授权、下载邮件<br>（2）IMAP因特网邮件访问协议：相比POP，具有更多特性，比如分类管理服务器上的邮件。<br>（3）HTTP：例如Gmail、Hostmail、QQ邮箱、网易邮箱等都提供了使用HTTP来进行邮件访问的功能。</p>
<p><img src="F:\计算机网络\计算机网络.assets\image-20220604222857726.png" alt="image-20220604222857726"></p>
<h4 id="1-POP3协议"><a href="#1-POP3协议" class="headerlink" title="1.POP3协议"></a>1.POP3协议</h4><p>POP协议使用最多的是第三个版本，所以也叫POP3。包括3个阶段。<br>（1）特许<br>（2）事务处理<br>（3）更新</p>
<p><strong>特许阶段</strong>：用户代理发送(以明文形式)用户名和口令以鉴别用户。</p>
<p>主要有两个命令：user<user name>和pass<password></p>
<p>服务器对命令有两个回答:+OK(指示前面命令正常)和-ERR(指示前面命令出现某些差错)。</p>
<img src="https://img-blog.csdnimg.cn/20210712134235520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:67%;" />

<p>当连接到server时给出连接响应，服务器等待客户端给出命令；<br>客户端发送user bob命令过去；<br>S接收到以后C再给出password；<br>若用户名和密码没有问题，S给出OK回应，OK后的短语可以自行定义。</p>
<p><strong>事务处理阶段</strong>：用户代理取回报文，同时在这个阶段用户代理还能进行如下操作：对报文做删除标记，取消报文删除标记，以及获取邮件的统计信息。</p>
<p>当我们获得授权以后就进入到事务处理阶段。<br>在事务处理阶段客户端主要有以下几个命令可以使用：<br>（1）list：列出邮件编号，看一下服务器上有哪些邮件，服务器端给出的应答比较简单它给出若干个邮件的序号以及邮件的大小。<br>（2）retr：按编号取邮件<br>（3）dele：删除邮件。<br>（4）quit：<br>例子如下：<br><img src="https://img-blog.csdnimg.cn/20210712134420726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>更新阶段</strong>：客户发出quit命令后，结束该POP3会话。</p>
<h4 id="2-IMAP"><a href="#2-IMAP" class="headerlink" title="2.IMAP"></a>2.IMAP</h4><p>POP3无法为用户提供任何创建远程文件夹并为报文指派文件夹的方法。</p>
<p>IMAP是一个邮件访问协议，但是它比POP3具有更多的特色。</p>
<p>IMAP服务器把每个报文与一个文件夹联系起来：当报文第一次到达服务器时，它与收件人的INBOX文件夹相关联。收件人则能够把邮件移到 一个新 的、用户创建的文件夹中，阅读邮件，删除邮件等。IMAP 协议为用户提供 了创建文件夹以及将邮件从一个文件夹移动到另一个文件夹的命令。IMAP 还为用 户提供了在远程文件夹中查 询邮件的命令，按指定条件去查询匹配的邮件 。 值得注意的是，与POP3不同，IMAP服务器维护了IMAP会话的用户状态信息，例如，文件夹的名字以及哪些报文与哪些文件夹相关联。</p>
<p>IMAP的另一个重要特性是它具有允许用户代理获取报文某些部分的命令 ) 例如，一个用户代理可以只读取一个报文的报文首部，或只是一个多部分MIME报文的一部分。当用户代理和其邮件服务器之间使用低带宽连接 (如一个低速调制解调器链路)的时候，这个特性非常有用。使用这种低带宽连接时，用户可能并不想取回他邮箱中的所有邮件，尤<br>其要避免可能包含如音频或视频片断的大邮件 。</p>
<p><strong>POP3与IMAP</strong><br>之前使用的都是Download-and-delete方式，但是这种方式有一个问题，当换了一个客户端例如在公司用电脑收取邮件后回家用手机查看邮件时就看不到了，因为这些邮件在服务器上已经被删掉了。所以很多时候我们采用的是另一种模式叫Download-and-keep模式，这种模式的特点是下载邮件但是不删掉，当换一个客户端时还是可以阅读邮件。这时只要不使用delete命令就可以。<br>另外POP3的会话是无状态的即如果中间中断了就必须要重新操作。<br>POP3协议比较简单容易实现，但功能是有限的，所以后来人们开发了其它的邮件接收协议，这些协议可以支持更复杂的功能，其中最常见的就是IMAP，相比POP3而言IMAP有如下特征：<br>（1）保存所有邮件消息在一个位置：服务器，这时无论在哪个客户端操作，在其它客户端都可以看到操作的结果。<br>（2）允许用户在服务器的各文件夹中管理邮件消息<br>（3）IMAP可以维护用户会话的状态信息，最典型的例子就是它可以把文件夹和邮件消息的ID关联起来，即可以把邮件放到不同的文件夹里面，如同在本地操作文件系统的目录一样，这样就非常方便。<br>注意：在邮箱里面的各种文件夹其实是一个虚拟的，它和我们文件系统的文件夹是有区别的，但是不管怎么样它方便了用户的使用。</p>
<h4 id="3-基于Web的电子邮件"><a href="#3-基于Web的电子邮件" class="headerlink" title="3.基于Web的电子邮件"></a>3.基于Web的电子邮件</h4><p>在这种情况下，用户代理是普通的浏览器，用户和他远程邮箱之间的通信则通过HTTP进行。当一个收件人想从他的邮箱中访问一个报文时，该电子邮件报文从Bob的邮件服务器发送到他的浏览器。使用的是HTTP而不是POP3或IMAP协议。</p>
<p>当发件人(如 Alice) 要发送一封电子邮件报文时，该电子邮件报文从 Alice 的浏览器发送到她的邮件服务器，使用的是HTTP而不是SMTP, 然而，Alice-的邮件服务器在与其他的邮件服务器之间发送和接收邮件时，仍然使用的是 SMTP。</p>
<h2 id="2-4-DNS：因特网的目录服务"><a href="#2-4-DNS：因特网的目录服务" class="headerlink" title="2.4 DNS：因特网的目录服务"></a>2.4 DNS：因特网的目录服务</h2><p>主机名(hostname):<a target="_blank" rel="noopener" href="http://www.facebook.com./">www.facebook.com。</a></p>
<p>主机也可以用IP地址标识。</p>
<h3 id="2-4-1-DNS提供的服务"><a href="#2-4-1-DNS提供的服务" class="headerlink" title="2.4.1 DNS提供的服务"></a>2.4.1 DNS提供的服务</h3><p>DNS(Domain Name System，域名系统)作用：<strong>在IP地址和主机名之间建立连接，通俗的说就是给互联网上的主机取名字。主机名到IP地址转换的目录服务。</strong></p>
<p>DNS即域名系统本质上是由各种各样的服务器来完成相关功能的，这些服务器成为DNS服务器，DNS服务器提供了四个重要的功能。<br>（1）主机名到IP地址的转换；<br>（2）DNS可以提供<strong>主机别名这样的服务</strong>，也就是说一个主机可以有一个规范主机名和多个主机别名，例如现实生活中给别人起外号一样。<br>（3）可以为邮件服务器取别名。<br>（4）可以提供负载分配的功能：即可实现冗余服务器，一个IP地址集合可以对应于用一个规范主机名。这在如今互联网飞速发展的情况下非常有用。例如很多大型网站域名是统一的，例如<a href="http://www.163.com，但是后台肯定是一个庞大的服务器集群为域名提供相关服务。这时怎么做负载分配呢？DNS这时可以起到很重要的作用。">www.163.com，但是后台肯定是一个庞大的服务器集群为域名提供相关服务。这时怎么做负载分配呢？DNS这时可以起到很重要的作用。</a></p>
<p>DNS的特点：</p>
<p>①一个由分层的DNS服务器实现的分布式数据库；</p>
<p>②一个使得主机能够查询分布式数据库的应用层协议。DNS服务器通常是运行在BIND软件上的UNIX及其。DNS协议运行在UDP之上，端口是53。DNS服务器实现域名转换（域名/地址转换）。也就是说在DNS里面涉及到了IP地址，这个是网络层的构成元素，但是DNS是在应用层实现转换的，所以DNS是一个应用层协议。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/57987304">10分钟理解TCP、UDP 和端口号 - 知乎 (zhihu.com)</a></p>
<p>DNS协议是应用层协议。</p>
<p>DNS 通常是由其他应用层协议所使用的，包括 HTTP、SMTP和 FTP，将用户提供的主机名解析为IP地址。 举一个例子，考虑运行在某用户主机上的一个浏览器 (即一个HTTP客户)请求URL <a target="_blank" rel="noopener" href="http://www.someschooledu/index.html%E9%A1%B5%E9%9D%A2%E6%97%B6%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%E7%8E%B0%E8%B1%A1%E3%80%82%E4%B8%BA%E4%BA%86%E4%BD%BF%E7%94%A8%E6%88%B7%E7%9A%84%E4%B8%BB%E6%9C%BA%E8%83%BD%E5%A4%9F%E5%B0%86%E4%B8%80%E4%B8%AAHTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E5%8F%91%E9%80%81%E5%88%B0Web%E6%9C%8D%E5%8A%A1%E5%99%A8">www.someschooLedu/index.html页面时会发生什么现象。为了使用户的主机能够将一个HTTP请求报文发送到Web服务器</a> <a target="_blank" rel="noopener" href="http://www.someschool.edu/">www.someschool.edu</a>, 该用户主机必须 获得www. someschool. edu的IP地址。其做法如下:</p>
<ol>
<li>同一台用户主机上运行着 DNS 应用的客户端 .</li>
</ol>
<ol start="2">
<li>浏览器从上述 URL 中抽取出主机名 www. someschool. edu、并将这台主机名传给DNS 应用的客户端 。</li>
<li>DNS 客户向 DNS 服务器发送 一 个包含主机名的请求 。</li>
<li>DNS 客户最终会收到一份回答报文，其中含有对应于该主机名的 IP地址。</li>
<li>一 旦浏览器接收到来自 DNS 的该 IP 地址，它能够向位千该 IP 地址 80 端口的HTTP服务器进程发起一个 TCP连接。</li>
</ol>
<p>从这个例子中，我们可以看到 DNS 给使用它的因特网 应用带来了额外的时延，有时还相当可观。幸运的是，如我们下面讨论的那样，想获得的 IP 地址通常就缓存在 一个“附近的”DNS 服务器中，这有助于减少 DNS 的网络流量和 DNS 的平均时延。</p>
<p>DNS的其他服务有：</p>
<ol>
<li><strong>主机别名(host aliasing)：</strong>有着复杂主机名的主机能拥有一个或者多个别名。规范主机名和主机别名。</li>
<li><strong>邮件服务器别名(mail server aliasing)：</strong>电子邮件程序通过调用DNS，对提供的主机名别名进行解析，以获得该主机的规范主机名及其IP地址。</li>
<li>**负载分配(load distribution):**DNS也用于在冗余的服务器之间进行负载分配。 繁忙的站点被冗余分布在多台服务器上，每台服务器均运行在不同的端系统上，每个有着不同的IP地址。一个IP地址集合与同一个规范主机名相联系。DNS数据库中存储着这些IP地址集合。当客户对映射到某地址集合的名字发出一个DNS请求时，该服务器用IP地址的整个集合进行响应。</li>
</ol>
<h3 id="2-4-2-DNS工作机理概述"><a href="#2-4-2-DNS工作机理概述" class="headerlink" title="2.4.2 DNS工作机理概述"></a>2.4.2 DNS工作机理概述</h3><p>概述：假设运行在用户主机上的某些应用程序(如Web浏览器或邮件阅读器)需要将主机名转换为 IP 地址这些。应用程序将调用DNS的客户端，并指明需要被转换的主机名 (在很多基于 UNIX 的机器上，应用程序为了执行这种转换需要调用函数 gethostbyname())。用户主机上的 DNS 接收到后，向网络中发送 一 个 DNS 查询报文。所有的 DNS 请求和 回答报文使用 UDP 数据报经端口 53 发送。经过若干毫秒到若干秒的时延后，用户主机上的DNS接收到一个提供所希望映射的 DNS 回答报文。这个映射结果则被传递到调用 DNS 的应用程序。因此，从用户主机上调用应用程序的角度看，DNS 是一个提供简单、直接的转换服务的黑盒子。但事实上，实现这个服务的黑盒子非常复杂，它由分布于全球的大量DNS服务器以及定义了DNS服务器与查询主机通信方式的应用层协议组成 。</p>
<p>DNS 的一种简单设计是在因特网上只使用一个DNS 服务器，该服务器包含所有的映射。在这种集中式设计中，客户直接将所有查询直接发往单一的 DNS 服务器，同时该DNS服务器直接对所有的查询客户做出响应。尽管这种设计的简单性非常具有吸引力，但它不适用于当今的因特网，因为因特网有着数量巨大(并持续增长)的主机。这种集中式设计的问题包括：</p>
<p>**单点故障(a single point of failure):**如果该DNS服务器崩溃，互联网瘫痪。</p>
<p>**通信容量(traffic volume):**单个DNS服务器处理所有DNS查询。</p>
<p>**远距离的集中式数据库(distant):**时延严重。</p>
<p>**维护(maintenance):**单个DNS服务器会频繁更新，集中式的DNS维护比较麻烦</p>
<p>扩展起来也不方便。</p>
<p><strong>1.分布式、层次数据库</strong></p>
<p>下图是分布式、层次数据库的架构：</p>
<p><img src="https://img-blog.csdnimg.cn/20210712215031502.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>DNS使用大量DNS服务器，分布在全世界范围内。没有一台DNS服务器拥有因特网上所有主机的映射。有3种类型的服务器：根DNS服务器、顶级域(TLD)DNS服务器和权威DNS服务器。</p>
<p>假定一个 DNS 客户要决定主机名 www. amazon. com 的 IP 地址 。 粗略说来，将发生下列事件。客户首先与根服务器之一联系，它将返回顶级域名 com 的 TLD 服务器的 IP 地址。该客户则与这些 TLD 服务器之一 联系，它将为 amazon. com 返回权威服务器的 IP 地址。 最后，该客户与amazon.com权威服务器之一联系，它为主机名<a target="_blank" rel="noopener" href="http://www.amazon.com返回其/">www.amazon.com返回其</a> IP 地址。我们将很快更为详细地考察DNS查找过程。</p>
<p>在整个DNS系统里面我们是按照分层的方式来组织的。<br>最上面的一层叫做根域名服务器，root服务器下面有若干顶级服务器，这些服务器负责某一类域名的管理。顶级域服务器的下层是若干权威域DNS服务器。这些权威DNS服务器就负责某一个顶级域名的解析。例如google.com负责所有google.com域名的解析。在权威DNS服务器下面还可以设置更下层的域名解析服务器。例如google.com下面还有很多分公司，每个公司的都有自己的域名解析服务器。<br>下面举一个例子：<br>在这样一个分布、层次化的数据库里客户机如何确定主机名<a href="http://www.amazon.com的IP地址呢？">www.amazon.com的IP地址呢？</a><br>（1）客户机查询根服务器的得到com DNS服务器的IP地址；<br>（2）客户机查询com DNS服务器得到amazon.com DNS服务器的IP地址；<br>（3）客户机查询amazon.com DNS服务器得到<a target="_blank" rel="noopener" href="http://www.amazon.com的ip地址./">www.amazon.com的IP地址。</a></p>
<p><strong>1.根DNS服务器：</strong>有400多个根名字服务器遍及全世界。这些根名字服务器由13个不同的组织管理。根名字服务器的 全部清单连同管理它们的组织及其 IP 地址可以在 [RootServers2016] 中找到。根名字服务器提供TLD服务器的IP地址。</p>
<p><strong>2.顶级域服务器：</strong></p>
<p>顶级域服务器构成体系：互联网的设计者把顶级域名分为两类：<br>（1）用途域名：com、org、net、edu、gov等。<br>（2）国家顶级域名：uk、fr、ip、cn等</p>
<p>TLD服务器体哦提供了权威DNS服务器的IP地址。</p>
<p><strong>3.权威DNS服务器：</strong></p>
<p>权威DNS域名服务器是真正的负责某一具体域名的解析工作。<br>在因特网上具有公共可访问主机（例如Web服务器和邮件服务器）的每个组织机构必须提供公共可访问的DNS记录，这些记录将这些主机的名字映射为IP地址。组织机构的权威DNS服务器负责保存这些DNS记录。<br>多数大学和公司维护它们基本权威DNS服务器。</p>
<p><strong>4.本地DNS服务器(local DNS server)</strong></p>
<p>每个ISP都有一台本地DNS服务器。当主机与某个ISP连接时，该ISP提供一台主机的IP地址，该主机具有一台或多台其本地DNS服务器的IP地址。</p>
<h5 id="1-DNS查询方法"><a href="#1-DNS查询方法" class="headerlink" title="1.DNS查询方法"></a>1.DNS查询方法</h5><p>1、<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E9%80%92%E5%BD%92%E6%9F%A5%E8%AF%A2&spm=1001.2101.3001.7020">递归查询</a></p>
<p>递归查询核心：<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90&spm=1001.2101.3001.7020">域名解析</a>的负担交给被查询的域名服务器。</p>
<p>下图为递归查询的流程：</p>
<img src="https://img-blog.csdnimg.cn/20210713101428834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />



<p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220607163941673.png" alt="image-20220607163941673"></p>
<p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220607163947253.png" alt="image-20220607163947253"></p>
<p>首先cis.poly.edu这台主机想去查询gaia.cs.umass.edu这台主机的域名所对应的IP地址，<br>（1）客户机会将查询请求发送给本地DNS服务器，这个地方用dns.poly.edu来代表，<br>（2）本地域名服务器会去问根域名服务器谁在管理gaia.cs.umass.edu这个域名，<br>（3）根域名服务器说我不知道谁在管，但是我知道谁在管.edu，我可以帮你去问它，这时根域名服务器去联系管理.edu这个顶级域名的顶级域名服务器<br>（4）管理.edu的顶级域服务器说我不知道gaia.cs.umass.edu这个域名的IP地址，但是我知道谁在管cs.umass.edu，我帮你去问它，于是它联系管理cs.umass.edu的服务器也就是权威域名服务器dns.cs.umass.edu.<br>（5）dns.cs.umass.edu得到信息后说你找对人了，我知道gaia.cs.umass.edu的IP地址是多少，然后它把信息返回给管理.edu的顶级域服务器<br>（6）管理.edu的顶级域名服务器将信息返回给根服务器<br>（7）根服务器又把结果返回给dns.poly.edu本地DNS服务器<br>（8）最后本地DNS服务器将结果返回给客户机<br>这样就完成了一次DNS的查询。<br>在查询过程中每一次的查询都是在被询问者的帮助下完成。</p>
<p><strong>2.迭代查询</strong></p>
<p>递归有一个问题：被查询者被查询的域名服务器它的负载会不会很重？尤其是对于根域名服务器而言，大家都去问它，它要帮助大家，会造成比较重的负担。这时就出现的迭代查询。<br>迭代查询原理：我不知道这个信息。但是其他人知道，你去问其他人就可以了。被询问者不会帮助你去查询，而是告诉你你可以另外去找谁。</p>
<img src="https://img-blog.csdnimg.cn/20210713102233828.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

<p>（1）客户机去问本地的DNS服务器<br>（2）本地的DNS 服务器去问根服务器<br>（3）根服务器会告诉本地域名服务器我不知道gaia.cs.umass.edu的IP地址是多少，但是我知道谁在管.edu，你去问它<br>（4）本地服务器根据根服务器的指引去访问管理.edu的顶级域名服务器<br>（5）顶级域名服务器告诉本地服务器说我并不知道你要查询的IP地址，但是我知道谁在管cs.umass.edu.<br>（6）本地DNS服务器根据顶级域名服务器提供的信息去找到dns.cs.umass.edu，对它进行查询<br>（7）将要查询的信息返回给DNS服务器<br>（8）本地DNS服务器再将结果传回给主机</p>
<p>递归查询中，所有查询都是递归的；迭代查询中，请求主机到本地DNS服务器是递归的，其他是迭代的。</p>
<h5 id="2-DNS缓存"><a href="#2-DNS缓存" class="headerlink" title="2.DNS缓存"></a>2.DNS缓存</h5><p>DNS 缓存，即DNS caching。</p>
<p>每次访问一个域名都要像刚才那样走一圈查询它的IP地址的话会导致互联网上的流量太大，同时速度也很慢，本地DNS服务器其实是可以把顶级域名服务器的IP地址（是很多权威域名服务器的查询信息）给缓存下来的，映射到本地存储器中。下一次当有人再去访问同样信息的时候就不用再去做刚才的查询而直接将缓存结果返回即可。</p>
<p>当然缓存信息需有一个有效的时间，这个时间称为TTL，服务器在一定时间（TTL）后将丢弃缓存信息。</p>
<p>这会导致一个问题就是缓存的条目可能会过期即可能本地DNS服务器查询的结果并不是最新。因为如果改条目对应的主机的IP改变了，只有当TTL到期时，本地DNS服务器的条目才会得到更新。</p>
<h3 id="2-4-3-DNS记录和报文"><a href="#2-4-3-DNS记录和报文" class="headerlink" title="2.4.3 DNS记录和报文"></a>2.4.3 DNS记录和报文</h3><p>资源记录(Resource Record)：共同实现DNS分布式数据库的所有DNS服务器。</p>
<p>RR提供了主机名到IP地址的映射。每个DNS回答报文包含了一条或多条资源记录。</p>
<p>资源记录是一个包含了下列字段的4元组：<code>（name，value，type，TTL）</code>。</p>
<p>TTL是该记录的生存时间：决定了从资源记录到应当从缓存中删除的时间。Name和Value的值取决于Type。</p>
<img src="计算机网络.assets/image-20220607165259006.png" alt="image-20220607165259006" style="zoom:50%;" />

<p><strong>type有四类：</strong><br>（1）Type=A<br>这时name=主机名；value=IP地址。<br>（2）Type=CNAME<br>这时name=主机别名；value=真实的规范主机名<br>例如：<a target="_blank" rel="noopener" href="http://www.ibm.com的真名为servereast.backup2.ibm.com./">www.ibm.com的真名为servereast.backup2.ibm.com。</a><br>（3）Type=NS<br>这时name=域名（如foo.com）；value=该域权威名字服务器的主机名。<br>（4）Type=MX<br>这时name=邮件服务器的主机别名；value=邮件服务器的真实规范主机名。</p>
<p>如果一台DNS服务器用于某特定主机名的权威DNS服务器，那么该DNS服务器会有一条包含用于该主机名的类型A记录。</p>
<p>如果一台DNS服务器不是用于某特定主机名的权威DNS服务器，那么该DNS服务器会有一条类型NS记录，该记录对应于包含主机名的域；它还将包括一条类型A记录，记录提供了在NS记录的Value字段中的DNS服务器的IP地址。</p>
<h5 id="1-DNS报文"><a href="#1-DNS报文" class="headerlink" title="1.DNS报文"></a>1.DNS报文</h5><p>DNS有查询和回答报文，并且查询和回答报文有相同的格式。</p>
<p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220607173512065.png" alt="image-20220607173512065"></p>
<ul>
<li>首部区域：报文头部。</li>
</ul>
<p>第一个字段(标识符)：16比特，查询和应答报文使用相同的标识符，用于标识该查询。这个标识符会被复制到对查询的回答报文中，以便让客户用它来匹配发送的请求和接收到的回答。</p>
<p>标志：若干标志。1比特的”查询/回答“标志位指出报文是查询报文(0)还是回答报文(1)。</p>
<p>查询希望是/非递归查询-1/0<br>应答可/否获得（支持）递归查询-1/0<br>应答是/否来自权威名字服务器-1/0</p>
<ul>
<li>问题区域：包含着正在进行的查询信息。</li>
</ul>
<p>包括名字字段(正在被查询的主机名字)；类型字段，指出有关该名字的正被询问的问题类型，例如主机地址是与一个名字相关联(类型A)还是与某个名字的邮件服务器相关联(类型MX)。</p>
<ul>
<li><p>回答区域：对于查询、应答的资源记录可以有多个资源记录，因为可以有多个IP地址。</p>
</li>
<li><p>权威区域：域对应的权威名字服务器的信息。</p>
</li>
<li><p>附加区域：权威名字服务器的IP地址等其它有帮助的记录。</p>
</li>
</ul>
<p><code>nslookup</code>：向某些DNS服务器发送一个DNS查询报文</p>
<h5 id="2-在DNS数据库中插入记录"><a href="#2-在DNS数据库中插入记录" class="headerlink" title="2.在DNS数据库中插入记录"></a>2.在DNS数据库中插入记录</h5><p>例如：刚刚创建一个”网络乌托邦“公司<br>（1）如果你想在注册登记机构注册你的域名networkutopia.com，则：<br>1）需要提供你自己的基本权威DNS服务器和辅助权威DNS服务器的名字和IP地址<br>2）该**注册登记机构<a href="%E6%98%AF%E4%B8%80%E4%B8%AA%E5%95%86%E4%B8%9A%E5%AE%9E%E4%BD%93">^注</a>**将下列两条资源记录插入注册机构的DNS系统中：<br>（networkutopia.com,dns1.networkutopia.com,NS）<br>（dns1.networkutopia.com，212.212.212.1，A）</p>
<p>（2）如果你想建立一个网站，则可以将网址<a target="_blank" rel="noopener" href="http://www.networkutopia.com以类型a的方式记录到你的权威dns服务器dns1.networkutopia.com中./">www.networkutopia.com以类型A的方式记录到你的权威DNS服务器dns1.networkutopia.com中。</a><br>（3）如果你想建一个邮件服务器，则可以将mail.networkutopia.com以类型MX的方式记录到你的权威DNS服务器dns1.networkutopia.com中。<br>自此你就把你的域名体系连入了internet。</p>
<p>一个人要访问一个网站，主机首先向其本地的DNS服务器发送请求。该本地服务器接着则联系一个TLD com服务器。该TLD服务器包含前面列出的类型NS和类型A资源记录，因为注册登记机构将这些资源记录插入所有的TLD com的服务器。该TLD com服务器向Alice的本地DNS服务器发送一个回答，该回答包含了这两条资源记录。 该本地DNS 服务器则向212.212.212.1 发送一个 DNS查询，请求对应于 <a target="_blank" rel="noopener" href="http://www.networkutopia.com的类型a记录.该记录提供了所希望的/">www.networkutopia.com的类型A记录。该记录提供了所希望的</a> Web 服务器的 IP 地址，如 212. 212. 71. 4, 本地 DNS 服务器将该地址回传给 Alice 的主机 。Alice的浏览器此时能够向主机 212. 212. 71. 4 发起一个 TCP 连接，并在该连接上发送一个HTTP请求。</p>
<p><strong>DNS安全问题</strong></p>
<p>（1）基于主机耗尽型的DNS查询拒绝服务（DDos）攻击：对根域名服务器或顶级域名服务器发起拒绝服务攻击。<br>（2）基于宽带耗尽型的DNS反弹式拒绝服务攻击：伪造客户地址向大量的DNS服务器发出请求，导致客户被回复淹没。<br>（3）重定向攻击：中间人攻击、DNS中毒攻击（发送欺骗的域名解析结果给DNS服务器）<br>影响个人用户的DNS安全威胁有：<br>（1）本机Host文件被篡改<br>（2）DNS胁持<br>（3）DNS污染</p>
<h2 id="2-5-P2P文件分发"><a href="#2-5-P2P文件分发" class="headerlink" title="2.5 P2P文件分发"></a>2.5 P2P文件分发</h2><p>P2P：间歇连接的对等方彼此直接通信。</p>
<p>比较流行的P2P文件分发协议：BitTorrent</p>
<h3 id="1-P2P体系结构的拓展性"><a href="#1-P2P体系结构的拓展性" class="headerlink" title="1.P2P体系结构的拓展性"></a>1.P2P体系结构的拓展性</h3><img src="计算机网络.assets/image-20220607190223736.png" alt="image-20220607190223736" style="zoom:50%;" />

<p>比较分发时间，P2P是越来越缓。</p>
<h4 id="集中式目录结构："><a href="#集中式目录结构：" class="headerlink" title="集中式目录结构："></a>集中式目录结构：</h4><p>在这种模式中有个中央目录服务器为P2P提供目录服务。这种集中式目录架构最早来自于”Napster“公司的设计。<br>在集中式目录架构中：<br>（1）当对等方启动时，它通知目录服务器以下信息：<br>1）IP地址<br>2）可供共享的对象名称<br>（2）当一个用户要在集中式的目录里面找寻某个资源时会去访问目录服务器。例如Alice查询文件”Hey Jude“<br>（3）服务器会告诉它哪些用户在线，然后这些用户上面有哪些资源，进一步的再去联系这些用户。然后从这些用户处下载相关资源。例如Alice向Bob请求文件。<br>如下图所示：</p>
<img src="https://img-blog.csdnimg.cn/20210713163434541.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

<p>相对于纯P2P而言，集中式目录有一些问题，因为文件传输是分散的，但是定位内容的过程是高度集中的因此可能会导致：<br>（1）单点故障<br>（2）性能瓶颈<br>（3）侵犯版权</p>
<h3 id="2-BitTorrent"><a href="#2-BitTorrent" class="headerlink" title="2.BitTorrent"></a>2.BitTorrent</h3><p>BitTorrent是一种用于文件分发的流行P2P协议。</p>
<p>洪流：参与一个特定文件分发的的所有对等方的集合。</p>
<p>文件块：当一个洪流中的对等方彼此下载等长度的文件块，典型块的长度为256KB。</p>
<p>可以使用最稀缺优先技术，得到更为迅速的分发。</p>
<p>P2P技术中使用最广泛的还有文件分发，文件分发最基础的技术来自于BitTorrent。<br>BitTorrent是一种用于文件分发的流行P2P协议。<br>参与一个特定文件分发的所有对等方的集合被称为一个洪流即torrent。<br>一个洪流中的对等方彼此下载等长度的文件快（chunk），典型块长度为256KB。</p>
<p><strong>1、追踪器tracker</strong><br>在BitTorrent里有个服务器我们称之为追踪器tracker，它可以跟踪参与洪流的所有对等方。<br>从这个角度来说Bit有一个目录服务器，它负责管理在某一次下载里面各客户端的情况。大家如果使用过Bit下载软件，看到过这些软件的工作日志就会发现这些软件在下载某个文件时一开始会根据Bit种子里边的信息去连接某些tracker服务器，然后去找寻洪流的信息，之后接入这些洪流。<br>例如Alice要加入某个洪流的下载，她要从追踪器获得对等方列表，获得列表以后就会知道可以和谁去交换文件信息、交换资源了。</p>
<p><strong>2、设计原则</strong><br>在Bit里有如下设计原则：<br>（1）请求文件快<br>1）要保证在任何给定的时刻，不同的对等方拥有不同的文件块子集。<br>2） 每个对等方会周期性的询问其它每个连接的对等方当前所拥有的文件块列表。<br>3）对等方将请求下载最稀缺的文件快。<br>（2）发送文件块<br>1）Alice发送文件块的对象是所有邻居中向自己发送速率最快的4个。 其它邻居被阻塞，但是每10秒会重新计算速率。<br>为了防止”穷者越穷、富者越富“的状况每30秒会随机选择一个其它邻居，发送文件块。</p>
<p><strong>DHT（分布式Hash表）</strong></p>
<p>再介绍一下在P2P技术中被广泛使用的DHT技术。<br>DHT可以看成一个分布式的P2P数据库。这个数据库由许多（key，value）键值对构成。<br>所有（key，value）对被分发到成千上万的对等方用户群中，对等方利用key来查询DHT，DHT返回与之匹配的value。此外对等方还可以插入（key，value）对。</p>
<blockquote>
<p><strong>1、键值分配</strong></p>
</blockquote>
<p>在DHT中核心问题为如何分配键值对给各对等方呢？基本思想为：<br>（1）把每个key转化成一个整数。<br>（2）给每个对等方分配一个整数标识符。<br>（3）把键值对分配给标识符离key最近的那个对等方。<br>具体做法为：<br>（1）给每个对等方分配一个[0,2 n − 1 2^n-12<br>n<br> −1]之间的整数标识符，n为某给定值。<br>（2）每个标识符由n比特构成。<br>（3）需要每个key也在同样的范围内。<br>（4）为得到整数key，将原key做hash<br>将一个key映射到相同范围内时使用到了数据结构中的hash技术。把key做hash运算，将它映射到与标识符相同的一个范围内。这就是为什么叫做分布式hash表的原因，因为在里面使用了hash技术。<br>将key数据化后就可以将key分配给具有最近邻ID的对等方。最邻近被定义为该key的直接后继。<br>例如n=4即给对等方分配[0,15]的整数标识符，peers:1、3、4、5、8、10、12、14。<br>当key=13时直接后继为14；<br>当key=15时直接后继为1，因为是按照环的形式。<br>环形如下：</p>
<img src="https://img-blog.csdnimg.cn/20210713193645192.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

<p>每个对等方仅和其直接后继和直接前任联系。</p>
<img src="https://img-blog.csdnimg.cn/2021071319410425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />

<p>例如1110被存放在最邻近的直接后继里面，最邻近的直接后继就是1111，0011查找哪个负责1110只能询问0100，依次往后，找到1111后，1111给0011返回信息说我负责1110。这就是环形DHT里键值对查找过程。</p>
<p>由上图我们看到环形DHT比较非时间，下面来介绍带捷径的环形DHT：</p>
<p>带捷径的环形DHT除了包括直接前任、后继之外还包括捷径方的IP。<br>如下图：<br><img src="https://img-blog.csdnimg.cn/20210713194500646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>3有一个捷径方8，可以直接将消息发给8，8也可以直接将消息发给15，与环形DHT相比，消息数从6减至2.</p>
<h2 id="2-6-视频流和分发内容网"><a href="#2-6-视频流和分发内容网" class="headerlink" title="2.6 视频流和分发内容网"></a>2.6 视频流和分发内容网</h2><h3 id="2-6-1-因特网视频"><a href="#2-6-1-因特网视频" class="headerlink" title="2.6.1 因特网视频"></a>2.6.1 因特网视频</h3><p>这些视频是预先存储在服务器上。</p>
<p>4K超过10Mbps。</p>
<ol>
<li><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/183956523">什么是4K - 知乎 (zhihu.com)</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://new.qq.com/omn/20210513/20210513A03JJK00.html">详解分辨率1080P、2K、4K、8K的含义和区别！_腾讯新闻 (qq.com)</a></p>
</li>
</ol>
<h3 id="2-6-2-HTTP流和DASH"><a href="#2-6-2-HTTP流和DASH" class="headerlink" title="2.6.2 HTTP流和DASH"></a>2.6.2 HTTP流和DASH</h3><p>在HTTP流中，视频存储在HTTP服务器中作为一个普通的文件，每个文件有一个特定的URL。当用户要看该视频时，客户与服务器创建一个TCP连接并发送对该URL的 HTTP GET 请求。服务器则以底层网络协议和流量条件允许的尽可能快的速率 ，在一个HTTP响应报文中发送该视频文件。 在客户一侧，字节被收集在客户应用缓存中，一旦该缓存中的字节数量超过预先设定的门限，客户应用程序就开始播放，特别是，流式视频应用程序周期性地从客户应用程序缓存中抓取帧，对这些帧解压缩并且在用户屏幕上展现 ，因此，流式视频应用接收到视频就进行播放，同时缓存该视频后面部分的帧 。</p>
<p>尽管HTTP流在实践中已经得到了广泛的部署。但缺陷是所有客户接收到相同编码的视频，不同客户带宽不同。</p>
<p>所以导致了一种新的HTTP流的研发，即DASH(经HTTP的动态适应性流)。在DASH中，视频编码为几个不同的版本，其中每个版本具有不同的比特率，对应于不同的质量水平。客户动态地请求来自不同版本且长度为几秒 的视频段数据块。当可用带宽量较高时，客户自然地选择来自高速率版本的块;当可用带宽量较低时，客户自然地选择来自低速 率版本的块。客户用 HTTP GET请求报文一次选择一个不同的块 [Akhshahi 2011]。</p>
<p>DASH允许客户使用不同的以太网接入速率流式播放具有不同编码速率的视频。每个视频存储在HTTP服务器中，每个版本都有一个不同的URL。HTTP服务器也有一个告示文件。DASH允许在客户自由地在不同的质量等级之间切换。</p>
<h3 id="2-6-3-内容分发网"><a href="#2-6-3-内容分发网" class="headerlink" title="2.6.3 内容分发网"></a>2.6.3 内容分发网</h3><p>单一的数据中心会导致：</p>
<ul>
<li>停滞时延</li>
<li>浪费网络带宽，增加支付费用</li>
<li>代表一个单点故障</li>
</ul>
<p>应对措施：<strong>CDN内容分发网</strong>：CDN管理分布在多个地理位置上的服务器，在其中存储视频副本。</p>
<p>CDN通常采用两种不同的服务器安置原则：</p>
<ul>
<li>深入：第一个原则由Akamai首创，该原则是通过在遍及全球的接入ISP中部署服务器集群来深入到ISP的接入网中。Akamai在大约1700个位置采用这种方法部署集群。目标是靠近端用户，改善时延和吞吐量。</li>
<li>邀请做客：通过少量关键位置建造大集群邀请ISP做客，维护和管理较低，时延和吞吐量代价大。</li>
</ul>
<p>一旦CDN的集群准备就绪，它就可以跨集群复制内容。</p>
<p><strong>1.CDN操作</strong></p>
<p>大多数CDN利用DNS来截获和重定向请求。</p>
<img src="计算机网络.assets/image-20220608162107067.png" alt="image-20220608162107067" style="zoom:50%;" />

<img src="计算机网络.assets/image-20220608162112784.png" alt="image-20220608162112784" style="zoom:50%;" />

<h3 id="2-6-4-学习案例：Netflix、YouTube和“看看”"><a href="#2-6-4-学习案例：Netflix、YouTube和“看看”" class="headerlink" title="2.6.4 学习案例：Netflix、YouTube和“看看”"></a>2.6.4 学习案例：Netflix、YouTube和“看看”</h3><h4 id="1-Netflix"><a href="#1-Netflix" class="headerlink" title="1.Netflix"></a>1.Netflix</h4><p>分发视频：亚马逊云和自己专用的CDN基础设施。</p>
<p>Netflix的功能的Web网站完全运行在亚马逊服务器上。</p>
<p>亚马逊云：</p>
<ul>
<li><strong>内容摄取：</strong>在Netflix能够向它的用户分发某电影之前，它必须首先获取和处理该电影。Netflix接收制片厂电影的母带，并且将其上载到亚马逊云的主机上。</li>
<li><strong>内容处理：</strong>亚马逊云中的机器为每部电影生成许多不同格式，以适合在桌面计算机、智能手机和电视机相连的游戏机上运行不同类型的客户视频播放器。</li>
<li><strong>向其CDN上载版本</strong>:向亚马逊主机云上载这些版本。</li>
</ul>
<p>Netflix雇佣了三个第三方CDN公司来分发它视频内容。通过这些CDN分发它的视频内容。自那时起，Netflix创建了自己专用的CDN，现在它从这些专用CDN发送它的视频。</p>
<h4 id="2-YouTube"><a href="#2-YouTube" class="headerlink" title="2.YouTube"></a>2.YouTube</h4><p>谷歌和YouTube协议是专用的。利用CDN技术来分发它的视频。在不同的IXP和ISP位置安装服务器集群和巨大的数据中心。谷歌的集群策略将客户定向到某个集群。</p>
<h4 id="3-看看"><a href="#3-看看" class="headerlink" title="3.看看"></a>3.看看</h4><p>P2P模式。</p>
<h2 id="2-7-套接字编程：生成网络应用"><a href="#2-7-套接字编程：生成网络应用" class="headerlink" title="2.7 套接字编程：生成网络应用"></a>2.7 套接字编程：生成网络应用</h2><p>典型的网络应用由一对程序构成：客户程序和服务器程序。</p>
<p>客户进程和服务器进程通过套接字读出和写入数据在彼此之间通信。</p>
<p>网络应用程序包含协议标准和专用的网络应用程序。</p>
<p>如果要在应用层调用传输层的服务，进行相关程序的设计，就要涉及到套接字编程。套接字也称之为Socket，本质上它就是利用传输层提供的一系列Api来进行网络应用程序的设计。</p>
<p>网络应用程序如果要进行套接字编程，需要明确的创建、使用及释放套接字。</p>
<p>套接字编程是典型的C/S模式。</p>
<p>从下图中可以形象的看到套接字的作用：<br><img src="https://img-blog.csdnimg.cn/20210714092804173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>（1）套接字是一个主机本地应用程序所创建的，为操作系统所控制的接口。<br>（2）应用程序通过这个接口，使用传输层提供的服务，跨网络发送/接收消息到/从其它应用进程。</p>
<h3 id="2-7-1-UDP套接字编程"><a href="#2-7-1-UDP套接字编程" class="headerlink" title="2.7.1 UDP套接字编程"></a>2.7.1 UDP套接字编程</h3><p>将目的地址附在该分组身上。</p>
<p>（1）当用UDP进行套接字编程时没有初始握手手段；<br>（2）发送方明确将接收方的IP地址和端口号加入到每个分组。<br>（3）服务器必须从接收到的分组中析取发送方进程的IP地址、端口号。<br>这种方式在发送数据时可能被乱序收到或丢失。<br>从应用程序的角度来看UDP在客户和服务器之间提供一组字节的不可靠传输。</p>
<p>在发送进程能够将数据分组推出套接字之门之前、当使用 UDP 时，必须先将目的地址附在该分组之上。在该分组传过发送方的 套接字之后，因特网将使用该目的地址通过因特网为该分组选路到接 收进程的套接字。当分组到达接收套接字时，接收进程将通过该套接字取回分组，然后检查分组内容并采取适当动作。</p>
<p>端口号：标识符。</p>
<p>目的主机ip地址就是目的地址的一部分。因为主机的IP地址是目的地一部分，通过在分组中包括目的地的IP地址，因特网中的路由器将能够通过因特网分组选路到目的主机。一台主机可能运行许多网络应用进程，每个进程具有一个或多个套接字。<strong>当生成一个套接字时，就为它分配一个称为端口号的标识符。</strong>分组的目的地址也包括该套接字的端口号。</p>
<p>目的地址由目的主机IP地址和目的地套接字端口号组成。</p>
<p><strong>交互流程：</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20210714102410172.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>（1）服务器对入栈请求创建套接字，端口是x。<br>（2）客户机如果要给服务器端发送数据，它也创建一个套接字，这个套接字使用服务器的ip地址和服务器的端口，直接使用这个套接字发送数据包请求。<br>（3）服务器从服务器套接字中读请求。<br>（4）服务器收到请求后将应答写到服务器套接字上面，在写应答上面有客户机主机地址和端口号。<br>（5）客户机从套接字上面读取应答。<br>（6）这个过程一直进行，客户机如果收发完毕就退出，而服务器又回到前一步继续等待下一个客户机套接字请求的到来。</p>
<h3 id="2-7-2-TCP套接字编程"><a href="#2-7-2-TCP套接字编程" class="headerlink" title="2.7.2 TCP套接字编程"></a>2.7.2 TCP套接字编程</h3><p>套接字编程有面向连接和无连接两种实际上就是TCP套接字编程和UDP套接字编程。<br>可以使用源端口号来区别客户。<br>使用TCP进行套接字编程时客户必须初始联系服务器，这时服务器进程必须先运行，创建套接字来迎候客户的初始联系。<br>那么客户如何初始联系服务器呢？主要有3个步骤：<br>（1）创建客户本地TCP套接字。<br>（2）指定服务器进程的IP地址和端口号。<br>（3）一旦客户创建套接字，客户TCP就发起3次握手并建立与服务器TCP连接。<br>一旦客户初始联系服务器，服务器TCP为服务器进程创建1个新的套接字与客户通信。这里允许服务器与多个客户通信，而端口号被用来区分客户。<br>从应用程序的角度来看，TCP为客户和服务器提供了可靠的、顺序</p>
<p><strong>TCP客户/服务器套接字交互流程</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20210714101520897.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>（1）服务器创建一个在端口x上的套接字，然后等待连入请求<br>（2）在服务器等待连入请求的过程中客户机如果要连接服务器它会创建一个到服务器的IP地址然后和服务器的端口号x相连接的套接字。<br>（3）使用这个套接字和服务器进行TCP连接建立<br>（4）连接建立好以后客户机使用套接字向服务器端发送相关请求。<br>（5）服务器端读到请求以后使用写应答的方式把数据发送给客户机。<br>（6）客户机读取应答，当所有的读写操作都进行完成以后，客户机关闭套接字。<br>（7）服务器也关闭套接字<br>注意：服务器这时关闭的是客户机刚才建立的TCP连接上所对应的套接字，但是监听套接字还在，因为监听套接字要等待下一次的到来。</p>
<h1 id="第三章-运输层"><a href="#第三章-运输层" class="headerlink" title="第三章 运输层"></a>第三章 运输层</h1><h2 id="3-1-概述和运输层服务"><a href="#3-1-概述和运输层服务" class="headerlink" title="3.1 概述和运输层服务"></a>3.1 概述和运输层服务</h2><p><strong>逻辑通信：</strong>运输层协议为运行在不同主机的应用进程之间提供了逻辑通信。应用进程通过运输层提供的逻辑通信功能彼此发送报文。</p>
<p>运输层协议在端系统中而不是在路由器实现。</p>
<p>运输层协议是在端系统中而不是在路由器中实现的。在发送端，运输 层将从发送应用程序进程接收到的报文转换成运输层分组，用因特网术语来讲该分组称为运输层报文段 (segment) 。 实现的方法(可能)是将应用报文划分为较小的块，并为每块加上一个运输层首部以生成运输 层 报文段 。 然后，在发送端系统中，运输层将这些报文段传递给网络层，网路层将其封装成网络层分组(即数据报)并向目的地发送 。 注意到下列事实是重要的：网络路由器仅作用千该数据报的网络层字段；即它们不检查封装在该数据报的运输层报文段的字段。在接收端，网络层从数据报中提取运输层报文段，并将该报文 段向上交给运输层 。运输层则处理接收到的报文段，使该报文段中的数据为接收应用进程使用。</p>
<p>传输层主要为在两个不同的主机上运行的应用程序之间提供<strong>逻辑</strong>通信。</p>
<p>传输层协议运行在端系统。</p>
<p>（1）发送方：将应用程序报文分成数据段传递给网络层。<br>（2）接收方：将数据段重新组装成报文传递到应用层。<br>注：不只有一个传输层协议可以用于应用程序。例如TCP和UDP。</p>
<h3 id="3-1-1-运输层和网络层的关系"><a href="#3-1-1-运输层和网络层的关系" class="headerlink" title="3.1.1 运输层和网络层的关系"></a>3.1.1 运输层和网络层的关系</h3><p>运输层为运行在不同主机上的进程之间提供了逻辑通信。</p>
<p>例子：应用层报文=信封上的字符；进程=堂兄弟姐妹；主机(端系统)=家庭；运输层协议=Ann和Bill；网络层协议=邮政服务；</p>
<p>运输协议提供的服务受制于底层网络协议的服务模型。如果网络层协议无法为主机之间发送的运输层报文段提供时延或贷款保证。</p>
<p>运输协议也能为应用程序提供可靠的数据传输服务。</p>
<h3 id="3-1-2-因特网运输层概述"><a href="#3-1-2-因特网运输层概述" class="headerlink" title="3.1.2 因特网运输层概述"></a>3.1.2 因特网运输层概述</h3><p>UDP：用户数据报协议</p>
<p>TCP：传输控制协议</p>
<p>运输层协议称为<strong>报文段</strong>。网络层分组：数据报。</p>
<p>网络层的协议：IP，网际协议。IP为主机之间提供逻辑通信，交换报文段。IP是不可靠服务。每台主机有一个IP地址。</p>
<p>两个端系统间的IP交付服务拓展到运行在端系统上的两个进程之间的交付服务。<strong>将主机之间交付拓展到进程间交付被称为运输层的多路复用与多路分解</strong></p>
<p>TCP提供可靠数据传输，通过使用流量控制、序号、确认和定时器，TCP确保正确地、按序地将数据从发送进程交付给接收进程。TCP还提供拥塞控制。</p>
<h2 id="3-2-多路复用与多路分解"><a href="#3-2-多路复用与多路分解" class="headerlink" title="3.2 多路复用与多路分解"></a>3.2 多路复用与多路分解</h2><p>概念：由网络层提供的主机到主机交付服务延申到为运行在主机上的应用程序提供进程到进程的交付服务。</p>
<p>那么到底是如何进行多路复用与多路分解的呢？<br>在接收主机多路分解：将接收到的数据段传递到正确的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%A5%97%E6%8E%A5%E5%AD%97&spm=1001.2101.3001.7020">套接字</a>。<br>在发送主机多路复用：从多个套接字收集数据，用首部封装数据，然后将报文段传递到<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%BD%91%E7%BB%9C%E5%B1%82&spm=1001.2101.3001.7020">网络层</a>。<br>过程如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210714142523376.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>一个进程有多个套接字。</p>
<p>多路分解：将运输层报文段中的数据交付到正确的套接字的工作称为多路分解。</p>
<p>多路复用：在源主机从不同的套接字中收集数据块，并为每个数据块封装上首部信息从而生成报文段，然后将报文段传递到网络层，这些工作称为多路复用。</p>
<p>运输层多路复用要求：</p>
<p>①套接字有唯一标识符；</p>
<p>②每个报文段有特殊字段来指示该报文段所要交付到的套接字。</p>
<img src="计算机网络.assets/image-20220610134310892.png" alt="image-20220610134310892" style="zoom: 33%;" />

<p>这些特殊字段是<strong>源端口号字段和目的端口号字段</strong>。端口号是一个16比特的数，其大小在0<del>65535之间。 0</del>1023范围的端口号称为周知端口号，受限制，保留给相关应用层协议使用。</p>
<p>在主机上的每个套接字能够分配一个端口号，当报文段到达主机时，运输层检查报文段中的目的端口号，并将其定向到相应的套接字。然后报文段中的数据通过套接字进入其所连接的进程。如我们将看到的那 样，UDP大体上是这样做的。然而，也将如我们所见， TCP 中的多路复用与多路分解更为复杂。</p>
<p><strong>1.无连接的多路复用与多路分解</strong></p>
<p>分解的过程中有无连接的多路分解。<br>（1）用端口号创建套接字：<br>DatagramSocket ServerSocket1=new DatagramSocket (9911);<br>DatagramSocket ServerSocket2=new DatagramSocket (9922)<br>UDP套接字由目的IP地址和目的端口号指定<br>（2）当主机收到UDP数据段时检查数据段中的目的端口号，用端口号指示UDP数据段属于哪个套接字。<br>（3）具有不同的源IP地址且/或源端口号，但具有相同目的的IP地址和目的端口号的IP数据报指向同样的套接字。<br>详细过程如图所示：<br><img src="https://img-blog.csdnimg.cn/20210714144853925.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>一个UDP套接字由一个二元组标识。该二元组包含一个目的IP地址和一个目的端口号。</p>
<p><strong>2.面向连接的多路复用和多路分解</strong></p>
<p>面向连接的多路分解中TCP套接字由4部分指定，分别为<strong>源IP地址</strong>、<strong>源端口号</strong>、<strong>目的IP地址</strong>和<strong>目的端口号</strong>。<br>接收主机使用所有的4个值将数据段定位到合适的套接字。<br>服务器主机支持很多同时使用的TCP套接字，每个套接字都用4部分来表示。Web服务器对每个连接的客户都有不同的套接字；非持久HTTP将对每个请求有一个不同的套接字。<br>面向连接多路分解过程图如下：<br><img src="https://img-blog.csdnimg.cn/20210714145612876.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" /></p>
<p><strong>3.Web服务器与TCP</strong></p>
<p>报文段目的端口号跟服务器的端口有关。</p>
<h2 id="3-3-无连接运输：UDP"><a href="#3-3-无连接运输：UDP" class="headerlink" title="3.3 无连接运输：UDP"></a>3.3 无连接运输：UDP</h2><p>（1）UDP是“无修饰”、“不加渲染的”因特网传输层协议。<br>（2）UDP提供“尽最大努力”服务，即不保证可靠交付，同时也不使用拥塞控制。使得UDP数据段可能丢失或传递失序的报文到应用程序。<br>（3）UDP是面向无连接的协议，即在UDP接收者与发送者之间没有握手、每个UDP数据段的处理独立于其它数据段。<br>（4）UDP只在IP的数据报服务之上增加了很少一点的功能，即端口的功能和差错检测的功能。</p>
<p>为什么会有UDP呢？主要有以下几点：<br>（1）不需要建立连接，这样就减少了延迟。<br>（2）在发送者和接收者之间不需要连接状态，使得数据传输更简单。<br>（3）具有很小的数据段首部。<br>（4）没有拥塞控制，UDP能够用尽可能快的速度传递。 很适合多媒体通信的要求。</p>
<p>UDP例子：DNS。</p>
<p>DNS 是一个通常使用 UDP 的应用层协议的例子。当一台主机中的 DNS 应 用程序想要进行一次查询时，它构造了 一个DNS查询报文并将其交给 UD凡无须执行任何与运行在目的端系统中的UDP实体之间的握手，主机端的UDP为此报文添加首部字段 ，然后将形成的报文段交给网络层9网络层将此UDP报文段封装进一个IP数据报中，然后将其发送给一个名字服务器。在查询主机中的DNS应用程序则等待对该查询的响应。如果它没有收到响应(可能是由千底层网络丢失了查询或响应 ) ，则要么试图向另一个名字服务器发送该查询，要么通知调用的应用程序它不能获得响应。</p>
<h3 id="3-3-1-UDP报文段结构"><a href="#3-3-1-UDP报文段结构" class="headerlink" title="3.3.1 UDP报文段结构"></a>3.3.1 UDP报文段结构</h3><p><img src="https://th.bing.com/th/id/R.491a38d2eb9163bae67197bd99305c87?rik=SIk7s9SrvqrrRg&riu=http://upload-images.jianshu.io/upload_images/11034989-0030c15174f2d4b2.png&ehk=EImYWzVHhCy1YEC01edbm++XVDFJ2XhElQVFVOoHlZs=&risl=&pid=ImgRaw&r=0" alt="查看源图像"></p>
<p>数据字段包含一个查询报文/响应报文。</p>
<p>UDP首部4个字段，每个字段由2个字节组成。</p>
<p>长度字段指示了在UDP报文段中的字节数(首部加数据)。长度字段指明了包括首部在内的UDP报文段长度。</p>
<h3 id="3-3-2-UDP检验和"><a href="#3-3-2-UDP检验和" class="headerlink" title="3.3.2 UDP检验和"></a>3.3.2 UDP检验和</h3><p>提供差错检测功能。判断比特是否发生改变。</p>
<p>发送方的UDP对报文段中的所有16比特字的和进行反码运算。求和时遇到溢出要回卷。前两个先相加，再相加后一个，然后再进行反码运算。四个16比特字加在一起，如果有0，分组出现差错。</p>
<p>为什么UDP首先提供了检验和，就像许多链路层协议也提供检验差错那样。原因是不能保证源和目的之间的所有链路都提供差错检测。这是一个在系统设计中被称颂的<strong>端到端原则</strong>的例子。</p>
<h2 id="3-4-可靠数据传输原理"><a href="#3-4-可靠数据传输原理" class="headerlink" title="3.4 可靠数据传输原理"></a>3.4 可靠数据传输原理</h2><p>概念：数据可以通过一条可靠的信道传输，借助于可靠的信道，传输的数据比特就不会受到损坏。</p>
<img src="计算机网络.assets/image-20220611154012154.png" alt="image-20220611154012154" style="zoom:50%;" />

<p><strong>可靠数据传输协议</strong>：由于下层可靠数据传输协议的下层协议也许是不可靠的。</p>
<p><code>rdt_send()函数</code>:上层可以调用数据传输协议的发送方，它将要发送的数据交付给位于接收方的最高层。rdt表示可靠数据传输协议，_send表示rdt的发送端正在被调用。</p>
<p>在接收端，当分组从信道的接收端到达时，将调用rdt_rcv()。</p>
<p>当rdt协议想要向较高层交付数据时，将通过调用deliver_data()来完成。</p>
<p>除了交换含有带传送的数据分组之外，rdt的发送端和接收端还需往返交换控制分组。rdt的发送端和接收端都要通过调用udt_send()发送分组给对方。</p>
<h3 id="3-4-1-构造可靠数据传输协议"><a href="#3-4-1-构造可靠数据传输协议" class="headerlink" title="3.4.1 构造可靠数据传输协议"></a>3.4.1 构造可靠数据传输协议</h3><p><strong>1.经完全可靠信道的可靠数据传输协议:rdt 1.0</strong></p>
<p>首先考虑最简单的情况，即在完全可靠的信道上，没有bit错误、没有分组丢失。</p>
<p>这时发送方与接收方的有限状态机定义如下图：</p>
<img src="计算机网络.assets/image-20220611161336560.png" alt="image-20220611161336560" style="zoom:50%;" />

<p>显示了1.0发送和接收方的<strong>有限状态机</strong>的定义。</p>
<p>发送方和接收方有各自的FSM(有限状态机)。FSM在两个都只有一个状态，描述了协议从一个状态变迁到另一个状态。因此变迁必定是从一个状态返回到自身。</p>
<p>其中，发送方发送数据到下层信道，接收方从下层信道接收数据。发送方和接收方有各自的FSM，并且都只有一个状态，都是从一个状态返回到自身。</p>
<p>发送端通过rdt_send(data)事件接收来自较高层的数据，经过make_pkt(data)事件把上层的数据转换成下层可以识别的数据段，然后把data数据通过udt_send(packet)发到下层IP层。</p>
<p>接收方通过rdt_rcv(paclet)函数从IP层接收数据，收到信息包之后继续等待来自下层的调用，这个过程的事件主要是将数据段转换成数据，交给应用层。</p>
<p>对于rdt1.0总结一句话就是假设信道没有出错，只是做两个动作，一个是交付，一个是上传。</p>
<p><strong>2.经具有比特差错信道地可靠数据传输：rdt2.0</strong></p>
<p>基于重传机制的可靠数据传输协议称为<strong>自动重传请求</strong>(ARQ)协议。</p>
<p>rdt2.0的新机制</p>
<p>ARQ协议中还需要另外三种协议功能来处理存在比特差错的情况：</p>
<ol>
<li><strong>差错检测</strong>。接收方检测到何时出现了比特差错。需要有额外的比特，这些比特被汇集在rdt2.0数据分组的分组检验和字段中。</li>
<li><strong>接收方反馈</strong>。接收方提供明确的反馈信息给发送方，如ACK(肯定确认)和NAK(否定确认)。</li>
<li><strong>重传</strong>。接收方收到有差错的分组时，发送方将重传该分组报文。</li>
</ol>
<img src="计算机网络.assets/image-20220611200048263.png" alt="image-20220611200048263" style="zoom:50%;" />



<p>rdt2.0有两个发送状态：在最左边的状态中，发送端</p>
<p>注意：如果对一个事件没有动作，或没有就事件发送而采取了一个动作，将在横线上方或下方使用符号A表示。</p>
<p>在这个过程中发送方首先等待来自上层的调用，做两个事情，第一个是rdt_send(data)接收上层数据。snkpkt与1.0相比加了一个校验和，可以检测到是否发送错误，之后udp_send(snkpkt)将分组发送出去。之后发送方等待来自接收方的ACK或NAK分组。如果收到一个ACK分组，则发送方知道最近发送的分组已经被正确接收，此时协议返回到等待来自上层调用的状态；如果收到一个NAK分组，则该协议会重传最后一个分组并等待接收方为响应重传分组而回送的ACK或NAK分组。</p>
<p>rdt2.0中接收方的FSM同样只有一个状态，当分组到达时，接收方根据接收到的分组是否受损要么回答一个ACK，要么回答一个NAK。停等协议。</p>
<p>（1）当没有错误时整个发送方与接收方操作如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210717230301386.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>（2）当出现错误场景时发送方与接收方的操作如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210717230408252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM3NDkzOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>rdt2.0错误场景其实就是一个停等协议，什么是停等协议呢？就是发送方发送一个报文，然后等到接收方的响应，响应类型有ACK和NAK两种，如果是ACK则为正常数据交付，如果是NAK要进行重传。<br><strong>处理受损ACK和NAK时会发生如下三种情况：</strong><br>（1）发送方并不知道接收方发生了什么。例如当我们说话时接收方回答的”请重复一遍”，发送方会问“你说什么？”。<br>（2）增加足够的检验和比特，使发送方不仅可以差错检测，还可以回复差错。对于会产生差错但不丢失分组的信道，这就可以直接解决问题。<br>（3）发送方收到含糊不清的ACK或NAK分组。即冗余分组，冗余分组的困难在于接收方不知道它上次所发送的ACK或NAK是否被发送方正确收到。</p>
<p>rdt2.0致命缺陷：我们考虑当ACK/NAK混淆了会发生什么？这时就会发生上面提到的发送方并不知道接收方发生了什么，使得不能正确重发数据，可能会导致数据重复。解决方法：发送方给每个分组加一个序号，在ACK/NAK混淆时发送方重发当前分组，之后接收方会丢弃重复的分组但并不向上传递。</p>
<p>解决方法：在数据分组中添加一新字段。编号。<strong>即把发送数据分组的序号放在该字段</strong>。这样，接收方只需要检测序号就能发现是否重传了分组。rdt2.0是“停等”的，因此，只需要一位序号就够了。因为只有接收方和发送方都确认该分组传输完成了，才会传输下一个分组。只要前后两次分组的编号是不同的即可，不需要管分组编号是否重复。</p>
<p><img src="https://img-blog.csdnimg.cn/20190402224549142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5MDEwMTAx,size_16,color_FFFFFF,t_70" alt="img"></p>
<p> 接收方的状态也有4种，它反映出了希望接受的分组是0还是1。需要注意的是当接收方接收到的分组是失序的（也就是它正确接受了上一个分组），它返回ACK，当然也必须这样返回，因为这就是出现了第一次返回ACK受损。</p>
<p>如果序号正确，但是分组受损，那么返回一个NAK消息。如果不返回NAK，而是返回对上一个正确接受分组的ACK，这也能实现一样的效果。因为发送方收到以后就知道，你没有成功接受上一个分组之后的分组。也就是说，接收方只返回ACK即可，如果返回的ACK中的编号是发送方刚才发送的，那么说明接收正确；如果返回的ACK的编号是上次发送方上一次发送的数据编号，那么说明接受错误。</p>
<p><img src="https://img-blog.csdnimg.cn/20190405200510524.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5MDEwMTAx,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>经过上面的改造就形成了rdt2.1版本，此时我们的信道仍旧是<strong>只具备“比特可能受损”的特性。</strong></p>
<h1 id="拓展1：报文、报文段、分组、包、数据报、帧、数据流的概念区别"><a href="#拓展1：报文、报文段、分组、包、数据报、帧、数据流的概念区别" class="headerlink" title="拓展1：报文、报文段、分组、包、数据报、帧、数据流的概念区别"></a>拓展1：报文、报文段、分组、包、数据报、帧、数据流的概念区别</h1><p><strong>1.报文(message)</strong></p>
<p>我们将位于应用层的信息分组称为报文。报文是网络中交换与传输的数据单元，也是网络传输的单元。报文包含了将要发送的完整的数据信息，其长短不需一致。报文在传输过程中会不断地封装成分组、包、帧来传输，<strong>封装的方式就是添加一些控制信息组成的首部，那些就是报文头。</strong></p>
<p><strong>2.报文段（segment）</strong></p>
<p>通常是指起<strong>始点和目的地都是传输层的信息单元。</strong></p>
<p><strong>3.分组/包(packet)</strong></p>
<p>分组是在网络中传输的二进制格式的单元，为了提供通信性能和可靠性，每个用户发送的数据会被分成多个更小的部分。在每个部分的前面加上一些必要的控制信息组成的首部，有时也会加上尾部，就构成了一个分组。它的起始和目的地是网络层。</p>
<p><strong>4.数据报(datagram)</strong></p>
<p>面向无连接的数据传输，其工作过程类似于报文交换。采用数据报方式传输时，被传输的分组称为数据报。通常是指起始点和目的地都使用无连接网络服务的网络层的信息单元。(指IP数据报)</p>
<p><strong>5.帧(frame)</strong></p>
<p>帧是数据链路层的传输单元。它将上层传入的数据添加一个头部和尾部，组成了帧。它的起始点和目的点都是数据链路层。</p>
<p><strong>6.数据单元（data unit）</strong></p>
<p>指许多信息单元。常用的数据单元有服务数据单元（SDU）、协议数据单元（PDU）。SDU是在同一机器上的两层之间传送信息。PDU是发送机器上每层的信息发送到接收机器上的相应层（同等层间交流用的）。</p>
<p><strong>分层协议：</strong></p>
<p><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%BA%94%E7%94%A8%E5%B1%82&spm=1001.2101.3001.7020">应用层</a>——消息</p>
<p>传输层——报文段(segment)/数据报(datagram) (注：TCP叫<strong>TCP报文段</strong>，UDP叫<strong>UDP数据报</strong>,也有人叫UDP段)</p>
<p>网络层——分组、数据包（packet）</p>
<p>链路层——帧（frame）</p>
<p>物理层——P-PDU（bit）</p>
<p><img src="https://img-blog.csdnimg.cn/20181201104548931.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2EzMTkyMDQ4,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>其实，segment，datagram，packet，frame是存在于同条记录中的，是基于所在协议层不同而取了不同的名字。我们可以用一个形象的例子对数据包的概念加以说明：我们在邮局邮寄产品时，虽然产品本身带有自己的包装盒，但是在邮寄的时候只用产品原包装盒来包装显然是不行的。必须把内装产品的包装盒放到一个邮局指定的专用纸箱里，这样才能够邮寄。这里，产品包装盒相当于数据包，里面放着的产品相当于可用的数据，而专用纸箱就相当于帧，且一个帧中通常只有一个数据包。<br>注：Datagram: This is used in 2 layers. If the network protocol is IP, the unit of data is called Datagram. At transport layer, if protocol is UDP, we use datagram there as well. Hence, we differentiate them as UDP Datagram, IP Datagram. (参考链接:Definition of Network Units: Fragment, Segment, Packet, Frame, Datagram)</p>
<p>TCP数据流(TCP stream)</p>
<p>Wireshark中是这么定义的：相同四元组(源地址，源端口，目的地址，目的端口)的包就为一条TCP流，即一条流有很多个包。</p>

    </div>

    
    
    

    
	      <div style="text-align:center;color: #ccc;font-size:14px;">
		      ---------感谢您的阅读，祝您生活愉快~---------
	      </div>
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>Buy me a piece of 辣条</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.jpg" alt="nono 微信">
        <span>微信</span>
      </div>

  </div>
</div>

          <div class="followme">
  <span>欢迎关注我的其它发布渠道</span>

  <div class="social-list">

      <div class="social-item">
        <a target="_blank" class="social-link" href="https://mp.weixin.qq.com/s/P8xgWvYc4HT5Mjn28VZQTw">
          <span class="icon">
            <i class="fab fa-weixin"></i>
          </span>

          <span class="label">WeChat</span>
        </a>
      </div>

      <div class="social-item">
        <a target="_blank" class="social-link" href="/atom.xml">
          <span class="icon">
            <i class="fa fa-rss"></i>
          </span>

          <span class="label">RSS</span>
        </a>
      </div>
  </div>
</div>

          <div class="post-tags">
              <a href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag"><i class="fa fa-tag"></i> 学习</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/undefined/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/C-%E8%AF%AD%E8%A8%80/c-primer-plus%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0%E9%A2%98%E9%9B%86%E5%90%88/" rel="prev" title="C++_Primer_Plus课后练习题集合">
                  <i class="fa fa-chevron-left"></i> C++_Primer_Plus课后练习题集合
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/undefined/%E6%80%9D%E8%80%83/20%E5%B2%81%E7%9A%84%E5%A4%A9%E7%A9%BA/" rel="next" title="20岁的天空">
                  20岁的天空 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






      <div class="tabs tabs-comment">
        <ul class="nav-tabs">
            <li class="tab"><a href="#comment-gitalk">gitalk</a></li>
            <li class="tab"><a href="#comment-livere">livere</a></li>
        </ul>
        <div class="tab-content">
            <div class="tab-pane gitalk" id="comment-gitalk">
              <div class="comments gitalk-container"></div>
            </div>
            <div class="tab-pane livere" id="comment-livere">
              <div class="comments" id="lv-container" data-id="city" data-uid="MTAyMC81NTk2OC8zMjQzMQ=="></div>
            </div>
        </div>
      </div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">nono</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">109k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:39</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>



    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/pace.js"></script>

  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





<!--使用 Gitter 实现一个 IM 即时通讯聊天室功能-->
<script>
  ((window.gitter = {}).chat = {}).options = {
    room: 'enjoytoshare/community'
  };
</script>
<script src="https://sidecar.gitter.im/dist/sidecar.v1.js" async defer></script>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":null,"repo":null,"client_id":null,"client_secret":null,"admin_user":null,"distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":null,"js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js","integrity":"sha256-Pmj85ojLaPOWwRtlMJwmezB/Qg8BzvJp5eTzvXaYAfA="},"path_md5":"58349f253957461050328c03bb99172b"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>
<script src="/js/third-party/comments/livere.js"></script>

</body>
</html>
